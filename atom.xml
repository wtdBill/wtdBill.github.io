<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Eric笔记</title>
  
  <subtitle>Eric笔记</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.yppcat.top/"/>
  <updated>2022-12-06T12:45:21.299Z</updated>
  <id>http://www.yppcat.top/</id>
  
  <author>
    <name>Eric笔记</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>IO加解密核心与dex文件改造过程分析</title>
    <link href="http://www.yppcat.top/2022/12/06/IO%E5%8A%A0%E8%A7%A3%E5%AF%86%E6%A0%B8%E5%BF%83%E4%B8%8Edex%E6%96%87%E4%BB%B6/"/>
    <id>http://www.yppcat.top/2022/12/06/IO加解密核心与dex文件/</id>
    <published>2022-12-06T12:33:42.000Z</published>
    <updated>2022-12-06T12:45:21.299Z</updated>
    
    <content type="html"><![CDATA[<p><strong>IO及序列化</strong></p><p>IO及序列化学习完成后，我能用用他们做什么？<br>数据的加解密<br>文件的读写<br>网络数据的传输</p><p><strong>加解密的核心原理</strong></p><p>加密原理其实很简单，通俗的说就是打乱所加密文件的内容，举个简单例子：你的桌面图标是不是可以按顺序排列，按时间排列，按大小排列，按内容排列？对的就是这个原理 加密就是打乱信息内容，比如把第一个字放在最后，在吧最后一个字放在前面，按照一定的算法，给一个自己编写的函数，比如递归加密，异或加密等等，解密的时候倒过来解密，异或加密，倒过来解密就是先或在异。 有的加密，把内容打乱后在进行2次整体加密。。完了后在加…… 其实不用加密软软件：我根据加密的原理自己手动加密，一个简单的方法。。你把文件后缀名改掉，比如JPG，改成CHM,log.WIN等等。。个人倾向改成系统问价后缀，然后把改了的文件在压缩，，压缩后在吧压缩文件后缀RAR在改掉、、，，恶心吧。。多改几次。。别人怎么能打开？当然你的指导顺序在改回来。。一般我是最后改成INF或者COM系统后缀放在C盘的系统问文件夹下面。。。一般别人也不会动、。</p><p><strong>数字签名-哈希散列</strong></p><p><strong>MD5算法:</strong><br>MD5 用的是 哈希函数，它的典型应用是对一段信息产生 信息摘要，以 防止被篡改。严格来说，MD5 不是一种 加密算法 而是 摘要算法。无论是多长的输入，MD5 都会输出长度为 128bits 的一个串 (通常用 16 进制 表示为 32 个字符)。。<br>对称加密和非对称加密<br>加密算法分 对称加密 和 非对称加密，其中对称加密算法的加密与解密 密钥相同，非对称加密算法的加密密钥与解密 密钥不同，此外，还有一类 不需要密钥 的 散列算法。</p><p><strong>SHA1算法：</strong><br>HA1 是和 MD5 一样流行的 消息摘要算法，然而 SHA1 比 MD5 的 安全性更强。对于长度小于 2 ^ 64 位的消息，SHA1 会产生一个 160 位的 消息摘要。基于 MD5、SHA1 的信息摘要特性以及 不可逆 (一般而言)，可以被应用在检查 文件完整性 以及 数字签名 等场景。</p><p><strong>对称加密与非对称加密</strong></p><p><strong>AES算法:</strong><br>AES 加密算法是密码学中的 高级加密标准，该加密算法采用 对称分组密码体制，密钥长度的最少支持为 128 位、 192 位、256 位，分组长度 128 位，算法应易于各种硬件和软件实现。这种加密算法是美国联邦政府采用的 区块加密标准。</p><p><strong>RSA算法：</strong><br>RSA 加密算法是目前最有影响力的 公钥加密算法，并且被普遍认为是目前 最优秀的公钥方案 之一。RSA 是第一个能同时用于 加密 和 数字签名 的算法，它能够 抵抗 到目前为止已知的 所有密码攻击，已被 ISO 推荐为公钥数据加密标准。</p><p><strong>ECC算法：</strong><br>ECC 也是一种 非对称加密算法，主要优势是在某些情况下，它比其他的方法使用 更小的密钥，比如 RSA 加密算法，提供 相当的或更高等级 的安全级别。不过一个缺点是 加密和解密操作 的实现比其他机制 时间长 (相比 RSA 算法，该算法对 CPU 消耗严重)。。</p><p><strong>各算法比较</strong></p><p><strong>散列</strong></p><p><strong>对称加密算法</strong></p><p><strong>非对称算法</strong></p><p><strong>大厂中加密思想：算法自定义，数学与性能的考虑，CPU利用与汇编底层的融合</strong></p><h2 id="APK反编译原理及实战"><a href="#APK反编译原理及实战" class="headerlink" title="APK反编译原理及实战"></a><strong>APK反编译原理及实战</strong></h2><p><strong>加固的总体思想</strong></p><p>一个程序员的故事：<br>辛辛苦苦找到一个对象，婚后家里主权为大，老婆管钱，导致这程序员木有经费去做一些爱做的事情。然而这个程序员很努力，平时除了上班，还能够做点外包，赚点外快。 所以他就想到了把工资卡上交，而把赚到的外快放到了自己的小金库。从此过上了性福生活。<br>结果被你反手一掏，小金库没了，从此欲哭无泪。<br>钱 = 代码<br>金库 = 编译过程<br>反手一套 = 破解过程</p><p><strong>加固基本原理</strong></p><p><strong>Dex文件 是什么？</strong></p><p>加固的目的是保护dex，直接而言就是对dex文件进 行操作，对dex文件动刀子，必须知道dex文件是什 么，能否直接动刀子。什么是源dex？什么是壳dex？</p><p><strong>Apk打包 流程</strong></p><p>加壳是在原来apk的基础上加一层保护壳，dex文件 修改了就需要重新打包，否则apk安装不了。这就需 要我们详细学习apk如何打包的，</p><p><strong>Dex文件加 载流程</strong></p><p>加壳后的文件是不能直接用的，dex文件是加密的， 所以我们需要对他进行解密，解密后的dex文件如何 加载？</p><p><strong>APK加载流程</strong></p><p><strong>加壳步骤</strong></p><p>1、制作原始项目的apk，这里称作original.apk；<br>2、制作一个壳项目（具体功能见ps），编译通过后得到它的classes.dex文件，这里称作shell.dex，而壳项目的apk称作shell.apk（需要签名）；<br>3、制作一个加壳工具（java工程就可以），按照以下流程工作：<br>1）读取original.apk的byte流，并加密；<br>2）读取shell.dex的byte流；<br>3）new一个新的byte数组，长度为1）和2）的长度之和+4，因为我们要在shell.dex中保存original.apk的长度；<br>4）在new byte数组中写入2），写入1），写入1）的长度；<br>5）根据dex文件的结构，修改checksum文件头、Signature文件头和file_size文件头，最终生成一个新的classes.dex；<br>4、替换掉2中的shell.apk中的classes.dex，并使用工具重新签名；<br>5、生成的新签名apk就是我们加壳过的apk了。</p><p><strong>脱壳流程</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;IO及序列化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;IO及序列化学习完成后，我能用用他们做什么？&lt;br&gt;数据的加解密&lt;br&gt;文件的读写&lt;br&gt;网络数据的传输&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;加解密的核心原理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;加密原理其实很简单，通俗的
      
    
    </summary>
    
    
      <category term="IO" scheme="http://www.yppcat.top/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>序列化</title>
    <link href="http://www.yppcat.top/2022/12/06/%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>http://www.yppcat.top/2022/12/06/序列化/</id>
    <published>2022-12-06T02:50:54.000Z</published>
    <updated>2022-12-06T03:11:25.646Z</updated>
    
    <content type="html"><![CDATA[<p><strong>序列化定义以及相关概念</strong></p><p>由于在系统底层，数据的传输形式是简单的字节序列形式传递，即在底层，系统不认识对象，只认识字节序列，而为了达到进程通讯的目的，需要先将数据序列化，而序列化就是将对象转化字节序列的过程。相反地，当字节序列被运到相应的进程的时候，进程为了识别这些数据，就要将其反序列化，即把字节序列转化为对象</p><p>无论是在进程间通信、本地数据存储又或者是网络数据传输都离不开序列化的支持。而针对不同场景选择合适的序列化方案对于应用的性能有着极大的影响。</p><p>从广义上讲，数据序列化就是将数据结构或者是对象转换成我们可以存储或者传输的数据格式的一个过程，在序列化的过程中，数据结构或者对象将其状态信息写入到临时或者持久性的存储区中，而在对应的反序列化过程中，则可以说是生成的数据被还原成数据结构或对象的过程。</p><p>序列化本质上其实就是将数据结构或对象转换成二进制串的过程。<br>反序列化本质是将在序列化过程中所生成的二进制串转换成数据结构或者对象的过程</p><p><strong>数据结构、对象与二进制串</strong></p><p>不同的计算机语言中，数据结构，对象以及二进制串的表示方式并不相同。</p><p>数据结构和对象：对于类似 Java 这种完全面向对象的语言，工程师所操作的一切都是对象（Object），来自于类的实例化。在 Java 语言中最接近数据结构的概念，就是 POJO（Plain Old JavaObject）或者 Javabean－－那些只有 setter/getter 方法的类。而在 C 二进制串：序列化所生成的二进制串指的是存储在内存中的一块数据。C 语言的字符串可以直接被传输层使用，因为其本质上就是以’0’结尾的存储在内存中的二进制串。在 Java 语言里面，二进制串的概念容易和String 混淆。实际上String 是 Java 的一等公民，是一种特殊对象（Object）。对于跨语言间的通讯，序列化后的数据当然不能是某种语言的特殊数据类型。二进制串在 Java 里面所指的是 byte[]，byte 是 Java 的 8 中原生数据类型之一（Primitive data types）。</p><p><strong>序列化协议特性</strong></p><p><strong>通用性</strong><br>技术层面，序列化协议是否支持跨平台、跨语言。如果不支持，在技术层面上的通用性就大大降低了。<br>流行程度，序列化和反序列化需要多方参与，很少人使用的协议往往意味着昂贵的学习成本；另一方面，流行度低的协议，往往缺乏稳定而成熟的跨语言、跨平台的公共包。</p><p><strong>强健性 / 鲁棒性</strong><br>成熟度不够<br>语言 / 平台的不公平性</p><p><strong>可调试性 / 可读性</strong><br>支持不到位<br>访问限制</p><p><strong>性能</strong><br>性能包括两个方面，时间复杂度和空间复杂度。<br>空间开销（Verbosity）， 序列化需要在原有的数据上加上描述字段，以为反序列化解析之用。如果序列化过程引入的额外开销过高，可能会导致过大的网络，磁盘等各方面的压力。对于海量分布式存储系统，数据量往往以 TB 为单位，巨大的的额外空间开销意味着高昂的成本。<br>时间开销（Complexity），复杂的序列化协议会导致较长的解析时间，这可能会使得序列化和反序列化阶段成为整个系统的瓶颈。</p><p><strong>可扩展性 / 兼容性</strong><br>移动互联时代，业务系统需求的更新周期变得更快，新的需求不断涌现，而老的系统还是需要继续维护。如果序列化协议具有良好的可扩展性，支持自动增加新的业务字段，而不影响老的服务，这将大大提供系统的灵活度。<br><strong>安全性 / 访问限制</strong><br>在序列化选型的过程中，安全性的考虑往往发生在跨局域网访问的场景。当通讯发生在公司之间或者跨机房的时候，出于安全的考虑，对于跨局域网的访问往往被限制为基于 HTTP/HTTPS 的 80 和 443 端口。如果使用的序列化协议没有兼容而成熟的 HTTP 传输层框架支持，可能会导致以下三种结果之一：<br>因为访问限制而降低服务可用性；<br>被迫重新实现安全协议而导致实施成本大大提高；<br>开放更多的防火墙端口和协议访问，而牺牲安全性<br><strong>注意点：Android的Parcelable也有安全漏洞</strong></p><p><strong>广义上的序列化和反序列化协议</strong></p><p><strong>XML&amp;SOAP</strong><br><strong>XML</strong> 是一种常用的序列化和反序列化协议，具有跨机器，跨语言等优点，SOAP（Simple ObjectAccess protocol） 是一种被广泛应用的，基于 XML 为序列化和反序列化协议的结构化消息传递协议<br><strong>JSON</strong> 起源于弱类型语言 Javascript， 它的产生来自于一种称之为”Associative array”的概念，其本质是就是采用”Attribute－value”的方式来描述对象。实际上在 Javascript 和 PHP 等弱类型语言中，类的描述方式就是 Associative array。JSON 的如下优点，使得它快速成为最广泛使用的序列化协议之一。这种 Associative array 格式非常符合工程师对对象的理解。它保持了 XML 的人眼可读（Human-readable）的优点。相对于 XML 而言，序列化后的数据更加简洁。 来自于的以下链接的研究表明：XML 所产生序列化之后文件的大小接近 JSON 的两倍它具备 Javascript 的先天性支持，所以被广泛应用于 Web browser 的应用常景中，是 Ajax 的事实标准协议。与 XML 相比，其协议比较简单，解析速度比较快。松散的 Associative array 使得其具有良好的可扩展性和兼容性<br><strong>Protobuf</strong><br>Protobuf 具备了优秀的序列化协议的所需的众多典型特征。<br>标准的 IDL 和 IDL 编译器，这使得其对工程师非常友好。<br>序列化数据非常简洁，紧凑，与 XML 相比，其序列化之后的数据量约为 1/3 到 1/10。<br>解析速度非常快，比对应的 XML 快约 20-100 倍。<br>提供了非常友好的动态库，使用非常简介，反序列化只需要一行代码。</p><p><strong>Android人员如何去选择序列化方案</strong></p><p>Serializable接口<br>Serializable 用来标识当前类可以被 ObjectOutputStream 序列化，以及被 ObjectInputStream 反序列化。</p><p>Parcelable接口<br>Parcelable是Android为我们提供的序列化的接口,Parcelable相对于Serializable的使用相对复杂一些,但Parcelable的效率相对Serializable也高很多,这一直是Google工程师引以为傲的,有时间的可以看一下Parcelable和Serializable的效率对比 Parcelable vs Serializable 号称快10倍的效率</p><p><strong>Serialzable接口</strong></p><p>JAVA提供，依赖于ObjectOutputStream/ObjectInputStream进行操作</p><p><strong>序列化经常会遇到的问题</strong></p><p>1.什么是serialVersionUID，如果不定义这个，会发生什么？</p><p>2.假设你有一个类，他序列化并存储在持久性中，然后修改了该类以添加新字段。如果对已序列化的对象进行反序列化会发生什么情况？</p><p>serialVersionUID的作用<br>serialVersionUID 用来表明类的不同版本间的兼容性。如果你修改了此类, 要修改此值。否则以前用老版本的类序列化的类恢复时会报错: InvalidClassException</p><p>为了在反序列化时，确保类版本的兼容性，最好在每个要序列化的类中加入 private static final long serialVersionUID这个属性，具体数值自己定义。这样，即使某个类在与之对应的对象 已经序列化出去后做了修改，该对象依然可以被正确反序列化。否则，如果不显式定义该属性，这个属性值将由JVM根据类的相关信息计算，而修改后的类的计算 结果与修改前的类的计算结果往往不同，从而造成对象的反序列化因为类版本不兼容而失败。不显式定义这个属性值的另一个坏处是，不利于程序在不同的JVM之间的移植。因为不同的编译器实现该属性值的计算策略可能不同，从而造成虽然类没有改变，但是因为JVM不同，出现因类版本不兼容而无法正确反序列化的现象出现</p><p>因此 JVM 规范强烈 建议我们手动声明一个版本号，这个数字可以是随机的，只要固定不变就可以。同时最好是 private 和 final 的，尽量保证不变。</p><p>3.序列化时，你希望某些成员不要序列化？你如何实现它？</p><p>有时候也会变着形式去问，比如问什么是瞬态trasient 变量？瞬态变量和静态变量会不会得到序列化等，所以，如果你不希望字段是对象状态的一部分，然后声明他静态或者瞬态，根据你的需要，他不会被包含在序列化过程之内</p><p>4.为什么序列化一定需要一个无参构造？</p><p>在序列化的过程中，他将构造函数的信息数据存储在ObjectStreamClass的类中，反序列化是提取到当前数据，拿到cons中的构造属性进行反射调用无参构造</p><p><strong>Parcelable</strong></p><p>Parcelable是因为，在android体系当中，为了应用层面使用便捷，在数据的传输过程中，能够直接应用JAVABean进行数据处理，但是传统的serializable依赖于IO，对于android特定场景跨进程间通信来说效率太慢，大量的应用IO会导致各种资源损耗，所以android另外开辟一套序列化方案，本质上也还是对于JAVA类对象的序列化与反序列化，但是其核心目的是为了解决跨进程间通信问题，而不是为了网络数据传输与持久化保存数据，所以他依托于Binder机制，去掉IO，将数据的传输层应用在内存角度。导致其速度比serializable快</p><p><strong>Parcelable与Serializable对比</strong></p><table><thead><tr><th><strong>类型</strong></th><th><strong>Serializable</strong></th><th><strong>Parcelable</strong></th></tr></thead><tbody><tr><td>操作方案</td><td>通过IO操作，速度慢</td><td>直接在内存操作，效率高</td></tr><tr><td>数据大小</td><td>大小不受限制</td><td>因为Binder，一般不超过1M</td></tr><tr><td>其他</td><td>大量反射，内存碎片多</td></tr></tbody></table><p><strong>面试相关</strong></p><p>1.反序列化后的对象，需要调用构造函数重新构造吗？</p><p>反序列化时，类的构造函数不会被执行</p><p>2.序列前的对象与序列化后的对象是什么关系？==？equal?浅复制？深复制？</p><p>深复制</p><p>3.SerialVersionID的作用是什么？</p><p>4.Android中Intent/Bundle的通信原理及大小限制</p><p>Bundle内部是由ArrayMap实现的，ArrayMap的内部实现是两个数组，一个int数组是存储对象数据对应下标，一个对象数组保存key和value，内部使用二分法对key进行排序，所以在添加、删除、查找数据的时候，都会使用二分法查找，只适合于小数据量操作，如果在数据量比较大的情况下，那么它的性能将退化。而HashMap内部则是数组+链表结构，所以在数据量较少的时候，HashMap的Entry Array比ArrayMap占用更多的内存。因为使用Bundle的场景大多数为小数据量，我没见过在两个Activity之间传递10个以上数据的场景，所以相比之下，在这种情况下使用ArrayMap保存数据，在操作速度和内存占用上都具有优势，因此使用Bundle来传递数据，可以保证更快的速度和更少的内存占用。另外一个原因，则是在Android中如果使用Intent来携带数据的话，需要数据是基本类型或者是可序列化类型，HashMap使用Serializable进行序列化，而Bundle则是使用Parcelable进行序列化。而在Android平台中，更推荐使用Parcelable实现序列化，虽然写法复杂，但是开销更小，所以为了更加快速的进行数据的序列化和反序列化，系统封装了Bundle类，方便我们进行数据的传输。</p><p>Intent 中的 Bundle 是使用 Binder 机制进行数据传送的。能使用的 Binder 的缓冲区是有大小限制的（有些手机是 2 M），而一个进程默认有 16 个 Binder 线程，所以一个线程能占用的缓冲区就更小了（ 有人以前做过测试，大约一个线程可以占用 128 KB）。所以当你看到 The Binder transaction failed because it was too large 这类 TransactionTooLargeException 异常时，你应该知道怎么解决了</p><p>5.为何Intent不能直接在组件间传递对象，而要通过序列化</p><p>Intent在启动其他组件时，会离开当前应用程序进程，进入ActivityManagerService进程（intent.prepareToLeaveProcess()），这也就意味着，Intent所携带的数据要能够在不同进程间传输。首先我们知道，Android是基于Linux系统，不同进程之间的java对象是无法传输，所以我们此处要对对象进行序列化，从而实现对象在 应用程序进程 和 ActivityManagerService进程 之间传输。而Parcel或者Serializable都可以将对象序列化，其中，Serializable使用方便，但性能不如Parcel容器，后者也是Android系统专门推出的用于进程间通信等的接口</p><p>6.序列化与持久化的关系和区别是什么？</p><p>序列化可以将一个复杂的对象转化为一维的数据，而这为持久化提供了很大的方便，因为文件就是一维的，将一维的东西写入文件自然比较方便。</p><p>不过持久化是个很宽泛的概念，可以是写入文件，也可以是存入数据库，写入注册表等多种方式。其本意是延长对象或数据的生命周期，让其可以超越程序的生命周期，程序关闭了，甚至服务器关机了，下次运行程序时又可以让对象或数据恢复到原来的状态。</p><p>而序列化也不一定是用来持久化的，可以是用来传递使用，如从计算机A传递到计算机B；也可以用来进行深拷贝；总之序列化主要解决从复杂的数据结构转化为一维结构，或者从一维结构从新构建复杂的数据结构</p><p><strong>总结</strong></p><p><strong>什么是序列化?</strong><br>本质上就是一套固定数据格式的方案<br>Parcelable与serializable本质区别<br><strong>应用角度：</strong><br>Parcelable目的是为了支持跨进程间数据通信<br>Serializable目的是提供对于JAVA对象的序列化支持，他考虑的场景覆盖全面，IO</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;序列化定义以及相关概念&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于在系统底层，数据的传输形式是简单的字节序列形式传递，即在底层，系统不认识对象，只认识字节序列，而为了达到进程通讯的目的，需要先将数据序列化，而序列化就是将对象转化字节序列的过程。相反地，当字节序列被
      
    
    </summary>
    
    
      <category term="IO" scheme="http://www.yppcat.top/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>BIO与NIO</title>
    <link href="http://www.yppcat.top/2022/12/05/BIO%E4%B8%8ENIO/"/>
    <id>http://www.yppcat.top/2022/12/05/BIO与NIO/</id>
    <published>2022-12-05T08:33:28.000Z</published>
    <updated>2022-12-05T08:53:54.845Z</updated>
    
    <content type="html"><![CDATA[<p><strong>android 人员对于IO的诉求</strong></p><p>IO对于系统的影响<br>性能层面基础的单位影响<br><strong>使用率</strong>：是指磁盘处理io的时间百分比。过高的使用率(比如超过80%)，通常意味着磁盘io存在性能瓶颈。<br><strong>饱和度</strong>：是指磁盘处理io的繁忙程度。过高的饱和度，意味着磁盘存在着严重的性能瓶颈。当饱和度为100%时，磁盘无法接受新的io请求。<br><strong>IOPS</strong>：是指每秒的io请求数，适用于大量小文件的情景<br><strong>吞吐量</strong>：是指每秒的io请求大小，适用与大文件的情景响应时间：是指io请求从发出到收到响应的时间间隔<br>IO模型对于性能的影响<br><strong>阻塞IO、非阻塞IO、复用IO、信号驱动IO、异步IO</strong></p><p>android对于IO需要注意的场景<br>1.设备（手机）作为S端<br>2.IO复用可能导致的空指针<br>3.设备数据的传递<br>4.dex加壳与脱壳<br>IO的优化是在解决CPU的瓶颈问题，但是通常在C端喝少会出现，所以在学习IO的角度上来说，我们不会吧重点放在CPU瓶颈的解决，而是会探寻IO本质原理及序列化的应用与Dex文件的加壳脱壳</p><p><strong>IO的基本常识-内核空间</strong></p><p>在对于IO学习之前， 我们首先需要了解一定的常识，比如内核、JVM、堆区、这些概念是必备的</p><p>内核=一套软件，操作系统用于支撑基础使用的功能程序</p><p>APP=上层应用–》很多基础功能是需要调用内核去进行完成</p><img src="/2022/12/05/BIO与NIO/image-20221205163514704.png" title="[BIO与NIO]"><p><strong>数据读写的方案</strong></p><img src="/2022/12/05/BIO与NIO/image-20221205163537391.png" title="[BIO与NIO]"><p><strong>内核（linux）的IO栈</strong></p><p><strong>我们可以吧Linux存储系统的io栈，由上到下分为三个层次，分别是文件系统层、通用块层和设备层。</strong><br><strong>文件系统层</strong>，包括虚拟文件系统和其他各种文件系统的具体实现。它为上层的应用程序，提供标准的文件访问接口；对下会通过通用块层，来存储和管理磁盘数据。<br><strong>通用块层</strong>，包括块设备io队列和io调度器。它会对文件系统的io请求进行排队，再通过重新排序和请求合并，然后才发送给下一级的设备层。<br><strong>设备层</strong>，包括存储设备和相应的驱动程序，负责最终物理设备的io操作。<br>存储系统的io，通常是整个系统中最慢的一环。所以，Linux通过多种缓存机制来优化io效率。<br>为了优化存储系统访问文件的性能，会使用页缓存、索引节点缓存、目录项缓存等多种缓存机制，以及减少对下层块设备的直接调用。<br>为了优化块设备的访问效率，会使用缓冲区，来缓存块设备的数据。</p><p><strong>内核空间对于IO的操作方案</strong></p><p>页：4K数据为一页， 一页数据是IO操作的基本单位</p><p>空间局部性原理：在常规操作下， 如果数据量较大的情况下可能会出现预占位4~16K的情况</p><p><strong>JAVA 对于Basic IO 的支撑</strong></p><p>Basic IO : API提供的基础功能分析及相关应用场景与特点</p><img src="/2022/12/05/BIO与NIO/image-20221205163812378.png" title="[BIO与NIO]"><p><strong>MappedByteBuffer缓冲区</strong></p><p>java io操作中通常采用BufferedReader，BufferedInputStream等带缓冲的IO类处理大文件，不过java nio中引入了一种基于MappedByteBuffer操作大文件的方式，其读写性能极高</p><p>FileChannel提供了map方法<strong>把文件映射到虚拟内存</strong>，通常情况可以映射整个文件，如果文件比较大，可以进行分段映射。</p><p>MappedByteBuffer使用虚拟内存，因此分配(map)的内存大小不受JVM的-Xmx参数限制，但是也是有大小限制的。<br>如果当文件超出1.5G限制时，可以通过position参数重新map文件后面的内容。<br>MappedByteBuffer在处理大文件时的确性能很高，但也存在一些问题，如内存占用、文件关闭不确定，被其打开的文件只有在垃圾回收的才会被关闭，而且这个时间点是不确定的。<br>javadoc中也提到：A mapped byte buffer and the file mapping that it represents remain valid until the buffer itself is garbage-collected.*</p><p><strong>性能分析</strong></p><p>从代码层面上看，从硬盘上将文件读入内存，都要经过文件系统进行数据拷贝，并且数据拷贝操作是由文件系统和硬件驱动实现的，理论上来说，拷贝数据的效率是一样的。<br>但是通过内存映射的方法访问硬盘上的文件，效率要比read和write系统调用高，这是为什么？</p><p>read()是系统调用，首先将文件从硬盘拷贝到内核空间的一个缓冲区，再将这些数据拷贝到用户空间，实际上进行了两次数据拷贝；<br>map()也是系统调用，但没有进行数据拷贝，当缺页中断发生时，直接将文件从硬盘拷贝到用户空间，只进行了一次数据拷贝。<br>所以，采用内存映射的读写效率要比传统的read/write性能高。</p><p><strong>IO模型概念</strong></p><p>IO分两阶段进行：<br>1.数据准备阶段<br>2.内核空间复制回用户进程缓冲区阶段</p><p>所谓模型就是在这两阶段当中的实现方案</p><p><strong>POSIX</strong></p><p>POSIX(可移植操作系统接口)把同步IO操作定义为导致进程阻塞直到IO完成的操作，反之则是异步IO</p><p><strong>阻塞IO模型</strong>：使用recv的默认参数一直等数据直到拷贝到用户空间，这段时间内进程始终阻塞。A同学用杯子装水，打开水龙头装满水然后离开。这一过程就可以看成是使用了阻塞IO模型，因为如果水龙头没有水，他也要等到有水并装满杯子才能离开去做别的事情。很显然，这种IO模型是同步的。</p><p><strong>非阻塞IO模型</strong>：改变flags，让recv不管有没有获取到数据都返回，如果没有数据那么一段时间后再调用recv看看，如此循环。B同学也用杯子装水，打开水龙头后发现没有水，它离开了，过一会他又拿着杯子来看看……在中间离开的这些时间里，B同学离开了装水现场(回到用户进程空间)，可以做他自己的事情。这就是非阻塞IO模型。但是它只有是检查无数据的时候是非阻塞的，在数据到达的时候依然要等待复制数据到用户空间(等着水将水杯装满)，因此它还是同步IO。</p><p><strong>传统阻塞IO</strong></p><img src="/2022/12/05/BIO与NIO/image-20221205164232129.png" title="[BIO与NIO]"><p><strong>非阻塞IO</strong></p><img src="/2022/12/05/BIO与NIO/image-20221205164249479.png" title="[BIO与NIO]"><p><strong>IO复用模型</strong></p><img src="/2022/12/05/BIO与NIO/image-20221205164310776.png" title="[BIO与NIO]"><p>这里在调用recv前先调用select或者poll，这2个系统调用都可以在内核准备好数据(网络数据到达内核)时告知用户进程，这个时候再调用recv一定是有数据的。因此这一过程中它是阻塞于select或poll，而没有阻塞于recv，有人将非阻塞IO定义成在读写操作时没有阻塞于系统调用的IO操作(不包括数据从内核复制到用户空间时的阻塞，因为这相对于网络IO来说确实很短暂)，如果按这样理解，这种IO模型也能称之为非阻塞IO模型，但是按POSIX来看，它也是同步IO，那么也和楼上一样称之为同步非阻塞IO吧。</p><p>这种IO模型比较特别，分个段。因为它能同时监听多个文件描述符(fd)。这个时候C同学来装水，发现有一排水龙头，舍管阿姨告诉他这些水龙头都还没有水，等有水了告诉他。于是等啊等(select调用中)，过了一会阿姨告诉他有水了，但不知道是哪个水龙头有水，自己看吧。于是C同学一个个打开，往杯子里装水(recv)。这里再顺便说说鼎鼎大名的epoll(高性能的代名词啊)，epoll也属于IO复用模型，主要区别在于舍管阿姨会告诉C同学哪几个水龙头有水了，不需要一个个打开看(当然还有其它区别)。</p><p><strong>信号驱动IO模型</strong></p><img src="/2022/12/05/BIO与NIO/image-20221205164355709.png" title="[BIO与NIO]"><p>通过调用sigaction注册信号函数，等内核数据准备好的时候系统中断当前程序，执行信号函数(在这里面调用recv)。D同学让舍管阿姨等有水的时候通知他(注册信号函数)，没多久D同学得知有水了，跑去装水。是不是很像异步IO？很遗憾，它还是同步IO(省不了装水的时间啊)。</p><p><strong>异步IO模型</strong></p><img src="/2022/12/05/BIO与NIO/image-20221205164437205.png" title="[BIO与NIO]"><p>调用aio_read，让内核等数据准备好，并且复制到用户进程空间后执行事先指定好的函数。E同学让舍管阿姨将杯子装满水后通知他。整个过程E同学都可以做别的事情(没有recv)，这才是真正的异步IO。</p><p><strong>五种IO模型不同</strong></p><img src="/2022/12/05/BIO与NIO/image-20221205164505642.png" title="[BIO与NIO]"><p><strong>IO的五个模型故事解释</strong></p><img src="/2022/12/05/BIO与NIO/image-20221205164527837.png" title="[BIO与NIO]"><p><strong>OKIO对于JAVAIO的优化</strong></p><p>官方的解释是这样的：Okio是一个库，是对java.io和java.nio的补充，通过这个库，我们可以更简单的使用和存储我们的数据。</p><p>Okio提供了两种新的类型，这两种类型有很多新的功能，并且使用比较简单。这两中类型分别是：ByteString和Buffer。</p><p>ByteString是不可变的字节序列（请参考String，String是不可变的字符串）。String是基本的字符数据，ByteString相当于是String的兄弟，ByteString让处理二进制数据变得简单了。这个类是符合人们的编程习惯的，它知道怎么使用比如hax，base64,UTF-8等编码格式将它自己编码或解码。</p><p>Buffer是一个可变的字符序列。你不需要提前设置它的大小，它在写入数据的时候会将数据放在最后，而在读取的时候会在最前面开始读取（这很类似与队列），你也不需要关心它的位置，限制，容量等等。</p><p><strong>OKIO 采取的方案</strong></p><p>OKIO在读取数据时，先从Buffer对象中获取了一个Segment，然后向Segment中读取数据，每个Segment最多可以存入8K数据。这里需要提一下Buffer中数据的数据结构，Buffer中的数据是存在于一个双向链表中，链表中的每个节点都是一个Segment</p><img src="/2022/12/05/BIO与NIO/image-20221205164615902.png" title="[BIO与NIO]"><img src="/2022/12/05/BIO与NIO/image-20221205164632285.png" title="[BIO与NIO]"><p><strong>OKIO 解决了什么</strong></p><p>不管是读入还是写出，缓冲区的存在必然涉及copy的过程，而如果涉及双流操作，比如从一个输入流读入，再写入到一个输出流，那么这种情况下，在缓冲存在的情况下，数据走向是：<br>-&gt; 从输入流读出到缓冲区<br>-&gt; 从输入流缓冲区copy到 b[]<br>-&gt; 将 b[] copy 到输出流缓冲区<br>-&gt; 输出流缓冲区读出数据到输出流</p><p>OK是将两个缓冲合并成一份</p><p><strong>Okio核心竞争力</strong>为，增强了流于流之间的互动，使得当数据从一个缓冲区移动到另一个缓冲区时，可以不经过copy能达到：</p><p>以Segment作为存储结构，真实数据以类型为byte[]的成员变量data存在，并用其它变量标记数据状态，在需要时，如果可以，移动Segment引用，而非copy data数据<br>Segment在Segment线程池中以单链表存在以便复用，在Buffer中以双向链表存在存储数据，head指向头部，是最老的数据<br>Segment能通过slipt()进行分割，可实现数据共享，能通过compact()进行合并。由Buffer来进行数据调度，基本遵守 “大块数据移动引用，小块数据进行copy” 的思想<br>Source 对应输入流，Sink 对应输出流<br>TimeOut 以达到在期望时间内完成IO操作的目的，同步超时在每次IO操作中检查耗时，异步超时开启另一线程间隔时间检查耗时</p><p>OK核心是解决双流操作的问题</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;android 人员对于IO的诉求&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;IO对于系统的影响&lt;br&gt;性能层面基础的单位影响&lt;br&gt;&lt;strong&gt;使用率&lt;/strong&gt;：是指磁盘处理io的时间百分比。过高的使用率(比如超过80%)，通常意味着磁盘io存在性能瓶颈
      
    
    </summary>
    
    
      <category term="IO" scheme="http://www.yppcat.top/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>AQS</title>
    <link href="http://www.yppcat.top/2022/12/05/AQS/"/>
    <id>http://www.yppcat.top/2022/12/05/AQS/</id>
    <published>2022-12-05T00:05:16.000Z</published>
    <updated>2022-12-05T00:16:55.258Z</updated>
    
    <content type="html"><![CDATA[<p><strong>什么是AQS？</strong></p><p>AQS，全程AbstractQueuedSynchronizer，位于java.util.concurrent.locks包下。</p><p>是JDK1.5提供的一套用于实现阻塞锁和一系列依赖FIFO等待队列的同步器(First Input First Output先进先出)的框架实现。是除了java自带的synchronized 关键字之外的锁机制。 可以将AQS作为一个队列来理解。</p><p>我们常用的ReentrantLock、Semaphore、CountDownLatch、CyclicBarrier等并发类均是基于AQS来实现的。具体用法是通过继承AQS，并实现其模板方法，来达到同步状态的管理。</p><p>AQS的功能在使用中可以分为两种:独占锁和共享锁<br>独占锁：每次只能有一个线程持有锁。eg: ReentrantLock就是独占锁<br>共享锁：允许多个线程同时获得锁，并发访问共享资源。eg: ReentrantReadWriteLock中的读</p><p><strong>AQS核心思想</strong></p><p>AQS核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</p><img src="/2022/12/05/AQS/image-20221205080624705.png" title="[AQS]"><p><strong>AQS使用方式</strong></p><p>AQS设计是基于模板方法模式的，一般的使用方式是：<br>使用者继承AbstractQueuedSynchronizer并重写指定的方法。（这些重写方法很简单，无非是对于共享资源state的获取和释放）</p><p>将AQS组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。</p><p>AQS定义的这些可重写的方法：<br>protected boolean tryAcquire(int arg): 独占式获取同步状态，试着获取，成功返回true，反之为false<br>protected boolean tryRelease(int arg) ：独占式释放同步状态，等待中的其他线程此时将有机会获取到同步状态；<br>protected int tryAcquireShared(int arg) ：共享式获取同步状态，返回值大于等于0，代表获取成功；反之获取失败；<br>protected boolean tryReleaseShared(int arg) ：共享式释放同步状态，成功为true，失败为false<br>protected boolean isHeldExclusively()： 是否在独占模式下被线程占用。</p><p><strong>AQS的模板方法</strong></p><p><strong>独占锁：</strong><br>void acquire(int arg);// 独占式获取同步状态，如果获取失败则插入同步队列进行等待；<br>void acquireInterruptibly(int arg);// 与acquire方法相同，但在同步队列中进行等待的时候可以检测中断；<br>boolean tryAcquireNanos(int arg, long nanosTimeout);// 在acquireInterruptibly基础上增加了超时等待功能，在超时时间内没有获得同步状态返回false;<br>boolean release(int arg);// 释放同步状态，该方法会唤醒在同步队列中的下一个节点</p><p><strong>共享锁：</strong><br>void acquireShared(int arg);// 共享式获取同步状态，与独占式的区别在于同一时刻有多个线程获取同步状态；<br>void acquireSharedInterruptibly(int arg);// 在acquireShared方法基础上增加了能响应中断的功能；<br>boolean tryAcquireSharedNanos(int arg, long nanosTimeout);// 在acquireSharedInterruptibly基础上增加了超时等待的功能；<br>boolean releaseShared(int arg);// 共享式释放同步状态</p><p>自定义，使用总结</p><p>首先，我们需要去继承AbstractQueuedSynchronizer这个类，然后我们根据我们的需求去重写相应的方法，比如要实现一个独占锁，那就去重写tryAcquire，tryRelease方法，要实现共享锁，就去重写tryAcquireShared，tryReleaseShared；</p><p>然后，在我们的组件中调用AQS中的模板方法就可以了，而这些模板方法是会调用到我们之前重写的那些方法的。也就是说，我们只需要很小的工作量就可以实现自己的同步组件，重写的那些方法，仅仅是一些简单的对于共享资源state的获取和释放操作，至于像是获取资源失败，线程需要阻塞之类的操作，自然是AQS帮我们完成了</p><p><strong>AQS源码分析</strong></p><p>AQS的基本实现：<br>    AQS维护一个共享资源state，通过内置的FIFO来完成获取资源线程的排队工作。（这个内置的同步队列称为”CLH”队列）。该队列由一个一个的Node结点组成，每个Node结点维护一个prev引用和next引用，分别指向自己的前驱和后继结点。AQS维护两个指针，分别指向队列头部head和尾部tail。<br>    当线程获取资源失败（比如tryAcquire时试图设置state状态失败），会被构造成一个结点加入CLH队列中，同时当前线程会被阻塞在队列中（通过LockSupport.park实现，其实是等待态）。当持有同步状态的线程释放同步状态时，会唤醒后继结点，然后此结点线程继续加入到对同步状态的争夺中。</p><img src="/2022/12/05/AQS/image-20221205080912795.png" title="[AQS]"><p><strong>ReentrantLock与AQS</strong></p><img src="/2022/12/05/AQS/image-20221205080936878.png" title="[AQS]"><p><strong>ReentrantLock加锁流程</strong>    </p><img src="/2022/12/05/AQS/image-20221205080956123.png" title="[AQS]"><img src="/2022/12/05/AQS/aqs加锁流程图.png" title="[AQS]"><p><strong>条件变量实现原理</strong></p><p>每个条件变量其实就对应着一个等待队列，其实现类是 ConditionObject</p><p>await 流程<br>开始 Thread-0 持有锁，调用 await，进入 ConditionObject 的 addConditionWaiter 流程<br>创建新的 Node 状态为 -2（Node.CONDITION），关联 Thread-0，加入等待队列尾部</p><img src="/2022/12/05/AQS/image-20221205081119159.png" title="[AQS]"><p><strong>同步方案对比</strong></p><p>wait/notify：依托于synchronized，基于VM底层对于阻塞的实现，使用waitSet作为等待机制，set结构的问题，要么是随机一个（set的提取算法），要么是全部提出来唤醒</p><p>await/signal：依赖于ReentrantLock条件变量，已经用条件变量与AQS体系作为唤醒机制，本质上底层是park/unpark实现阻塞</p><p>park/unpark:以thread为操作对象,操作更精准，可以准确地唤醒某一个线程（notify随机唤醒一个线程，notifyAll唤醒所有等待的线程），增加了灵活性。</p><p>其实park/unpark的设计原理核心是“许可”：park是等待一个许可，unpark是为某线程提供一个许可</p><p>但是这个“许可”是不能叠加的，“许可”是一次性的。<br>比如线程B连续调用了三次unpark函数，当线程A调用park函数就使用掉这个“许可”，如果线程A再次调用park，则进入等待状态。</p><p><strong>ReentrantReadWriteLock读写锁</strong></p><p><strong>读写锁指一个资源能够被多个读线程访问，或者被一个写线程访问，但是不能同时存在读写线程</strong><br>ReentrantReadWriteLock中有两个静态内部类：ReadLock读锁和WriteLock写锁，这两个锁实现了Lock接口ReentrantReadWriteLock支持可重入，同步功能依赖自定义同步器（AbstractQueuedSynchronizer）实现，读写状态就是其同步器的同步状态</p><p><strong>写锁的获取和释放</strong>：<br>写锁WriteLock是支持重进入的排他锁。如果当前线程已经获取了写锁，则增加写状态。如果当前线程在获取读锁时，读锁已经被获取或者该线程不是已获取写锁的线程，则当前线程进入等待状态。读写锁确保写锁的操作对读锁可见。写锁释放每次减少写状态，当前写状态为0时表示写锁已背释放。</p><p><strong>读锁的获取与释放：</strong><br>读锁ReadLock是支持重进入的共享锁（共享锁为shared节点，对于shared节点会进行一连串的唤醒，知道遇到一个读节点），它能够被多个线程同时获取，在没有其他写线程访问（写状态为0）时，读锁总是能够被成功地获取，而所做的也只是增加读状态（线程安全）。如果当前线程已经获取了读锁，则增加读状态。如果当前线程在获取读锁时，写锁已经被获取，则进入等待状态。</p><p><strong>CyclicBarrier和CountDownLatch</strong></p><p>CountDownLatch：一个或者多个线程，等待其他多个线程完成某件事情之后才能执行；</p><p>CyclicBarrier：多个线程互相等待，直到到达同一个同步点，再继续一起执行。而且可以重用</p><p>CountDownLatch是计数器，线程完成一个记录一个，只不过计数不是递增而是递减，而CyclicBarrier更像是一个阀门，需要所有线程都到达，阀门才能打开，然后继续执行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;什么是AQS？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;AQS，全程AbstractQueuedSynchronizer，位于java.util.concurrent.locks包下。&lt;/p&gt;
&lt;p&gt;是JDK1.5提供的一套用于实现阻塞锁和一系列依赖FIFO等待队列
      
    
    </summary>
    
    
      <category term="JUC" scheme="http://www.yppcat.top/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>线程池</title>
    <link href="http://www.yppcat.top/2022/12/03/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://www.yppcat.top/2022/12/03/线程池/</id>
    <published>2022-12-03T11:49:42.000Z</published>
    <updated>2022-12-03T12:03:06.462Z</updated>
    
    <content type="html"><![CDATA[<p><strong>异步模式之工作线程</strong></p><p>让有限的工作线程轮流异步处理无限多的任务，也可以将其归类为分工模式，他的典型实现就是线程池，也体现了经典设计模式中的享元模式</p><p>例如,海底捞的服务员（线程），轮流处理每位顾客的点餐（任务），如果每位顾客都配一个专属服务员，则成本太过高昂</p><p>注意：不同任务类型应该使用不同的线程池，这样能够避免饥饿现象，且效率上得到合理分配</p><p>线程饥饿现象：<br>    本质上是在出现多任务混合在同一个池中，如果出现相互影响的状况出现类似死锁的问题</p><p><strong>享元设计模式</strong></p><p>本质：运用内存共享的原理，去有效支撑大量的细颗粒度的对象</p><p>享元工厂：一个享元工厂，用来创建并管理对象，他主要是用来确保合理地共享对象，当用户请求一个对象是，由工厂提供一个已创建的对象示例或者创建一个</p><p>享元对象：一个重复的对象</p><p>使用场景：如果一个程序对于某个对象进行大量应用，且使用生命周期短，可以考虑采取享元模式进行复用</p><p><strong>线程数量与核心数</strong></p><p>处理器核数：<br>    线程核心数是一种执行资源，资源数量就是核的个数，应用程序的线程数就是服务请求数，而操作系统的作用如何调配有限的资源来服务更多的请求，这就是进程调度的概念。<br>一般情况下，服务其你去线程会“相对公平”的分配到核上运行，并且在时间片上轮流使用，这就是所谓的并发执行。</p><p>比如系统有4个核，如果<br>3个线程，分配到3个核上<br>8个线程，每个核分配两个线程执行<br>10个线程，有些核跑3个有些跑2个</p><p>所以，并非线程数量越大，速度越快，线程数量太过于庞大会导致各种内存问题，因为一个线程的开辟还会涉及到线程上下文的应用</p><p><strong>创建多少线程合适？</strong></p><img src="/2022/12/03/线程池/image-20221203195303524.png" title="[线程池]"><p><strong>CPU密集型运算：</strong><br>    通常采用CPU核数 + 1 能够实现最优的CPU利用率，+1是保证当线程由于页缺失故障（操作系统）或其他原因导致暂停时，额外的这个线程就能顶上去，保证CPU始终周期不被浪费</p><p><strong>I/O密集型运算：</strong><br>    CPU不总是处于繁忙状态，例如，当你执行业务计算时，这时候会使用CPU资源，但当你执行IO操作、或者远程的RPC调用时，包括进行数据库操作等，这个时候CPU会闲下来，你可以利用多线程提高他的利用率</p><p><strong>经验公式如下：</strong><br><strong>线程数 = 核数 <em> 期望CPU利用率 </em> 总时间（CPU计算时间+等待时间） / CPU计算时间</strong></p><p>例如：4核CPU，计算时间是50%，其他等待时间是50%，期望CPU被100%利用，套用公式<br>    4 <em> 100% </em> 100% / 50% = 8</p><p><strong>自定义线程池</strong></p><p>由主线程往一个队列中去添加任务，由线程池控制线程去进行消费</p><img src="/2022/12/03/线程池/image-20221203195417333.png" title="[线程池]"><p><strong>JDK中提供的线程池</strong></p><img src="/2022/12/03/线程池/image-20221203195509261.png" title="[线程池]"><p><strong>ThreadPoolExecutor</strong></p><p><strong>状态模型：</strong></p><img src="/2022/12/03/线程池/image-20221203195533485.png" title="[线程池]"><p><strong>构造方法</strong></p><img src="/2022/12/03/线程池/image-20221203195601076.png" title="[线程池]"><p><strong>工作模式</strong></p><img src="/2022/12/03/线程池/image-20221203195622021.png" title="[线程池]"><p><strong>JDK中的拒绝策略</strong></p><p>ThreadPoolExecutor自己已经提供了四个拒绝策略，分别是</p><p>CallerRunsPolicy：在任务被拒绝添加后，会调用当前线程池的所在的线程去执行被拒绝的任务。这个策略的缺点就是可能会阻塞主线程。</p><p>AbortPolicy：默认的拒绝策略就是AbortPolicy。直接抛出异常。抛出个RejectedExecutionException异常，也不执行这个任务了</p><p>DiscardPolicy：这个东西什么都没干。</p><p>DiscardOldestPolicy：当任务呗拒绝添加时，会抛弃任务队列中最旧的任务也就是最先加入队列的，再把这个新任务添加进去。</p><p><strong>变量压缩合并的好处</strong></p><img src="/2022/12/03/线程池/image-20221203195711488.png" title="[线程池]"><p><strong>合并算法</strong></p><p>目的：将另个整数值打包到一个整数值下</p><p>步骤：<br>    1.拆分短位与长位数值      短位=常量（状态）         长位 = 动态值（长度）<br>    2.打包算法   :<br>        长位 &amp; ~ mask | 短位 &amp; mask<br>    mask为分界位，如 一个整数值 短位占用3位，则长位占用29位，mask作用是用来对于短位数值进行换算，所有，如果短位需要占用三位则需要用111&lt;&lt;29位来占据前三位作为等值</p><p><strong>ThreadPoolExecutor与当前自定义的区别</strong></p><p>1.救急线程的应用<br>    提升性能</p><p>2.状态设置<br>    对于线程池的管理</p><p>3.原子合并<br>    利用位运算，进行CAS的优化</p><p>4.工厂模式的应用</p><p><strong>Timer缺点</strong></p><p>Timer的优点在于简单易用，但是由于所有任务都是同一线程来调度执行，所有任务是串行，如果前面任务有延迟，会影响后面任务执行</p><p>解决办法：<br>    ScheduledExecutorService<br>    线程池的调度</p><p><strong>fork/join线程池</strong></p><p>fork/join是JDK 1.7后加入的心得线程池实现，他主要体现是分治思想，适用于能够进行任务拆分的CPU密集型运算</p><p>他是为了处理大数据诞生的</p><p>所谓任务拆分，是将一个大任务拆分为算法上相同的小任务，直至不能拆分可以直接求解。跟递归相关的一些计算，如归并排序、斐波拉切数列，都可以进行分治完成</p><p>Fork/Join在分治的基础上加入了多线程，可以把每个任务的分解和合并交给不同的线程来完成，进一步提升运算效率</p><p>Fork/Join 默认会创建于CPU核心数大小相同的线程池</p><p>最常见业务，对于文件夹的操作</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;异步模式之工作线程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;让有限的工作线程轮流异步处理无限多的任务，也可以将其归类为分工模式，他的典型实现就是线程池，也体现了经典设计模式中的享元模式&lt;/p&gt;
&lt;p&gt;例如,海底捞的服务员（线程），轮流处理每位顾客的点餐（任务），如果
      
    
    </summary>
    
    
      <category term="JUC" scheme="http://www.yppcat.top/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>CAS与原子变量</title>
    <link href="http://www.yppcat.top/2022/11/27/CAS%E4%B8%8E%E5%8E%9F%E5%AD%90%E5%8F%98%E9%87%8F/"/>
    <id>http://www.yppcat.top/2022/11/27/CAS与原子变量/</id>
    <published>2022-11-27T13:08:34.000Z</published>
    <updated>2022-11-28T01:54:19.332Z</updated>
    
    <content type="html"><![CDATA[<p><strong>为什么无锁状态下的运行效率会高？</strong></p><p><strong>单纯的CAS理论：</strong></p><p>单纯的CAS理论只是为了完成一次比较确认值的同步<br>与代码块的同步并没有关系</p><p><strong>CAS理论应用下的锁实现原理：</strong><br>利用volatile变量与CAS理论保证在一定时间段内变量结果的一致性<br>同步对于线程进行阻塞</p><p><strong>CAS无锁状态下与synchronize有锁状态下的本质区别</strong><br>无锁情况下，即使重试失败，线程始终在高速运行，没有停歇，而synchronized会让线程在没有获得锁的时候，发生上下文切换，进入阻塞<br>比喻：高速上飙车，当前自己开200码，正常的高速运行，但是一旦发生上下文切换，需要减速停车，换路，在加速，代价相对高昂<br>无锁状态下，因为线程需要保持运行，则需要额外CPU的支持，CPU在这里就是高速公路，没路我们走不下去，一开始没有加锁，不会有阻塞，但是没有时间片，会导致上下文切换，所以CAS需要有多核CPU对于其进行支撑，单核体系下效率不一定</p><p><strong>CAS效率分析</strong></p><p>结合CAS与volatile实现无锁并发情况的适用场景：<br>    多核CPU场景下，且线程数少<br><strong>CAS基于乐观锁思想</strong>，最乐观结果，不怕别的线程来修改共享变量，改了也没事，我在重试<br><strong>synchronize基于悲观锁思想</strong>：最悲观结果，得放着其他线程来修改共享变量，我上锁，你们都别改，我改了解开你们才有机会</p><p>CAS体现的是无锁并发，无阻塞并发<br>    因为没有synchronized，线程不会陷入阻塞，这是效率提升的因素之一<br>    如果竞争几率，重试必然发生频繁，效率会下降</p><p>最好结果为线程数不超过CPU核心数</p><p><strong>线程的上下文切换</strong></p><p>本质：CPU切换前把当前任务的状态保存下来，以便下次切换回这个任务时可以再次加载这个任务的状态，然后加载下一任务的状态并执行。任务的状态保存及再加载, 这段过程就叫做上下文切换。</p><p>每个线程都有一个程序计数器（记录要执行的下一条指令），一组寄存器（保存当前线程的工作变量），堆栈（记录执行历史，其中每一帧保存了一个已经调用但未返回的过程）。</p><p>寄存器 是 CPU 内部的数量较少但是速度很快的内存（与之对应的是 CPU 外部相对较慢的 RAM 主内存）。寄存器通过对常用值（通常是运算的中间值）的快速访问来提高计算机程序运行的速度。</p><p>程序计数器是一个专用的寄存器，用于表明指令序列中 CPU 正在执行的位置，存的值为正在执行的指令的位置或者下一个将要被执行的指令的位置。</p><p>上下文切换会导致额外的开销，常常表现为高并发执行时速度会慢串行，因此减少上下文切换次数便可以提高多线程程序的运行效率。</p><p>直接消耗：指的是CPU寄存器需要保存和加载, 系统调度器的代码需要执行, TLB实例需要重新加载, CPU 的pipeline需要刷掉<br>间接消耗：指的是多核的cache之间得共享数据, 间接消耗对于程序的影响要看线程工作区操作数据的大小</p><p><strong>Atomic Variables（原子变量）</strong></p><p>本质上是一组工具，位置在atomic包下</p><p>​    处理并发安全问题上：<br>​        1.单个原子处理<br>​        2.块处理</p><p>​    本质上分类两类，<br>​        1.保证基本数据类型的原子性（AtomicInteger…）<br>​        2.保证引用类型的原子性（AtomicReference）</p><p><strong>原子引用与ABA问题</strong></p><p><strong>ABA问题</strong>：<br>    在多线程对于原子变量操作时，会发生将数据变更回去的现象，CAS在判断时会造成概念上的认知错误，但是实际上对业务结果是不变的</p><p>但是实际业务运用过程中可能会需要知道整个运行过程值是否改变</p><p>通过AtomicStampedReference  追溯版本号<br>通过AtomicMarkableReference 得到是否更改结果</p><p><strong>不同场景下的原子变量操作方案</strong></p><p>AtomicReference本质上是对于引用类型的地址<br>但是我们常规使用中，更多的业务是要判定内部数据是否一致<br>原子数组：<br>    保证数组内元素的线程安全<br>字段：<br>    字段更新器   AtomicReferenceFieldUpdater<br>累加业务：<br>    原子累加器</p><p><strong>LongAdder与Atomic比较</strong></p><p>性能提升的原因很简单，就是有竞争时，设置多个累加单元，然后最后结果汇总，他这样的累加操作不同的cell变量，因此减少了Cas重试失败，从而提高性能</p><p><strong>LongAdder原理分析</strong></p><p>性能提升的原因很简单，就是有竞争时，设置多个累加单元，然后最后结果汇总，他这样的累加操作不同的cell变量，因此减少了Cas重试失败，从而提高性能</p><img src="/2022/11/27/CAS与原子变量/image-20221127211502227.png" title="[CAS与原子变量]"><p><strong>LongAdder伪共享原理与缓存行</strong></p><p>什么是伪共享？</p><p>​    CPU高度缓冲器的存储体系下，一个基本的缓存单位叫做缓存行，一个缓存行的大小为64byte,<br>​    数组是一块连续的空间，因为副本数据的原因，数组加载到缓存当中，数据超过64字节会占用多行,若小于64字节则占用一行</p><p><strong>总结</strong></p><p>对于并发处理，从业务角度我们看做为两块：</p><p>​    1.原子变量操作</p><p>​    2.业务代码块的并发</p><p>并发手段现在接触的是两种：</p><p>​    1.加锁并发：synchronize（悲观体现）</p><p>​    2.无锁并发：CAS应用实现（乐观体现）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;为什么无锁状态下的运行效率会高？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;单纯的CAS理论：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;单纯的CAS理论只是为了完成一次比较确认值的同步&lt;br&gt;与代码块的同步并没有关系&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CAS理论应
      
    
    </summary>
    
    
      <category term="JUC" scheme="http://www.yppcat.top/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>锁</title>
    <link href="http://www.yppcat.top/2022/11/24/%E9%94%81/"/>
    <id>http://www.yppcat.top/2022/11/24/锁/</id>
    <published>2022-11-24T00:33:55.000Z</published>
    <updated>2022-11-24T00:44:09.608Z</updated>
    
    <content type="html"><![CDATA[<p><strong>JAVA下的线程安全分析</strong></p><p>在系统处理过程中，最为常见的问题是同一线程对于相同资源进行访问所造成的数据处理异常问题</p><p>下面代码中可能出现的结果是多少？</p><img src="/2022/11/24/锁/image-20221124083439437.png" title="[锁]"><p>出现问题的过程指令分析-线程的上下文切换</p><img src="/2022/11/24/锁/image-20221124083501485.png" title="[锁]"><p><strong>临界区与竞态条件</strong></p><p><strong>临界区：</strong><br>一个程序运行多个线程本身没有问题<br>出现问题最大的地方在于多个线程访问共享资源<br>多个线程读共享资源其实也没有问题<br>在多个线程对共享资源读写操作时发生指令交错，就会出现问题<br>一段代码块内如果存在对共享资源的多线程读写操作，称这段代码为临界区</p><p><strong>竞态条件:</strong><br>多个线程在临界区内执行，由于代码执行序列不同而导致结果无法预测，称之为静态条件</p><img src="/2022/11/24/锁/image-20221124083546506.png" title="[锁]"><p><strong>应用之互斥</strong></p><p>为了避免临界区的竞态条件发生，JAVA提供多种手段进行规避<br>阻塞式的解决方案：synchronized,Lock<br>非阻塞式的解决方案：原子变量</p><p>synchronized对象锁：<br>采用互斥方式让统一时刻之多只有一个线程持有对象锁，其他线程在获取这个对象锁会被阻塞，不用担心线程上下文切换</p><p>synchronized—本质与等价方案</p><img src="/2022/11/24/锁/image-20221124083638396.png" title="[锁]"><p><strong>Mark中的数据对于并发的支持</strong></p><img src="/2022/11/24/锁/image-20221124083721097.png" title="[锁]"><img src="/2022/11/24/锁/image-20221124083734688.png" title="[锁]"><p><strong>Monitor对象与synchronized</strong></p><img src="/2022/11/24/锁/image-20221124083750276.png" title="[锁]"><p><strong>注意事项</strong></p><p>执行同步代码块内容，然后唤醒entryList中其他线程时，此处采取竞争策略，先到不一定先得，所以synchronize锁是非公平</p><p>非公平锁： 在锁可用的时候，一个新到来的线程要占有锁，可以不需要排队，直接获得。</p><p>公平锁： 在锁可用的时候，一个新到来的线程要占有锁，需要排队，等待执行</p><p><strong>有没有比synchronized速度更快的方案？</strong></p><p>利用CPU的CAS指令，同时借助JNI来完成Java的非阻塞算法。其它原子操作都是利用类似的特性完成的。而整个J.U.C都是建立在CAS之上的，因此对于synchronized阻塞算法，J.U.C在性能上有了很大的提升。</p><p><strong>什么是CAS？</strong></p><p>CAS是英文单词Compare And Swap的缩写，翻译过来就是比较并替换。</p><p>CAS机制当中使用了3个基本操作数：<br>内存地址V<br>旧的预期值A<br>要修改的新值B</p><p>更新一个变量的时候，只有当变量的预期值A和内存地址V当中的实际值相同时，才会将内存地址V对应的值修改为B。</p><p>CAS机制当中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B。</p><img src="/2022/11/24/锁/image-20221124084005051.png" title="[锁]"><img src="/2022/11/24/锁/image-20221124084041320.png" title="[锁]">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;JAVA下的线程安全分析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在系统处理过程中，最为常见的问题是同一线程对于相同资源进行访问所造成的数据处理异常问题&lt;/p&gt;
&lt;p&gt;下面代码中可能出现的结果是多少？&lt;/p&gt;
&lt;img src=&quot;/2022/11/24/锁/imag
      
    
    </summary>
    
    
      <category term="JUC" scheme="http://www.yppcat.top/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>JMM内存模型与线程并发</title>
    <link href="http://www.yppcat.top/2022/11/23/JMM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91/"/>
    <id>http://www.yppcat.top/2022/11/23/JMM内存模型与线程并发/</id>
    <published>2022-11-23T00:09:15.000Z</published>
    <updated>2022-11-23T00:27:46.051Z</updated>
    
    <content type="html"><![CDATA[<p><strong>多核并发缓存架构解析</strong></p><p><strong>CPU 核心数和线程数的关系</strong></p><p>多核心:也指单芯片多处理器( Chip Multiprocessors,简称 CMP),CMP 是由美国斯坦福大学提出的,其思想是将大规模并行处理器中的 SMP(对称多处理器)集成到同一芯片内,各个处理器并行执行不同的进程。这种依靠多个 CPU 同时并行地运行程序是实现超高速计算的一个重要方向,称为并行处理</p><p>多线程: Simultaneous Multithreading.简称 SMT.让同一个处理器上的多个线程同步执行并共享处理器的执行资源。<br>核心数、线程数:目前主流 CPU 都是多核的。增加核心数目就是为了增加线程数,因为操作系统是通过线程来执行任务的,一般情况下它们是 1:1 对应关系,也就是说四核 CPU 一般拥有四个线程。但 Intel 引入超线程技术后,使核心数与线程数形成 1:2 的关系</p><img src="/2022/11/23/JMM内存模型与线程并发/image-20221123081135874.png" title="[JMM内存模型与线程并发]"><p><strong>CPU 时间片轮转机制</strong></p><p>时间片轮转调度中唯一有趣的一点是时间片的长度。从一个进程切换到另一个进程是需要定时间的,包括保存和装入寄存器值及内存映像,更新各种表格和队列等。假如进程切( processwitch),有时称为上下文切换( context switch),需要 5ms, 再假设时间片设为 20ms,则在做完 20ms 有用的工作之后,CPU 将花费 5ms 来进行进程切换。CPU 时间的 20%被浪费在了管理开销上了。<br>为了提高 CPU 效率,我们可以将时间片设为 5000ms。这时浪费的时间只有0.1%。但考虑到在一个分时系统中,如果有 10 个交互用户几乎同时按下回车键, 将发生什么情况?假设所有其他进程都用足它们的时间片的话,最后一个不幸的进程不得不等待 5s 才获得运行机会。多数用户无法忍受一条简短命令要 5 才能做出响应。<br>结论可以归结如下:时间片设得太短会导致过多的进程切换,降低了CPU 效率: 而设得太长又可能引起对短的交互请求的响应变差。将时间片设为 100ms 通常是一个比较合理的折衷</p><img src="/2022/11/23/JMM内存模型与线程并发/image-20221123081047224.png" title="[JMM内存模型与线程并发]"><p><strong>并发与并行</strong></p><p>我们举个例子,如果有条高速公路 A 上面并排有 8 条车道,那么最大的并行车辆就是 8 辆此条高速公路 A 同时并排行走的车辆小于等于 8 辆的时候,车辆就可以并行运行。CPU 也是这个原理,一个 CPU 相当于一个高速公路 A,核心数或者线程数就相当于并排可以通行的车道;而多个CPU  就相当于并排有多条高速公路,而每个高速公路并排有多个车道。<br>当谈论并发的时候一定要加个单位时间,也就是说单位时间内并发量是多少?    离开了单位时间其实是没有意义的。<br>俗话说,一心不能二用,这对计算机也一样,原则上一个 CPU 只能分配给一个进程,以便运行这个进程。我们通常使用的计算机中只有一个 CPU,也就是说只有一颗心,要让它一心多用同时运行多个进程,就必须使用并发技术。实现并发技术相当复杂,最容易理解的是“时间片轮转进程调度算法”。</p><img src="/2022/11/23/JMM内存模型与线程并发/image-20221123081215966.png" title="[JMM内存模型与线程并发]"><p><strong>CPU物理内核架构</strong></p><img src="/2022/11/23/JMM内存模型与线程并发/image-20221123081303369.png" title="[JMM内存模型与线程并发]"><p><strong>多核CPU缓存架构</strong></p><img src="/2022/11/23/JMM内存模型与线程并发/image-20221123081334365.png" title="[JMM内存模型与线程并发]"><p><strong>JMM内存模型</strong></p><p>JAVA多线程内存模型跟CPU内存模型类似，是基于CPU缓存模型来建立的，java线程内存模型是标准化的，屏蔽了底层计算机的不同</p><img src="/2022/11/23/JMM内存模型与线程并发/image-20221123081409704.png" title="[JMM内存模型与线程并发]"><p><strong>JMM内存模型8大原子操作</strong></p><p><strong>read(读取)：从主内存中读取数据</strong><br><strong>load(载入)：将主内存读取到的数据写入工作内存</strong><br><strong>use(使用)：从工作内存读取数据来计算</strong><br><strong>assign(赋值)：将计算好的值重新赋值到工作内存当中</strong><br><strong>store(存储)：将工作内存数据写入主内存</strong><br><strong>write(写入)：将存入的数据变量值赋值给主内存中的共享变量</strong><br><strong>lock(锁定)：将主内存变量加锁</strong><br><strong>unlock(解锁)：将主内存变量解锁</strong></p><img src="/2022/11/23/JMM内存模型与线程并发/image-20221123081454988.png" title="[JMM内存模型与线程并发]"><p><strong>缓存一致协议（MESI）：</strong><br>多个CPU从主内存读取同一个数据到各自的高速缓存，当其中某个CPU修改了缓存里的数据，该数据马上同步会主内存，其他的CPU通过总线嗅探机制可以感知到数据的变化从而将自己缓存的数据失效</p><p><strong>缓存加锁：</strong><br>缓存锁的核心机制是遵循与缓存一致性协议，一个处理器的缓存回写到内存会导致其他处理器的缓存失效，IA-32和Inter 64处理器使用MESI实现缓存一致性协议，Arm架构下是AMBA协议</p><p><strong>Volatile可见性底层实现原理</strong></p><p>Volatile缓存可见性实现原理：<br>底层实现主要通过一条汇编指令lock前缀指令，他会锁定这块内存区域的缓存（缓存行锁定）并写回到主内存中<br>Inter架构软件开发者手册中对lock指令的解释：<br>会将当前处理器缓存行的数据立即写回到系统内存<br>这个写回内存操作会引起其他CPU缓存了该地址的数据无效(MESI)<br>提供内存屏障功能，是lock指令不会进行重排</p><img src="/2022/11/23/JMM内存模型与线程并发/image-20221123081614247.png" title="[JMM内存模型与线程并发]"><p><strong>JAVA底层对应转换汇编语言查看</strong></p><p>-server -Xcomp -XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly -XX:CompileCommand=compileonly,*JMMTest.prepare</p><img src="/2022/11/23/JMM内存模型与线程并发/image-20221123081642431.png" title="[JMM内存模型与线程并发]"><p><strong>dex工具使用</strong></p><p>工具位置：SDK目录下\build-tools\版本\dx.bat<br>使用方式：配置该路径为环境变量<br>作用：将.class编译为dex字节码<br>转换指令：<br>dx –dex –min-sdk-version=28 –verbose –dump-to=JmmTest.dex.txt –dump-method=JMMTest.prepare  –verbose-dump JMMTest.class</p><p>-server -Xcomp -XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly -XX:CompileCommand=compileonly,*VolatileVisibilltyTest.prepareData</p><p><strong>指令重排序</strong></p><p>在计算机执行指令的顺序在经过程序编译器编译之后形成的指令序列</p><p>一般而言，这个指令序列是会输出确定的结果；以确保每一次的执行都有确定的结果</p><p>但是，一般情况下，CPU和编译器为了提升程序执行的效率，会按照一定的规则允许进行指令优化</p><p>在某些情况下，这种优化会带来一些执行的逻辑问题，主要的原因是代码逻辑之间是存在一定的先后顺序</p><p>在并发执行情况下，会发生二义性，即按照不同的执行逻辑，会得到不同的结果信息。</p><p><strong>规则:  改变指令的先后顺序会导致最终的结果不一致，则不会发生指令重排,反之 如果不会发生结果不一致则会发生重排指令重排主要反映在读和写的过程中</strong></p><p><strong>不会发生重排</strong></p><p>名称        代码示例            说明</p><p>写后读     a = 1;b = a;     写一个变量之后，再读这个位置。</p><p>写后写     a = 1;a = 2;     写一个变量之后，再写这个变量。</p><p>读后写     a = b;b = 1;     读一个变量之后，再写这个变量</p><p><strong>指令重排序规则</strong></p><p>在计算机执行指令的顺序在经过程序编译器编译之后形成的指令序列</p><p>一般而言，这个指令序列是会输出确定的结果；以确保每一次的执行都有确定的结果</p><p>但是，一般情况下，CPU和编译器为了提升程序执行的效率，会按照一定的规则允许进行指令优化<br>在某些情况下，这种优化会带来一些执行的逻辑问题，主要的原因是代码逻辑之间是存在一定的先后顺序</p><p>在并发执行情况下，会发生二义性，即按照不同的执行逻辑，会得到不同的结果信息。</p><p><strong>Happens-Before</strong></p><p><strong>程序次序规则</strong>：在一个线程内一段代码的执行结果是有序的。就是还会指令重排，但是随便它怎么排，结果是按照我们代码的顺序生成的不会变。<br><strong>管程锁定规则</strong>：就是无论是在单线程环境还是多线程环境，对于同一个锁来说，一个线程对这个锁解锁之后，另一个线程获取了这个锁都能看到前一个线程的操作结果！(管程是一种通用的同步原语，synchronized就是管程的实现）<br><strong>volatile变量规则</strong>：就是如果一个线程先去写一个volatile变量，然后一个线程去读这个变量，那么这个写操作的结果一定对读的这个线程可见。<br><strong>线程启动规则</strong>：在主线程A执行过程中，启动子线程B，那么线程A在启动子线程B之前对共享变量的修改结果对线程B见。<br><strong>线程终止规则</strong>：在主线程A执行过程中，子线程B终止，那么线程B在终止之前对共享变量的修改结果在线程A中可见。也称线程join()规则。<br><strong>线程中断规则</strong>：对线程interrupt()方法的调用先行发生于被中断线程代码检测到中断事件的发生，可以通过Thread.interrupted()检测到是否发生中断。<br><strong>传递性规则</strong>：这个简单的，就是happens-before原则具有传递性，即hb(A, B) ， hb(B, C)，那么hb(A, C)。<br><strong>对象终结规则</strong>：这个也简单的，就是一个对象的初始化的完成，也就是构造函</p><p><strong>内存屏障</strong></p><p><strong>实际上就是如果CPU在指令优化时给与一个标记位置，碰到此位置不进行优化</strong></p><p>Store：将处理器缓存的数据刷新到内存中。<br>Load：将内存存储的数据拷贝到处理器的缓存中。</p><img src="/2022/11/23/JMM内存模型与线程并发/image-20221123082200922.png" title="[JMM内存模型与线程并发]">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;多核并发缓存架构解析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CPU 核心数和线程数的关系&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;多核心:也指单芯片多处理器( Chip Multiprocessors,简称 CMP),CMP 是由美国斯坦福大学提出的,其思
      
    
    </summary>
    
    
      <category term="JUC" scheme="http://www.yppcat.top/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>JVM指令手册</title>
    <link href="http://www.yppcat.top/2022/11/20/JVM%E6%8C%87%E4%BB%A4%E6%89%8B%E5%86%8C/"/>
    <id>http://www.yppcat.top/2022/11/20/JVM指令手册/</id>
    <published>2022-11-20T13:30:37.000Z</published>
    <updated>2022-11-20T13:32:44.679Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JVM指令手册"><a href="#JVM指令手册" class="headerlink" title="JVM指令手册"></a>JVM指令手册</h3><p>## 一、栈和局部变量操作</p><p>### 将常量压入栈的指令</p><p>aconst_null 将null对象引用压入栈</p><p>iconst_m1 将int类型常量-1压入栈</p><p>iconst_0 将int类型常量0压入栈</p><p>iconst_1 将int类型常量1压入栈</p><p>iconst_2 将int类型常量2压入栈</p><p>iconst_3 将int类型常量3压入栈</p><p>iconst_4 将int类型常量4压入栈</p><p>iconst_5 将int类型常量5压入栈</p><p>lconst_0 将long类型常量0压入栈</p><p>lconst_1 将long类型常量1压入栈</p><p>fconst_0 将float类型常量0压入栈</p><p>fconst_1 将float类型常量1压入栈</p><p>dconst_0 将double类型常量0压入栈</p><p>dconst_1 将double类型常量1压入栈</p><p>bipush 将一个8位带符号整数压入栈</p><p>sipush 将16位带符号整数压入栈</p><p>ldc 把常量池中的项压入栈</p><p>ldc_w 把常量池中的项压入栈（使用宽索引）</p><p>ldc2_w 把常量池中long类型或者double类型的项压入栈（使用宽索引）</p><p>### 从栈中的局部变量中装载值的指令</p><p>iload 从局部变量中装载int类型值</p><p>lload 从局部变量中装载long类型值</p><p>fload 从局部变量中装载float类型值</p><p>dload 从局部变量中装载double类型值</p><p>aload 从局部变量中装载引用类型值（refernce）</p><p>iload_0 从局部变量0中装载int类型值</p><p>iload_1 从局部变量1中装载int类型值</p><p>iload_2 从局部变量2中装载int类型值</p><p>iload_3 从局部变量3中装载int类型值</p><p>lload_0 从局部变量0中装载long类型值</p><p>lload_1 从局部变量1中装载long类型值</p><p>lload_2 从局部变量2中装载long类型值</p><p>lload_3 从局部变量3中装载long类型值</p><p>fload_0 从局部变量0中装载float类型值</p><p>fload_1 从局部变量1中装载float类型值</p><p>fload_2 从局部变量2中装载float类型值</p><p>fload_3 从局部变量3中装载float类型值</p><p>dload_0 从局部变量0中装载double类型值</p><p>dload_1 从局部变量1中装载double类型值</p><p>dload_2 从局部变量2中装载double类型值</p><p>dload_3 从局部变量3中装载double类型值</p><p>aload_0 从局部变量0中装载引用类型值</p><p>aload_1 从局部变量1中装载引用类型值</p><p>aload_2 从局部变量2中装载引用类型值</p><p>aload_3 从局部变量3中装载引用类型值</p><p>iaload 从数组中装载int类型值</p><p>laload 从数组中装载long类型值</p><p>faload 从数组中装载float类型值</p><p>daload 从数组中装载double类型值</p><p>aaload 从数组中装载引用类型值</p><p>baload 从数组中装载byte类型或boolean类型值</p><p>caload 从数组中装载char类型值</p><p>saload 从数组中装载short类型值</p><p>### 将栈中的值存入局部变量的指令</p><p>istore 将int类型值存入局部变量</p><p>lstore 将long类型值存入局部变量</p><p>fstore 将float类型值存入局部变量</p><p>dstore 将double类型值存入局部变量</p><p>astore 将将引用类型或returnAddress类型值存入局部变量</p><p>istore_0 将int类型值存入局部变量0</p><p>istore_1 将int类型值存入局部变量1</p><p>istore_2 将int类型值存入局部变量2</p><p>istore_3 将int类型值存入局部变量3</p><p>lstore_0 将long类型值存入局部变量0</p><p>lstore_1 将long类型值存入局部变量1</p><p>lstore_2 将long类型值存入局部变量2</p><p>lstore_3 将long类型值存入局部变量3</p><p>fstore_0 将float类型值存入局部变量0</p><p>fstore_1 将float类型值存入局部变量1</p><p>fstore_2 将float类型值存入局部变量2</p><p>fstore_3 将float类型值存入局部变量3</p><p>dstore_0 将double类型值存入局部变量0</p><p>dstore_1 将double类型值存入局部变量1</p><p>dstore_2 将double类型值存入局部变量2</p><p>dstore_3 将double类型值存入局部变量3</p><p>astore_0 将引用类型或returnAddress类型值存入局部变量0</p><p>astore_1 将引用类型或returnAddress类型值存入局部变量1</p><p>astore_2 将引用类型或returnAddress类型值存入局部变量2</p><p>astore_3 将引用类型或returnAddress类型值存入局部变量3</p><p>iastore 将int类型值存入数组中</p><p>lastore 将long类型值存入数组中</p><p>fastore 将float类型值存入数组中</p><p>dastore 将double类型值存入数组中</p><p>aastore 将引用类型值存入数组中</p><p>bastore 将byte类型或者boolean类型值存入数组中</p><p>castore 将char类型值存入数组中</p><p>sastore 将short类型值存入数组中</p><p>wide指令</p><p>wide 使用附加字节扩展局部变量索引</p><p>### 通用(无类型）栈操作</p><p>nop 不做任何操作</p><p>pop 弹出栈顶端一个字长的内容</p><p>pop2 弹出栈顶端两个字长的内容</p><p>dup 复制栈顶部一个字长内容</p><p>dup_x1 复制栈顶部一个字长的内容，然后将复制内容及原来弹出的两个字长的内容压入栈</p><p>dup_x2 复制栈顶部一个字长的内容，然后将复制内容及原来弹出的三个字长的内容压入栈</p><p>dup2 复制栈顶部两个字长内容</p><p>dup2_x1 复制栈顶部两个字长的内容，然后将复制内容及原来弹出的三个字长的内容压入栈</p><p>dup2_x2 复制栈顶部两个字长的内容，然后将复制内容及原来弹出的四个字长的内容压入栈</p><p>swap 交换栈顶部两个字长内容</p><p>## 二、类型转换</p><p>i2l 把int类型的数据转化为long类型</p><p>i2f 把int类型的数据转化为float类型</p><p>i2d 把int类型的数据转化为double类型</p><p>l2i 把long类型的数据转化为int类型</p><p>l2f 把long类型的数据转化为float类型</p><p>l2d 把long类型的数据转化为double类型</p><p>f2i 把float类型的数据转化为int类型</p><p>f2l 把float类型的数据转化为long类型</p><p>f2d 把float类型的数据转化为double类型</p><p>d2i 把double类型的数据转化为int类型</p><p>d2l 把double类型的数据转化为long类型</p><p>d2f 把double类型的数据转化为float类型</p><p>i2b 把int类型的数据转化为byte类型</p><p>i2c 把int类型的数据转化为char类型</p><p>i2s 把int类型的数据转化为short类型</p><p>## 三、整数运算</p><p>iadd 执行int类型的加法</p><p>ladd 执行long类型的加法</p><p>isub 执行int类型的减法</p><p>lsub 执行long类型的减法</p><p>imul 执行int类型的乘法</p><p>lmul 执行long类型的乘法</p><p>idiv 执行int类型的除法</p><p>ldiv 执行long类型的除法</p><p>irem 计算int类型除法的余数</p><p>lrem 计算long类型除法的余数</p><p>ineg 对一个int类型值进行取反操作</p><p>lneg 对一个long类型值进行取反操作</p><p>iinc 把一个常量值加到一个int类型的局部变量上</p><p>## 四、逻辑运算</p><p>### 移位操作</p><p>ishl 执行int类型的向左移位操作</p><p>lshl 执行long类型的向左移位操作</p><p>ishr 执行int类型的向右移位操作</p><p>lshr 执行long类型的向右移位操作</p><p>iushr 执行int类型的向右逻辑移位操作</p><p>lushr 执行long类型的向右逻辑移位操作</p><p>### 按位布尔运算</p><p>iand 对int类型值进行“逻辑与”操作</p><p>land 对long类型值进行“逻辑与”操作</p><p>ior 对int类型值进行“逻辑或”操作</p><p>lor 对long类型值进行“逻辑或”操作</p><p>ixor 对int类型值进行“逻辑异或”操作</p><p>lxor 对long类型值进行“逻辑异或”操作</p><p>### 浮点运算</p><p>fadd 执行float类型的加法</p><p>dadd 执行double类型的加法</p><p>fsub 执行float类型的减法</p><p>dsub 执行double类型的减法</p><p>fmul 执行float类型的乘法</p><p>dmul 执行double类型的乘法</p><p>fdiv 执行float类型的除法</p><p>ddiv 执行double类型的除法</p><p>frem 计算float类型除法的余数</p><p>drem 计算double类型除法的余数</p><p>fneg 将一个float类型的数值取反</p><p>dneg 将一个double类型的数值取反</p><p>## 五、对象和数组</p><p>### 对象操作指令</p><p>new 创建一个新对象</p><p>checkcast 确定对象为所给定的类型。后跟目标类，判断栈顶元素是否为目标类 / 接口的实例。如果不是便抛出异常</p><p>getfield 从对象中获取字段</p><p>putfield 设置对象中字段的值</p><p>getstatic 从类中获取静态字段</p><p>putstatic 设置类中静态字段的值</p><p>instanceof 判断对象是否为给定的类型。后跟目标类，判断栈顶元素是否为目标类 / 接口的实例。是则压入 1，否则压入 0</p><p>### 数组操作指令</p><p>newarray 分配数据成员类型为基本上数据类型的新数组</p><p>anewarray 分配数据成员类型为引用类型的新数组</p><p>arraylength 获取数组长度</p><p>multianewarray 分配新的多维数组</p><p>## 六、控制流</p><p>### 条件分支指令</p><p>ifeq 如果等于0，则跳转</p><p>ifne 如果不等于0，则跳转</p><p>iflt 如果小于0，则跳转</p><p>ifge 如果大于等于0，则跳转</p><p>ifgt 如果大于0，则跳转</p><p>ifle 如果小于等于0，则跳转</p><p>if_icmpcq 如果两个int值相等，则跳转</p><p>if_icmpne 如果两个int类型值不相等，则跳转</p><p>if_icmplt 如果一个int类型值小于另外一个int类型值，则跳转</p><p>if_icmpge 如果一个int类型值大于或者等于另外一个int类型值，则跳转</p><p>if_icmpgt 如果一个int类型值大于另外一个int类型值，则跳转</p><p>if_icmple 如果一个int类型值小于或者等于另外一个int类型值，则跳转</p><p>ifnull 如果等于null，则跳转</p><p>ifnonnull 如果不等于null，则跳转</p><p>if_acmpeq 如果两个对象引用相等，则跳转</p><p>if_acmpnc 如果两个对象引用不相等，则跳转</p><p>### 比较指令</p><p>lcmp 比较long类型值</p><p>fcmpl 比较float类型值（当遇到NaN时，返回-1）</p><p>fcmpg 比较float类型值（当遇到NaN时，返回1）</p><p>dcmpl 比较double类型值（当遇到NaN时，返回-1）</p><p>dcmpg 比较double类型值（当遇到NaN时，返回1）</p><p>### 无条件转移指令</p><p>goto 无条件跳转</p><p>goto_w 无条件跳转（宽索引）</p><p>### 表跳转指令</p><p>tableswitch 通过索引访问跳转表，并跳转</p><p>lookupswitch 通过键值匹配访问跳转表，并执行跳转操作</p><p>### 异常</p><p>athrow 抛出异常或错误。将栈顶异常抛出</p><p>finally子句</p><p>jsr 跳转到子例程</p><p>jsr_w 跳转到子例程（宽索引）</p><p>rct 从子例程返回</p><p>## 七、方法调用与返回</p><p>### 方法调用指令</p><p>invokcvirtual 运行时按照对象的类来调用实例方法</p><p>invokespecial 根据编译时类型来调用实例方法</p><p>invokestatic 调用类（静态）方法</p><p>invokcinterface 调用接口方法</p><p>### 方法返回指令</p><p>ireturn 从方法中返回int类型的数据</p><p>lreturn 从方法中返回long类型的数据</p><p>freturn 从方法中返回float类型的数据</p><p>dreturn 从方法中返回double类型的数据</p><p>areturn 从方法中返回引用类型的数据</p><p>return 从方法中返回，返回值为void</p><p>### 线程同步</p><p>montiorenter 进入并获取对象监视器。即：为栈顶对象加锁</p><p>monitorexit 释放并退出对象监视器。即：为栈顶对象解锁</p><p>## 八、JVM指令助记符</p><p>变量到操作数栈：iload,iload_,lload,lload_,fload,fload_,dload,dload_,aload,aload_</p><p>操作数栈到变量：istore,istore_,lstore,lstore_,fstore,fstore_,dstore,dstor_,astore,astore_</p><p>常数到操作数栈：bipush,sipush,ldc,ldc_w,ldc2_w,aconst_null,iconst_ml,iconst_,lconst_,fconst_,dconst_</p><p>加：iadd,ladd,fadd,dadd</p><p>减：isub,lsub,fsub,dsub</p><p>乘：imul,lmul,fmul,dmul</p><p>除：idiv,ldiv,fdiv,ddiv</p><p>余数：irem,lrem,frem,drem</p><p>取负：ineg,lneg,fneg,dneg</p><p>移位：ishl,lshr,iushr,lshl,lshr,lushr</p><p>按位或：ior,lor</p><p>按位与：iand,land</p><p>按位异或：ixor,lxor</p><p>类型转换：i2l,i2f,i2d,l2f,l2d,f2d(放宽数值转换)</p><p>i2b,i2c,i2s,l2i,f2i,f2l,d2i,d2l,d2f(缩窄数值转换)</p><p>创建类实便：new</p><p>创建新数组：newarray,anewarray,multianwarray</p><p>访问类的域和类实例域：getfield,putfield,getstatic,putstatic</p><p>把数据装载到操作数栈：baload,caload,saload,iaload,laload,faload,daload,aaload</p><p>从操作数栈存存储到数组：bastore,castore,sastore,iastore,lastore,fastore,dastore,aastore</p><p>获取数组长度：arraylength</p><p>检相类实例或数组属性：instanceof,checkcast</p><p>操作数栈管理：pop,pop2,dup,dup2,dup_xl,dup2_xl,dup_x2,dup2_x2,swap</p><p>有条件转移：ifeq,iflt,ifle,ifne,ifgt,ifge,ifnull,ifnonnull,if_icmpeq,if_icmpene,</p><p>if_icmplt,if_icmpgt,if_icmple,if_icmpge,if_acmpeq,if_acmpne,lcmp,fcmpl</p><p>fcmpg,dcmpl,dcmpg</p><p>复合条件转移：tableswitch,lookupswitch</p><p>无条件转移：goto,goto_w,jsr,jsr_w,ret</p><p>调度对象的实便方法：invokevirtual</p><p>调用由接口实现的方法：invokeinterface</p><p>调用需要特殊处理的实例方法：invokespecial</p><p>调用命名类中的静态方法：invokestatic</p><p>方法返回：ireturn,lreturn,freturn,dreturn,areturn,return</p><p>异常：athrow</p><p>finally关键字的实现使用：jsr,jsr_w,ret</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;JVM指令手册&quot;&gt;&lt;a href=&quot;#JVM指令手册&quot; class=&quot;headerlink&quot; title=&quot;JVM指令手册&quot;&gt;&lt;/a&gt;JVM指令手册&lt;/h3&gt;&lt;p&gt;## 一、栈和局部变量操作&lt;/p&gt;
&lt;p&gt;### 将常量压入栈的指令&lt;/p&gt;
&lt;p&gt;aconst_n
      
    
    </summary>
    
    
      <category term="JVM" scheme="http://www.yppcat.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>class字节码文件结构</title>
    <link href="http://www.yppcat.top/2022/11/20/class%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/"/>
    <id>http://www.yppcat.top/2022/11/20/class字节码文件结构/</id>
    <published>2022-11-20T13:30:19.000Z</published>
    <updated>2022-11-20T13:32:28.054Z</updated>
    
    <content type="html"><![CDATA[<h3 id="class字节码文件结构"><a href="#class字节码文件结构" class="headerlink" title="class字节码文件结构"></a>class字节码文件结构</h3><p>## class字节码文件结构</p><p>| 类型      | 名称        | 说明          | 长度  | 数量         |</p><p>| ————– | ——————- | ———————- | ——- | ——————— |</p><p>| u4       | magic        | 魔数,识别Class文件格式 | 4个字节 | 1           |</p><p>| u2       | minor_version    | 副版本号(小版本)    | 2个字节 | 1           |</p><p>| u2       | major_version    | 主版本号(大版本)    | 2个字节 | 1           |</p><p>| u2       | constant_pool_count | 常量池计数器      | 2个字节 | 1           |</p><p>| cp_info    | constant_pool    | 常量池表        | n个字节 | constant_pool_count-1 |</p><p>| u2       | access_flags    | 访问标识        | 2个字节 | 1           |</p><p>| u2       | this_class     | 类索引         | 2个字节 | 1           |</p><p>| u2       | super_class     | 父类索引        | 2个字节 | 1           |</p><p>| u2       | interfaces_count  | 接口计数器       | 2个字节 | 1           |</p><p>| u2       | interfaces     | 接口索引集合      | 2个字节 | interfaces_count   |</p><p>| u2       | fields_count    | 字段计数器       | 2个字节 | 1           |</p><p>| field_info   | fields       | 字段表         | n个字节 | fields_count     |</p><p>| u2       | methods_count    | 方法计数器       | 2个字节 | 1           |</p><p>| method_info  | methods       | 方法表         | n个字节 | methods_count     |</p><p>| u2       | attributes_count  | 属性计数器       | 2个字节 | 1           |</p><p>| attribute_info | attributes     | 属性表         | n个字节 | attributes_count   |</p><p>## Class文件版本号和平台的对应</p><p>| 主版本（十进制） | 副版本（十进制） | 编译器版本 |</p><p>| —————- | —————- | ———- |</p><p>| 45        | 3        | 1.1    |</p><p>| 46        | 0        | 1.2    |</p><p>| 47        | 0        | 1.3    |</p><p>| 48        | 0        | 1.4    |</p><p>| 49        | 0        | 1.5    |</p><p>| 50        | 0        | 1.6    |</p><p>| 51        | 0        | 1.7    |</p><p>| 52        | 0        | 1.8    |</p><p>| 53        | 0        | 1.9    |</p><p>| 54        | 0        | 1.10    |</p><p>| 55        | 0        | 1.11    |</p><p>## class文件数据类型</p><p>| 数据类型 | 定义                             | 说明                             |</p><p>| ——– | ———————————————————— | ———————————————————— |</p><p>| 无符号数 | 无符号数可以用来描述数字、索引引用、数量值或按照utf-8编码构成的字符串值。 | 其中无符号数属于基本的数据类型。 以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节 |</p><p>| 表    | 表是由多个无符号数或其他表构成的复合数据结构。        | 所有的表都以“_info”结尾。 由于表没有固定长度，所以通常会在其前面加上个数说明。 |</p><p>## 类型描述符</p><p>| 标志符 | 含义                         |</p><p>| —— | —————————————————- |</p><p>| B   | 基本数据类型byte                   |</p><p>| C   | 基本数据类型char                   |</p><p>| D   | 基本数据类型double                  |</p><p>| F   | 基本数据类型float                  |</p><p>| I   | 基本数据类型int                   |</p><p>| J   | 基本数据类型long                   |</p><p>| S   | 基本数据类型short                  |</p><p>| Z   | 基本数据类型boolean                 |</p><p>| V   | 代表void类型                     |</p><p>| L   | 对象类型，比如：<code>Ljava/lang/Object;</code>         |</p><p>| [   | 数组类型，代表一维数组。比如：<code>double[][][] is [[[D</code> |</p><p>## 常量类型和结构</p><p>| 类型               | 标志(或标识) | 描述          |</p><p>| ——————————– | ———— | ———————- |</p><p>| CONSTANT_utf8_info        | 1      | UTF-8编码的字符串   |</p><p>| CONSTANT_Integer_info      | 3      | 整型字面量       |</p><p>| CONSTANT_Float_info       | 4      | 浮点型字面量      |</p><p>| CONSTANT_Long_info        | 5      | 长整型字面量      |</p><p>| CONSTANT_Double_info       | 6      | 双精度浮点型字面量   |</p><p>| CONSTANT_Class_info       | 7      | 类或接口的符号引用   |</p><p>| CONSTANT_String_info       | 8      | 字符串类型字面量    |</p><p>| CONSTANT_Fieldref_info      | 9      | 字段的符号引用     |</p><p>| CONSTANT_Methodref_info     | 10      | 类中方法的符号引用   |</p><p>| CONSTANT_InterfaceMethodref_info | 11      | 接口中方法的符号引用  |</p><p>| CONSTANT_NameAndType_info    | 12      | 字段或方法的符号引用  |</p><p>| CONSTANT_MethodHandle_info    | 15      | 表示方法句柄      |</p><p>| CONSTANT_MethodType_info     | 16      | 标志方法类型      |</p><p>| CONSTANT_InvokeDynamic_info   | 18      | 表示一个动态方法调用点 |</p><p>## 常量类型和结构细节</p><table><thead><tr><th>常量类型和结构</th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>标志</td><td>常量</td><td>描述</td><td>细节</td><td>长度</td><td>细节描述</td></tr><tr><td>1</td><td>CONSTANT_utf8_info</td><td>UTF-8编码的字符串</td><td>tag</td><td>u1</td><td>值为1</td></tr><tr><td>length</td><td>u2</td><td>UTF-8编码的字符串占用的字符数</td><td></td><td></td><td></td></tr><tr><td>bytes</td><td>u1</td><td>长度为length的UTF-8编码的字符串</td><td></td><td></td><td></td></tr><tr><td>3</td><td>CONSTANT_Integer_info</td><td>整型字面量</td><td>tag</td><td>u1</td><td>值为3</td></tr><tr><td>bytes</td><td>u4</td><td>按照高位在前存储的int值</td><td></td><td></td><td></td></tr><tr><td>4</td><td>CONSTANT_Float_info</td><td>浮点型字面量</td><td>tag</td><td>u1</td><td>值为4</td></tr><tr><td>bytes</td><td>u4</td><td>按照高位在前存储的float值</td><td></td><td></td><td></td></tr><tr><td>5</td><td>CONSTANT_Long_info</td><td>长整型字面量</td><td>tag</td><td>u1</td><td>值为5</td></tr><tr><td>bytes</td><td>u8</td><td>按照高位在前存储的long值</td><td></td><td></td><td></td></tr><tr><td>6</td><td>CONSTANT_Double_info</td><td>双精度浮点型字面量</td><td>tag</td><td>u1</td><td>值为6</td></tr><tr><td>bytes</td><td>u8</td><td>按照高位在前存储的double值</td><td></td><td></td><td></td></tr><tr><td>7</td><td>CONSTANT_Class_info</td><td>类或接口的符号引用</td><td>tag</td><td>u1</td><td>值为7</td></tr><tr><td>index</td><td>u2</td><td>指向全限定名常量项的索引</td><td></td><td></td><td></td></tr><tr><td>8</td><td>CONSTANT_String_info</td><td>字符串类型字面量</td><td>tag</td><td>u1</td><td>值为8</td></tr><tr><td>index</td><td>u2</td><td>指向字符串字面量的索引</td><td></td><td></td><td></td></tr><tr><td>9</td><td>CONSTANT_Fieldref_info</td><td>字段的符号引用</td><td>tag</td><td>u1</td><td>值为9</td></tr><tr><td>index</td><td>u2</td><td>指向声明字段的类或接口描述符CONSTANT_Class_info的索引项</td><td></td><td></td><td></td></tr><tr><td>index</td><td>u2</td><td>指向字段描述符CONSTANT_NameAndType的索引项</td><td></td><td></td><td></td></tr><tr><td>10</td><td>CONSTANT_Methodref_info</td><td>类中方法的符号引用</td><td>tag</td><td>u1</td><td>值为10</td></tr><tr><td>index</td><td>u2</td><td>指向声明方法的类描述符CONSTANT_Class_Info的索引项</td><td></td><td></td><td></td></tr><tr><td>index</td><td>u2</td><td>指向名称及类型描述符CONSTANT_NameAndType的索引项</td><td></td><td></td><td></td></tr><tr><td>11</td><td>CONSTANT_InterfaceMethodref_info</td><td>接口中方法的符号引用</td><td>tag</td><td>u1</td><td>值为11</td></tr><tr><td>index</td><td>u2</td><td>指向声明方法的接口描述符CONSTANT_Class_Info的索引项</td><td></td><td></td><td></td></tr><tr><td>index</td><td>u2</td><td>指向名称及类型描述符CONSTANT_NameAndType的索引项</td><td></td><td></td><td></td></tr><tr><td>12</td><td>CONSTANT_NameAndType_info</td><td>字段或方法的符号引用</td><td>tag</td><td>u1</td><td>值为12</td></tr><tr><td>index</td><td>u2</td><td>指向该字段或方法名称常量项的索引</td><td></td><td></td><td></td></tr><tr><td>index</td><td>u2</td><td>指向该字段或方法描述符常量项的索引</td><td></td><td></td><td></td></tr><tr><td>15</td><td>CONSTANT_MethodHandle_info</td><td>表示方法句柄</td><td>tag</td><td>u1</td><td>值为15</td></tr><tr><td>reference_kind</td><td>u1</td><td>值必须在1-9之间，它决定了方法句柄的类型方法句柄类型的值表示方法句柄的字节码行为</td><td></td><td></td><td></td></tr><tr><td>reference_index</td><td>u2</td><td>值必须是对常量池的有效索引</td><td></td><td></td><td></td></tr><tr><td>16</td><td>CONSTANT_MethodType_info</td><td>标志方法类型</td><td>tag</td><td>u1</td><td>值为16</td></tr><tr><td>descriptor_index</td><td>u2</td><td>值必须是对常量池的有效索引，常量池在该索引处的项必须是CONSTANT_Utf8_info结构，表示方法的描述符</td><td></td><td></td><td></td></tr><tr><td>18</td><td>CONSTANT_InvokeDynamic_info</td><td>表示一个动态方法调用点</td><td>tag</td><td>u1</td><td>值为18</td></tr><tr><td>bootstrap_method_attr</td><td>u2</td><td>值必须是对当前Class文件中引导方法表的bootstrap_methods[]数组的有效索引</td><td></td><td></td><td></td></tr><tr><td>name_and_type_index</td><td>u2</td><td>值必须是对当前常量池的有效索引，常量池在该索引处的项必须是CONSTANT_NameAndType_Info结构，表示方法名和方法描述符</td><td></td><td></td></tr></tbody></table><p>## 访问标志</p><p>| 标志名称    | 标志值 | 含义                             |</p><p>| ————– | —— | ———————————————————— |</p><p>| ACC_PUBLIC   | 0x0001 | 标志为public类型                       |</p><p>| ACC_FINAL   | 0x0010 | 标志被声明为final，只有类可以设置              |</p><p>| ACC_SUPER   | 0x0020 | 标志允许使用invokespecial字节码指令的新语义，JDK1.0.2之后编译出来的类的这个标志默认为真。（使用增强的方法调用父类方法） |</p><p>| ACC_INTERFACE | 0x0200 | 标志这是一个接口                       |</p><p>| ACC_ABSTRACT  | 0x0400 | 是否为abstract类型，对于接口或者抽象类来说，次标志值为真，其他类型为假 |</p><p>| ACC_SYNTHETIC | 0x1000 | 标志此类并非由用户代码产生（即：由编译器产生的类，没有源码对应） |</p><p>| ACC_ANNOTATION | 0x2000 | 标志这是一个注解                       |</p><p>| ACC_ENUM    | 0x4000 | 标志这是一个枚举                       |</p><p>## 字段表访问标志</p><p>| 标志名称   | 标志值 | 含义            |</p><p>| ————- | —— | ————————– |</p><p>| ACC_PUBLIC  | 0x0001 | 字段是否为public      |</p><p>| ACC_PRIVATE  | 0x0002 | 字段是否为private     |</p><p>| ACC_PROTECTED | 0x0004 | 字段是否为protected    |</p><p>| ACC_STATIC  | 0x0008 | 字段是否为static      |</p><p>| ACC_FINAL   | 0x0010 | 字段是否为final      |</p><p>| ACC_VOLATILE | 0x0040 | 字段是否为volatile     |</p><p>| ACC_TRANSTENT | 0x0080 | 字段是否为transient    |</p><p>| ACC_SYNCHETIC | 0x1000 | 字段是否为由编译器自动产生 |</p><p>| ACC_ENUM   | 0x4000 | 字段是否为enum       |</p><p>## 类索引、父类索引、接口索引</p><p>| 长度 | 含义             |</p><p>| —- | —————————- |</p><p>| u2  | this_class          |</p><p>| u2  | super_class         |</p><p>| u2  | interfaces_count       |</p><p>| u2  | interfaces[interfaces_count] |</p><p>## 属性的通用格式</p><p>| 类型 | 名称         | 数量       | 含义    |</p><p>| —- | ——————– | —————- | ———- |</p><p>| u2  | attribute_name_index | 1        | 属性名索引 |</p><p>| u4  | attribute_length   | 1        | 属性长度  |</p><p>| u1  | info         | attribute_length | 属性表   |</p><p>## 数据类型和默认初始值对应</p><p>| 类型   | 默认初始值 |</p><p>| ——— | ———- |</p><p>| byte   | (byte)0  |</p><p>| short   | (short)0  |</p><p>| int    | 0     |</p><p>| long   | 0L     |</p><p>| float   | 0.0f    |</p><p>| double  | 0.0    |</p><p>| char   | \u0000   |</p><p>| boolean  | false   |</p><p>| reference | null    |</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;class字节码文件结构&quot;&gt;&lt;a href=&quot;#class字节码文件结构&quot; class=&quot;headerlink&quot; title=&quot;class字节码文件结构&quot;&gt;&lt;/a&gt;class字节码文件结构&lt;/h3&gt;&lt;p&gt;## class字节码文件结构&lt;/p&gt;
&lt;p&gt;| 类型   
      
    
    </summary>
    
    
      <category term="JVM" scheme="http://www.yppcat.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>字节码文件与类加载</title>
    <link href="http://www.yppcat.top/2022/11/20/%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD/"/>
    <id>http://www.yppcat.top/2022/11/20/字节码文件与类加载/</id>
    <published>2022-11-20T13:11:06.000Z</published>
    <updated>2022-11-20T13:48:32.227Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Dalvik虚拟机</strong>执行的是dex字节码，解释执行。从Android 2.2版本开始，支持在程序运行的过程中进行选择热点代码（经常执行的代码）进行编译或者优化。</p><p>而<strong>ART（Android Runtime）</strong> 是在 Android 4.4 中引入的一个开发者选项，也是 Android 5.0 及更高版本的默认 Android 运行时。<strong>ART虚拟机执行的是本地机器码</strong>。Android的运行时从Dalvik虚拟机替换成ART虚拟机，并不要求开发者将自己的应用直接编译成目标机器码，APK仍然是一个包含dex字节码的文件。 </p><p><strong>那么，ART虚拟机执行的本地机器码是从哪里来？</strong></p><p><strong>前端编译器与后端编译器</strong></p><img src="/2022/11/20/字节码文件与类加载/image-20221120211238030.png" title="[字节码文件与类加载]"><p><strong>解释执行&amp;JIT&amp;AOT</strong></p><p>解释执行 ： 程序运行过程中，逐行进行代码编译</p><p>JIT ：程序运行过程中，将热点代码进行编译缓存执行</p><p>AOT：运行之前，将所有代码打包编译成机器码</p><p><strong>dex2aot</strong></p><p>Dalvik下应用在安装的过程，会执行一次优化，将dex字节码进行优化生成odex文件。</p><p>而Art下将应用的dex字节码翻译成本地机器码的最恰当AOT时机也就发生在应用安装的时候。ART 引入了预先编译机制（Ahead Of Time），在安装时，ART 使用设备自带的 dex2oat 工具来编译应用，dex中的字节码将被编译成本地机器码</p><img src="/2022/11/20/字节码文件与类加载/image-20221120211537989.png" title="[字节码文件与类加载]"><p><strong>Android N的运作方式</strong></p><p>ART 使用预先 (AOT) 编译，并且从 Android N混合使用AOT编译，解释和JIT。</p><p>1、最初安装应用时不进行任何 AOT 编译（安装又快了），运行过程中解释执行，对经常执行的方法进行JIT，经过 JIT 编译的方法将会记录到<strong>Profile</strong>配置文件中。</p><p>2、当设备闲置和充电时，编译守护进程会运行，根据<strong>Profile</strong>文件对常用代码进行 AOT 编译。待下次运行时直接使用。</p><p><strong>“类（文件）”的生命周期</strong></p><p><strong>类的生命周期概述</strong></p><p>在JAVA中数据类型分为引用数据类型与基本数据类型，基本数据类型由虚拟机预先定义，引用数据类型则需要进行类加载。</p><p>按照JAVA虚拟机规范，从class文件到加载到内存当中的类，到类写在出内存位置，他的整个生命周期包含下述七个阶段</p><img src="/2022/11/20/字节码文件与类加载/image-20221120211738049.png" title="[字节码文件与类加载]"><img src="/2022/11/20/字节码文件与类加载/“类”的生命周期.png" title="[字节码文件与类加载]"><p>类的卸载</p><img src="/2022/11/20/字节码文件与类加载/生命周期-类卸载.png" title="[字节码文件与类加载]"><p> 我们需要知道的是，一个我自己写的代码文件如何到内存当中被使用以及释放的过程</p><p>​       1.写代码—.java—&gt;前段编译器—&gt;.class—–&gt;通过IO读取进来—-&gt;解析文件结构，约定固定套路</p><p>​       —-&gt;将解出来的数据扔到方法区—-&gt;将当前这个类的信息提取出来—&gt;推到堆当中生成Class对象</p><p>​       —-&gt;具体使用—&gt;cinit—-&gt;卸载</p><p><strong>字节码解析</strong></p><img src="/2022/11/20/字节码文件与类加载/image-20221120213716176.png" title="[字节码文件与类加载]"><p><strong>类加载器</strong></p><img src="/2022/11/20/字节码文件与类加载/类加载器.png" title="[字节码文件与类加载]"><p>类加载：</p><p>​         读取指定目录下面的相关字节码文件，解析文</p><p>​           <strong>系统类加载器/启动类加载器/根类加载器</strong></p><p>​             加载jre下的内容</p><p>​            <strong>扩展类加载器</strong></p><p>​             加载ext文件夹下的内容</p><p>​           <strong>应用程序类加载器</strong></p><p>​             加载自己工程当中的内容</p><p>​           <strong>自定义类加载器（热修复）</strong></p><p>​             提供自己去写类加载器的方案，自己去指定某个路径或者某个文件，只要你是符合jvm字节码规范</p><p>​           Dex—&gt;N个Class文件—》应用程序类加载器–》不支持。自己写</p><p>​           </p><p>​           类加载器的分类=类加载器的种类</p><p>​             不是继承关系，每个人都是独立的，每个人干自己不同的活，加载代码的路径不一致   </p><p>​         ART ！= JVM</p><p>​         BootClassLoader—&gt;DexBaseClassloader</p><p>  <strong>Android的应用程序类加载器</strong></p><img src="/2022/11/20/字节码文件与类加载/image-20221120211910243.png" title="[字节码文件与类加载]"><p> 类加载–》物理读取字节码文件的动作</p><p>​           loadClass—》双亲委派–》为了保证我找不到，其他人能够去找</p><p>​           findClass—&gt;找一个路径，读取这个文件出来，形成一个字节码数组</p><p>​           defindClass—》将字节码文件读取完后进行校验，然后生成Class数据对象</p><p>​          </p><p>​           defindClass结束，类加载结束—-</p><p><strong>热修复原理</strong></p><p>热修复原理就是类加载器的核心</p><img src="/2022/11/20/字节码文件与类加载/image-20221120211930746.png" title="[字节码文件与类加载]"><p>热修复文章 ： <a href="https://blog.csdn.net/sahadev_/article/details/53318251" target="_blank" rel="noopener">https://blog.csdn.net/sahadev_/article/details/53318251</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Dalvik虚拟机&lt;/strong&gt;执行的是dex字节码，解释执行。从Android 2.2版本开始，支持在程序运行的过程中进行选择热点代码（经常执行的代码）进行编译或者优化。&lt;/p&gt;
&lt;p&gt;而&lt;strong&gt;ART（Android Runtime）&lt;/st
      
    
    </summary>
    
    
      <category term="JVM" scheme="http://www.yppcat.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>GC及调优</title>
    <link href="http://www.yppcat.top/2022/11/18/GC%E5%8F%8A%E8%B0%83%E4%BC%98/"/>
    <id>http://www.yppcat.top/2022/11/18/GC及调优/</id>
    <published>2022-11-18T11:25:19.000Z</published>
    <updated>2022-11-18T11:54:40.354Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GC核心概述"><a href="#GC核心概述" class="headerlink" title="GC核心概述"></a><strong>GC核心概述</strong></h2><p><strong>Java自动化内存管理</strong></p><p>好处：<br>   无需开发人员手动参与内存分配与回收，降低内存泄漏与溢出风险</p><p>缺点：<br>   弱化了开发人员在程序出现内存溢出时定位问题和解决问题的能</p><p>对于我们现在的意义：<br>我们必须堆这些自动化技术的原理进行了解，学会如何去监控和调节</p><p><strong>垃圾</strong>：指在程序中没有任何指针指向的对象，这个对象就是需要被回收的垃圾</p><p><strong>内存碎片概念</strong></p><img src="/2022/11/18/GC及调优/image-20221118192853538.png" title="[GC及调优]"><p>存储地址空间是指对存储器编码（编码地址）的范围。所谓编码就是对每一个物理存储单元（一个字节）分配一个号码，通常叫作“编址”。分配一个号码给一个存储单元的目的是为了便于找到它，完成数据的读写，这就是所谓的“寻址”（所以，有人也把地址空间称为寻址空间）。<br>地址空间的大小和物理存储器的大小并不一定相等。举个例子来说明这个问题：某层楼共有17个房间，其编号为801～817。这17个房间是物理的，而其地址空间采用了三位编码，其范围是800～899共100个地址，可见地址空间是大于实际房间数量的。</p><p><strong>为什么需要GC？</strong></p><p>对于系统而言，内存迟早都会被消耗完，因为不断的分配内存空间而不进行回溯，就好像不停的产生生活垃圾</p><p>但是除了释放垃圾对象，也需要对于内存空间进行碎片管理，没有GC就不能保证应用程序的正常化进行</p><h5 id="GC核心算法"><a href="#GC核心算法" class="headerlink" title="GC核心算法"></a><strong>GC核心算法</strong></h5><p>1.<strong>垃圾确认算法</strong>–标记阶段算法<br>    引用计数算法<br>    GCRoot可达性分析算法<br>2.<strong>清除垃圾算法</strong>–清除阶段算法<br>    标记-清除算法<br>    复制算法<br>    标记-压缩算法</p><p><strong>引用计数算法</strong></p><p>原理：对每一个对象保存一个整形的引用计数器属性，用于记录对象被引用的情况。</p><p>例：一个对象A只要有任何一个对象引用了A则A的引用计数器就+1，当引用失效时，引用计数器就-1.只要对象A的引用计数器的值为0，即标识对象A不可能再被使用，可进行回收</p><p>优点：实现简单，垃圾对象便于识别，判断效率高</p><p>缺点：<br>    他需要单独的字段存储计数器，这样的做法增加的存储空间的开销<br>    每次赋值需要额外的加减法计算，增加了时间开销<br>    引用计数算法最大的问题是无法处理循环引用的情况，这是一个比较致命的缺陷</p><p>引用计数算法循环引用问题</p><img src="/2022/11/18/GC及调优/image-20221118193123263.png" title="[GC及调优]"><p><strong>可达性分析算法</strong></p><p>相对于引用计数算法，他有效的解决了在引用计数算法中的循环引用问题，防止内存泄漏发生<br>这种类型的垃圾收集也叫作追踪性垃圾收集</p><p>概念：</p><p>可达性分析算法以跟对象集合为起点，按照从上至下的方式搜索被跟对象集合所链接的对象目标是否可达</p><p>使用可达性分析算法后，内存中的存货对象会被跟对象集合直接或者间接连接着，搜索所走过的路径称之为引用链</p><p>如果目标对象没有任何阴影链项链，则是不可达的，意味着该对象已经死亡，可以标记为垃圾对象。</p><p>在可达性分析算法中只有能够被根对象集合直接或间接连接的对象才是存活对象。</p><img src="/2022/11/18/GC及调优/image-20221118193236025.png" title="[GC及调优]"><p><strong>GCRoots</strong></p><p>虚拟机栈汇总的引用对象<br>例：各个线程被调用的方法中使用的参数、局部变量等<br>本地方法栈内JNI引用的对象</p><p>方法区中类静态属性引用对象<br>例：JAVA类的引用类型静态变量</p><p>方法区中常量引用的对象<br>例：字符串常量池里面的引用</p><p>所有被同步所synchronize持有的对象</p><p>java虚拟机内部引用的对象<br>例：基本数据类型对应的Class对象，一些常驻的异常对象（NullPointerException等）,系统类加载器</p><p>总结：一个指针，他保存了堆里面的对象，但自己又不在堆当中，那么他就是一个Root</p><p><strong>标记-清除（Mark-Sweep）算法</strong></p><img src="/2022/11/18/GC及调优/image-20221118193411647.png" title="[GC及调优]"><p>背景：<br>标记清除算法是一种非常基础和常见的垃圾收集算法，该算法被J.McCarthy等人在1960年提出并应用于Lisp语言</p><p>执行过程：<br>当堆空间中有效内存空间被耗尽时，就会停止这个程序（Stop the world），然后进行两项工作，标记，清除这两部分<br><strong>标记</strong>：从引用根节点上开始遍历（可达性分析算法）标记所有被引用的对象。一般是在对象Header中记录为可达对象。<br><strong>清除</strong>：对堆内存从头到尾进行线性遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收<br><strong>缺点</strong>：效率不高；在进行GC的时候需要停止整个应用程序，导致用户体验差；且会产生的大量的内存碎片</p><p>注意：<br>在这里的清除不是去干掉具体内存中的数据，而是本身分配的是一组连续的内存编码给我们使用，清除就是在回收这些空闲地址，将他们保存在空闲地址表当中，下次有新的对象需要空间时去判断是否够用</p><p><strong>复制（Copying）算法</strong></p><img src="/2022/11/18/GC及调优/image-20221118193546205.png" title="[GC及调优]"><p>背景：<br>为了解决标记-清除算法在垃圾收集效率方面的缺陷，M.LMinsky与1963年发表了著名论文，”使用双存储区的Lisp语言垃圾收集器“，该论文中被描述的算法被人们称之为复制算法。</p><p>执行过程：<br>将内存空间分为两块，每次只使用其中一块，在垃圾回收的时候，将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块，交换两个内存角色。<br>缺点：<br>1.需要两倍空间<br>2.GC需要维护对象的引用关系，时间开销加大<br>此种方案使用与垃圾对象较少，量级不大的情况</p><p>应用场景</p><p>在年青代中，对常规应用的垃圾回收，一次通常可以回收70%-99%的内存空间。回收性价比高。所以年青代一般采用这种</p><img src="/2022/11/18/GC及调优/image-20221118193633262.png" title="[GC及调优]"><p><strong>标记-压缩/整理（Mark-Compact）算法</strong></p><p>背景：<br>复制算法的高效是简历在存货对象少、垃圾对象多的前提下。这种情况在新生代中经常法神，但是在老年代，更常见的情况是大部分对象都是存货的。如果依然使用复制算法，由于存货对象多，复制成本也会非常高。因此基于老年代使用复制算法并不适用。</p><p>执行过程：<br>第一阶段与标记清除算法一致。<br>第二阶段将所有的存货对象压缩到内存的一段，按照顺讯排放，之后清理边界外所有空间</p><img src="/2022/11/18/GC及调优/image-20221118193809294.png" title="[GC及调优]"><p>优劣：<br>标记压缩算法的最终效果等同于标记-清除算法执行完成后在进行一次内存碎片的整理，因此，也可以把他称之为标记-清除-压缩（Mark-Sweep-Compact）算法。<br>二者本质差异在于标记清除算法是一直非移动式的回收算法，标记压缩是移动式的。是否移动回收后的存货对象是一项优缺点并存的风险决策<br>可以看到，标记的存货被整理后，按照内存地址一次排列，而未被标记的内存会被清理掉。如此一来，我们需要给新对象分配内存是，JVM只需要持有一个内存的起始地址即可，这个比维护一个空闲列表显然少了很多开销</p><p><strong>三种算法的性能指标对比</strong></p><table><thead><tr><th><strong>指标</strong></th><th><strong>Mark-Sweep</strong></th><th><strong>Mark-Compact</strong></th><th><strong>Copying</strong></th></tr></thead><tbody><tr><td>速度</td><td>中等</td><td>最慢</td><td>最快</td></tr><tr><td>空间</td><td>少（会堆积碎片）</td><td>少（不堆积碎片）</td><td>需要两倍大小（不堆积碎片）</td></tr><tr><td>移动对象</td><td>否</td><td>是</td><td>是</td></tr></tbody></table><p>效率上来说，复制算法最快，但是内存浪费最多<br>而为了尽量兼顾上面三个指标，标记整理算法相对平滑一些，但是效率上不仅如此任意，他比复制算法多了一个标记阶段，比清除多了一个整理内存阶段</p><p><strong>分代收集算法</strong></p><p>为了满足垃圾回收的效率最优性，所以分代手机算法应运而生。<br>分代手机算法基于一个事实：不同的对象生命周期是不一样的，因此，不同生命周期的对象可以采取不同的手机方式，以便于提高回收效率。一般是把JAVA堆分为<strong>新生代</strong>和<strong>老年代</strong>，这样就可以根据各个年代的特点使用不同回收算法，相对提高效率<br>在系统运行过程汇总，会产生大量对象，其中有些对象是业务信息相关，如HTTP请求的Session、线程、Socket连接等对象，这类对象跟业务挂钩，因此生命周期长，还有一部分是运行过程汇总生成的临时变量，这些对象生命周期短，比如：String,这些对象甚至<strong>只使用一次即可回收</strong></p><p>目前所有GC都采用分代收集算法进行执行<br>对象的状态经过大量的调研研究划分为年青代与老年代两个类别<br><strong>年青代</strong>：区域相对小，对象生命周期短、存活率低，且产生应用频繁<br>复制算法回收整理速度是最快的。复制算法效率只与当前存活对象大小有关，因此很实用与年青代的回收，而空间问题，因为存活率问题，所以单独开辟S0,S1两块空间处理清除后结果<br><strong>老年代</strong>：区域较大，生命周期长、存活率高，回收不及年青代频繁<br>这种情况存在大量存过对象下，复制不适用，所以一般是用清除与整理算法混合实现<br>Mark阶段的开销与存活对象的数量成正比<br>Sweep阶段的开销与所管理的大小成正比<br>Compact阶段的开销与存活对象的数据成正比</p><p><strong>增量收集算法</strong></p><p>上述所有算法，在垃圾回收过程中，软件都会处于一种Stop The World的状态。在STW状态下，应用程序所有线程都会挂起，暂停一切正常工作，等待垃圾回收完成，这种情况将严重影响用户体验或系统稳定。为了解决这个问题，催生出了一套增量手机算法。</p><p>基本概念：<br>如果一次性将所有垃圾进行处理，需要造成系统长时间停顿，那么久可以让垃圾收集线程和应用程序线程交替执行。每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。一次反复，直到垃圾收集完成。</p><p>总结：实际上就是通过对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理、复制等工作。</p><p>使用这种方式，由于在垃圾回收过程中，间断性的还执行了应用程序代码，所以能减少停顿时间。但是因为线程切换和上下文转换的消耗，会是的垃圾回收的总体成本上升，系统吞吐量下降。</p><p><strong>分区算法</strong></p><img src="/2022/11/18/GC及调优/image-20221118194234450.png" title="[GC及调优]"><p>相同条件下，堆空间越大，一次GC时间越长，停顿时间也越长，为了更好地控制GC产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干小区间，而不是整个堆空间，从而减少一次GC所产生的停顿。</p><p><strong>总结 :注意，实际上GC过程要复杂的多，需要考虑的不单单是这些，还有并行与并发的兼顾，而且通常都会应用复合算法去使用</strong></p><h4 id="垃圾回收器与内存管理"><a href="#垃圾回收器与内存管理" class="headerlink" title="垃圾回收器与内存管理"></a><strong>垃圾回收器与内存管理</strong></h4><p>常用7种垃圾回收器</p><img src="/2022/11/18/GC及调优/image-20221118194343343.png" title="[GC及调优]"><p><strong>垃圾回收的并行与串行</strong></p><p>并行&amp;串行：<br><strong>并行</strong>（Parallel）：只多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态。<br>ParNew、Parallel Scavenge、Parallel Old<br><strong>串行</strong>（Serial）：<br>单线程执行<br>如果内存不够则程序暂停，启动JVM垃圾回收器进行垃圾回收。回收万再启动城西县城</p><img src="/2022/11/18/GC及调优/image-20221118194424868.png" title="[GC及调优]"><img src="/2022/11/18/GC及调优/image-20221118194433609.png" title="[GC及调优]"><p>并行&amp;并发：<br><strong>并发</strong>：指的是多个事情在同一时间段内同时发生<br>并发的多个任务之间是相互抢占资源<br><strong>并行</strong>：指的是多个事情在同一时间点上同时发生了<br>并行的多个线程之间不相互抢占资源</p><p>只有在<strong>多个CPU</strong>或者<strong>一个CPU多核</strong>的情况中，才会发生并行。<br>否则，看似相同发生的事情，实际上都是并发执行</p><p>常用GC垃圾回收器对比</p><img src="/2022/11/18/GC及调优/image-20221118194745187.png" title="[GC及调优]"><p><strong>CMS回收器</strong></p><img src="/2022/11/18/GC及调优/image-20221118194800255.png" title="[GC及调优]"><p>初始标记：<br>这个阶段会出现STW现象，主要工作内容是标记处GCRoot能关联到的对象。（注意，这里只有GCROOT的对象，不会涉及引用链）<br>并发标记：<br>遍历GCROOT整个引用链，这个工作耗时非常长，采取了与垃圾收集器线程一起运行的方案<br>重新标记：<br>因为在上面步骤有用户线程行为，所以此处再次STW，进行重新标记，但是这部分只管重新运行后的那部分对象数据的变动。<br>并发清理：<br>清理所有标记的死亡对象，释放，这一步与用户线程同步进行<br>并发重置：</p><img src="/2022/11/18/GC及调优/image-20221118194826422.png" title="[GC及调优]"><p><strong>评估GC的性能指标</strong></p><p><strong>吞吐量</strong>：运行用户代码的时间占总运行时间的比例<br>                 总运行时间=程序运行时间+内存回收时间<br><strong>垃圾收集开销</strong>：吞吐量的补数，垃圾收集所用时间与总运行时间的比例<br><strong>暂停时间</strong>：执行垃圾收集时，程序的工作线程被暂停的时间<br><strong>收集频率</strong>：应用程序的执行，收集操作发生的次数<br><strong>内存占用</strong>：java堆区所占的内存大小</p><p><strong>不可达三角</strong>：<br>    性能调优的终极概念：空间换时间、时间换空间<br>不存在完美，一般情况下抓住吞吐量与暂停时间来设计</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;GC核心概述&quot;&gt;&lt;a href=&quot;#GC核心概述&quot; class=&quot;headerlink&quot; title=&quot;GC核心概述&quot;&gt;&lt;/a&gt;&lt;strong&gt;GC核心概述&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Java自动化内存管理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;好
      
    
    </summary>
    
    
      <category term="JVM" scheme="http://www.yppcat.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Dalvik虚拟机与ART虚拟机</title>
    <link href="http://www.yppcat.top/2022/11/18/Dalvik%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%8EART%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    <id>http://www.yppcat.top/2022/11/18/Dalvik虚拟机与ART虚拟机/</id>
    <published>2022-11-18T09:14:42.000Z</published>
    <updated>2022-11-18T09:52:06.255Z</updated>
    
    <content type="html"><![CDATA[<p>Dalvik<strong>虚拟机&amp;ART虚拟机与Hotspot区别</strong></p><p>Dalivk VM:</p><p>隶属：Google</p><p>发展历史：</p><p>应用于Android系统，并且在Android2.2中提供了JIT，发展迅猛</p><p>Dalvik是一款不是JVM的JVM虚拟机。本质上他没有遵循与JVM规范</p><p>不能直接运行java Class文件</p><p>他的结构基于寄存器结构，而不是JVM栈架构</p><p>执行的是编译后的Dex文件，执行效率较高</p><p>于Android5.0后被ART替换</p><p>Android应用程序运行在Dalvik/ART虚拟机，并且每一个应用程序对应有一个单独的Dalvik虚拟机实例。Dalvik虚拟机实则也算是一个Java虚拟机，只不过它执行的不是class文件，而是dex文件。</p><p>Dalvik虚拟机与Java虚拟机共享有差不多的特性，差别在于两者执行的指令集是不一样的，前者的指令集是基本寄存的，而后者的指令集是基于堆栈的。</p><img src="/2022/11/18/Dalvik虚拟机与ART虚拟机/image-20221118171713741.png" title="[Dalvik虚拟机与ART虚拟机]"><p><strong>栈区存储结构与运行原理</strong></p><img src="/2022/11/18/Dalvik虚拟机与ART虚拟机/image-20221118171801777.png" title="[Dalvik虚拟机与ART虚拟机]"><p><strong>寄存器存储与运行原理</strong></p><p>寄存器是CPU的组成部分。寄存器是有限存贮容量的高速存贮部件，它们可用来暂存指令、数据和位址。</p><img src="/2022/11/18/Dalvik虚拟机与ART虚拟机/image-20221118171917722.png" title="[Dalvik虚拟机与ART虚拟机]"><p><strong>基于寄存器的虚拟机</strong></p><p>基于寄存器的虚拟机中没有操作数栈，但是有很多虚拟寄存器。其实和操作数栈相同，这些寄存器也存放在运行时栈中，本质上就是一个数组。与JVM相似，在Dalvik VM中每个线程都有自己的PC和调用栈，方法调用的活动记录以帧为单位保存在调用栈上。</p><img src="/2022/11/18/Dalvik虚拟机与ART虚拟机/image-20221118172212396.png" title="[Dalvik虚拟机与ART虚拟机]"><p>与JVM版相比，可以发现Dalvik版程序的指令数明显减少了，数据移动次数也明显减少了。</p><p><strong>性能对比</strong></p><p>基于堆栈的Java指令(1个字节)和基于寄存器的Dalvik指令(2、4或者6个字节)各有优劣</p><p>一般而言，执行同样的功能，Java虚拟机需要更多的指令（主要是load和store指令），而Dalvik虚拟机需要更多的指令空间</p><p>需要更多指令意味着要多占用CPU时间，而需要更多指令空间意味着指令缓冲（i-cache）更易失效</p><p>Dalvik虚拟机使用dex（Dalvik Executable）格式的类文件，而Java虚拟机使用class格式的类文件</p><p>一个dex文件可以包含若干个类，而一个class文件只包括一个类</p><p>由于一个dex文件可以包含若干个类，因此它可以将各个类中重复的字符串只保存一次，从而节省了空间，</p><p>适合在内存有限的移动设备使用</p><p>一般来说，包含有相同类的未压缩dex文件稍小于一个已经压缩的jar文件</p><img src="/2022/11/18/Dalvik虚拟机与ART虚拟机/image-20221118172443050.png" title="[Dalvik虚拟机与ART虚拟机]"><p><strong>ART与Dalvik</strong></p><p>Dalvik虚拟机执行的是dex字节码，解释执行。从Android 2.2版本开始，支持JIT即时编译（Just In Time）在程序运行的过程中进行选择热点代码（经常执行的代码）进行编译或者优化。</p><p>而ART（Android Runtime） 是在 Android 4.4 中引入的一个开发者选项，也是 Android 5.0 及更高版本的默认 Android 运行时。ART虚拟机执行的是本地机器码。Android的运行时从Dalvik虚拟机替换成ART虚拟机，并不要求开发者将自己的应用直接编译成目标机器码，APK仍然是一个包含dex字节码的文件。</p><p><strong>那么，ART虚拟机执行的本地机器码是从哪里来？</strong></p><p>dex2aot</p><p>Dalvik下应用在安装的过程，会执行一次优化，将dex字节码进行优化生成odex文件。而Art下将应用的dex字节码翻译成本地机器码的最恰当AOT时机也就发生在应用安装的时候。ART 引入了预先编译机制（Ahead Of Time），在安装时，ART 使用设备自带的 dex2oat 工具来编译应用，dex中的字节码将被编译成本地机器码。</p><img src="/2022/11/18/Dalvik虚拟机与ART虚拟机/image-20221118172812081.png" title="[Dalvik虚拟机与ART虚拟机]"><p><strong>Android N的运作方式</strong></p><p>ART使用预先(AOT)编译，并且从AndroidN混合使用AOT编译，解释和JIT。</p><p>1、最初安装应用时不进行任何AOT编译（安装又快了），运行过程中解释执行，对经常执行的方法进行JIT，</p><p>经过JIT编译的方法将会记录到<strong>Profile</strong>配置文件中。</p><p>2、当设备闲置和充电时，编译守护进程会运行，根据<strong>Profile</strong>文件对常用代码进行AOT编译。待下次运行时直</p><p>接使用。</p><img src="/2022/11/18/Dalvik虚拟机与ART虚拟机/image-20221118172905300.png" title="[Dalvik虚拟机与ART虚拟机]"><h2 id="Android内存管理模型"><a href="#Android内存管理模型" class="headerlink" title="Android内存管理模型"></a><strong>Android内存管理模型</strong></h2><img src="/2022/11/18/Dalvik虚拟机与ART虚拟机/image-20221118173020016.png" title="[Dalvik虚拟机与ART虚拟机]"><p><strong>用户空间内存管理</strong></p><p>用户空间主要分两部分，一个是面向C++的native层，一个是基于虚拟机的java层。</p><p>native部分：</p><p>​             Data：用于保存全局变量</p><p>​             Bss：用于保存全局未初始化变量</p><p>​              Code：程序代码段</p><p>​              Stack：线程函数执行的内存</p><p>​               Heap：Malloc分配管理的内存</p><p>java基于虚拟机的内存划分:</p><p>​                ProgramCounterRegisterPC寄存器</p><p>​                VMStack基于方法中的局部变量，包括基本数据类型及对象引用等</p><p>​                NativeMethodStack针对native方法，与方法栈一致</p><p>​                MethodArea虚拟机加载的类信息、常量、静态变量等</p><p>​                Heap对象实体</p><p><strong>ART堆的详细划分</strong></p><img src="/2022/11/18/Dalvik虚拟机与ART虚拟机/image-20221118173405715.png" title="[Dalvik虚拟机与ART虚拟机]"><p>ImageSpace：连续地址空间，不进行垃圾回收，存放系统预加载类，而这些对象是存放system@<a href="mailto:framework@boot.art" target="_blank" rel="noopener">framework@boot.art</a>@classes.oat这个OAT文件中的该文件存于data/dalvikccache目录下，每次开机启动只需把系统类映射到ImageSpace。</p><p>ZygoteSpace：连续地址空间，匿名共享内存，进行垃圾回收，管理Zygote进程在启动过程中预加载和创建的各种对象、资源。</p><p>注：ImageSpace和ZygoteSpace在Zygote进程和应用程序进程之间进行共享，而AllocationSpace就每个进程都独立地拥有一份。虽然ImageSpace和ZygoteSpace都是在Zygote进程和应用程序进程之间进行共享，但是前者的对象只创建一次，而后者的对象需要在系统每次启动时根据运行情况都重新创建一遍。</p><p>AllocationSpace与ZygoteSpace性质一致，在Zygote进程fork第一个子进程之前，就会把ZygoteSpace一分为二，原来的已经被使用的那部分堆还叫ZygoteSpace，而未使用的那部分堆就叫AllocationSpace。以后的对象都在AllocationSpace上分配。</p><p>LargeObjectSpace离散地址空间，进行垃圾回收，用来分配一些大于12K的大对象。当满足以下三个条件时，在largeobject  heap上分配，否则在zygote或者allocationspace上分配： </p><p>​                        1.请求分配的内存大于等于Heap类的成员变量large_object_threshold_指定的值。</p><p>​                         2.这个值等于3*kPageSize，即3个页面的大小</p><p>​                         3.已经从ZygoteSpace划分出AllocationSpace，即Heap类的成员变量have_zygote_space_的值等于true。</p><p>​                         4.被分配的对象是一个原子类型数组，即byte数组、int数组和boolean数组等。</p><p><strong>ART的GC策略</strong></p><p>Art的三种GC策略：</p><p>StickyGC:只回收上一次GC到本次GC之间申请的内存。cms浮游垃圾</p><p>PartialGC:局部垃圾回收，除了ImageSpace和ZygoteSpace空间以外的其他内存垃圾。</p><p>FullGC:全局垃圾回收,除了ImageSpace之外的Space的内存垃圾。</p><p>策略的对比：(gcpause时间越长，对应用的影响越大)</p><p>GC暂停时间：StickyGC&lt;PartialGC&lt;FullGC</p><p>回收垃圾的效率：StickyGC&gt;PartialGC&gt;FullGC</p><p><strong>分配对象时执行GC的三个阶段</strong></p><p>执行GC的三个阶段：</p><p>阶段一：首先会进行一次轻量级的GC，GC完成后尝试分配。如果分配失败，则选取下一个GC策略，再进行一次轻量级GC。每次GC完成后都尝试分配，直到三种GC策略都被轮询了一遍还是不能完成分配，则进入下一阶段。</p><p>阶段二：允许堆进行增长的情况下进行对象的分配。</p><p>阶段三：进行一次允许回收软引用的GC的情况下进行对象的分配。</p><img src="/2022/11/18/Dalvik虚拟机与ART虚拟机/image-20221118173813194.png" title="[Dalvik虚拟机与ART虚拟机]"><p><strong>强、软、弱、虚引用</strong></p><p>强软弱虚（强引用、软引用、弱引用、虚引用）对应的是四种JVM回收堆内存的四种策略，不同的引用类型</p><p>有不同的回收策略。</p><p>1.强引用</p><p>普通new对象就是使用强引用，强引用必须是对象不可达情况下才会回收</p><p>2.软引用</p><p>当内存不足时，软引用会被回收，系统不足时，就算可达也会回收</p><p>3.弱引用</p><p>只要遇到垃圾回收，就会被回收掉，</p><p>4.虚引用</p><p>如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。</p><p><strong>GC打印log分析</strong></p><p>ART不会把所有的GC结果都输出到Logcat中。只有那些被认为执行缓慢的GC才会被输出到Logcat中。确切的说，只有GC停顿时间超过5ms或者整个GC耗时超过100ms才会被输出到Logcat中</p><p>I/art:ExplicitconcurrentmarksweepGCfreed104710(7MB)AllocSpaceobjects,21(416KB)LOSobjects,33%free,</p><p>25MB/38MB,paused1.230mstotal67.216ms</p><p>格式翻译：</p><p>I/art:&lt;GC_Reason&gt;&lt;GC_Name&gt;&lt;Objects_freed&gt;(&lt;Size_freed&gt;)AllocSpaceObjects,</p><p>GC_Reason&gt;触发垃圾回收的原因以及触发了何种类型的垃圾回收，它包含以下几类：</p><p>Concurrent特点是不需要挂起应用线程。它在后台线程中运行，不会影响到内存的分配。(前后台切换)</p><p>Alloc它在应用申请内存但是堆已满的情况下触发。在这种情况下，垃圾回收在分配内存的线程中进行。（它会导致应用停一段时间）</p><p>Explicit主动发起的垃圾回收，例如System.gc()。跟dalvik一样，建议不要主动发起垃圾回收。</p><p>NativeAlloc它会在native层内存吃紧的时候发起。比如说分配Bitmap或者RenderScript内存空间不够的时候。</p><p>CollectorTransition一般由堆转换引起，垃圾回收器会把free-listback空间的所有对象都复制到bumppointer空间中。目前转换过程只在一些低内存的设备上应用所在进程从对暂停敏感切换到对暂停不敏感状态的时候发生。</p><p>HomogeneousSpaceCompact它是在free-list空间到free-list空间的复制。当app所在进程对暂停不敏感的时候发生。它可以减少内存的使用，减少内存分配的碎片化。</p><p>DisableMovingGc它并不是引起内存回收的真正原因，它是垃圾回收被GetPrimitiveCritical中断时发生的。当concurrent堆压缩正在执行的时候，因为对垃圾回收器的限制，所以非常不建议使用它。</p><p>HeapTrim它不是触发垃圾回收的原因，但是在堆压缩的时候垃圾回收会被终止。</p><p>GCName垃圾回收的名称，一共有如下几类：</p><p>Concurrentmarksweep(CMS)对整个堆进行垃圾回收，除了image空间。</p><p>Concurrentpartialmarksweep对几乎整个堆进行回收，除了image空间和zynote空间。</p><p>Concurrentstickymarksweep一次普通的垃圾回收，它只负责回收上次垃圾回收之后的分配的对象。它要比Concurrentpartial marksweep执行的次数频繁的多，因为它的执行速度快，暂停时间少。</p><p>Marksweep+semispace一种非同时进行的，包含复制过程的GC。可以用来移动堆，也可以用来压缩堆（减少堆的碎片化）。</p><p>Objectsfreed释放了对象（非大对象）的数量</p><p>Sizefreed释放了空间（非大对象）的大小</p><p>Largeobjectsfreed释放了大对象的数量</p><p>Largeobjectsizefreed释放了大对象的空间的大小</p><p>Heapstats堆中空闲空间的百分比和（对象的个数）/（堆的总空间）</p><p>Pausetimes一般情况下，垃圾回收的暂停时间跟堆中引用的数量成正比。目前，ARTCMSGC只有一次在垃圾回收结束的时候。</p><p><strong>分析工具</strong></p><p>adb:对应用进程和系统整体内存状态做一个宏观把控</p><p>dumpsysmeminfo、MemoryProfiler:操作应用程序过程中，以实时图标反馈当前内存情况，对于明显的内存抖动、内存泄漏能做一个初步分析。</p><p>eakCanary:傻瓜式内存泄漏检测工具，对于Activity与Fragment检测非常好用</p><p>MAT:内存块分析，比较全面，使用复杂</p><p><strong>MemoryProfiler</strong></p><img src="/2022/11/18/Dalvik虚拟机与ART虚拟机/image-20221118174236862.png" title="[Dalvik虚拟机与ART虚拟机]"><p><strong>30分钟下代码整体运行情况</strong></p><img src="/2022/11/18/Dalvik虚拟机与ART虚拟机/image-20221118174253850.png" title="[Dalvik虚拟机与ART虚拟机]"><p><strong>MAT与性能调优（GCROOT溯源与问题分析）</strong></p><p>Mat工具的使用</p><p>转换profile文件格式 -&gt; sdk/platform-tools/hprof-conv.exe  -&gt; 转换命令hprof-conv-zsrcdst</p><p>下载：<a href="https://www.eclipse.org/mat/downloads.php" target="_blank" rel="noopener">https://www.eclipse.org/mat/downloads.php</a></p><p>打开软件File菜单下OpenHeapDump…打开转换好的文件 -&gt; 点击QQL按钮查找activity  (select*frominstanceofandroid.app.Activity)</p><p><strong>内存抖动与内存泄漏</strong></p><p><strong>内存抖动</strong></p><p>内存频繁的分配与回收，（分配速度大于回收速度时）最终会产生OOM</p><p><strong>内存泄露</strong></p><p>一个长生命周期的对象持有一个短生命周期对象的强引用,通俗讲就是该回收的对象因为引用问题没有被回收，最终会产生OOM</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Dalvik&lt;strong&gt;虚拟机&amp;amp;ART虚拟机与Hotspot区别&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Dalivk VM:&lt;/p&gt;
&lt;p&gt;隶属：Google&lt;/p&gt;
&lt;p&gt;发展历史：&lt;/p&gt;
&lt;p&gt;应用于Android系统，并且在Android2.2中提供了JIT，
      
    
    </summary>
    
    
      <category term="JVM" scheme="http://www.yppcat.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>堆内存解析</title>
    <link href="http://www.yppcat.top/2022/11/15/%E5%A0%86%E5%86%85%E5%AD%98%E8%A7%A3%E6%9E%90/"/>
    <id>http://www.yppcat.top/2022/11/15/堆内存解析/</id>
    <published>2022-11-15T13:39:21.000Z</published>
    <updated>2022-11-15T14:06:06.260Z</updated>
    
    <content type="html"><![CDATA[<p><strong>运行时数据区</strong></p><img src="/2022/11/15/堆内存解析/image-20221115214119142.png" title="[堆内存解析]"><p><strong>堆概述</strong></p><p>1.一个JVM进程存在一个堆内存，堆是JVM内存管理的核心区域</p><p>2.java 堆区在JVM启动是被创建，其空间大小也被确定，是JVM管理的最大一块内存（堆内存大小可以调整）</p><p>3.本质上堆是一组在物理上不连续的内存空间，但是逻辑上是连续的空间（参考HSDB分析的内存结构）</p><p>4.所有线程共享堆，但是堆内对于线程处理还是做了一个线程私有的部分（TLAB）</p><p><strong>堆的对象管理</strong></p><p>在《JAVA虚拟机规范》中对Java堆的描述是：所有的对象示例以及数组都应当在运行时分配在堆上</p><p>但是从实际使用角度来看，不是绝对，存在某些特殊情况下的对象产生是不在堆上分配</p><p>这里请注意，规范上是绝对、实际上是相对</p><p>方法结束后,堆中的对象不会马上移除，需要通过GC执行垃圾回收后才会回收</p><p><strong>堆的内存细分</strong></p><img src="/2022/11/15/堆内存解析/image-20221115214342705.png" title="[堆内存解析]"><p>Java7之前内存逻辑划分为：</p><p>新生区+养老区+永久区</p><p>Java8之后内存逻辑划分为：</p><p>新生去+养老区+元空间</p><p>实际上不管永久代与元空间其实都是只方法区中对于长期存在的常量对象的保存</p><p><strong>体会堆空间的分代思想</strong></p><p>为什么需要分代？有什么好处？</p><p>经研究表明，不同对象的生命周期不一致，但是在具体使用过程中70%-90的对象是临时对象</p><p>分代唯一的理由是优化GC性能。如果没有分代，那么所有对象在一块空间，GC想要回收扫描他就必须扫描所有的对象，分代之后，长期持有的对象可以挑出，短期持有的对象可以固定在一个位置进行回收，省掉很大一部分空间利用</p><p><strong>堆的默认大小</strong></p><p>默认空间大小：</p><p>初始大小：物理电脑内存大小 / 64</p><p>最大内存大小：物理电脑内存大小 / 4</p><p><strong>对象分配过程图示</strong></p><img src="/2022/11/15/堆内存解析/image-20221115214524136.png" title="[堆内存解析]"><p><strong>对象生产过程自述</strong></p><p>1.我是一个普通的java对象，我出生在Eden区，在Eden区我还看到和我长的很像的小兄弟，我们在Eden区中玩了挺长时间。</p><p>2.有一天Eden区中的人实在是太多了，我就被迫去了Survivor区的“From”区，自从去了Survivor区，我就开始了我漂泊的人生，有时候在Survivor的“From”区，有时候在Survivor的“To”区，居无定所。</p><p>3.直到我 岁的时候，爸爸说我成人了，该去社会上闯闯了。于是我就去了年老代那边，年老代里，人很多，并且年龄都挺大的，我在这里也认识了很多人。在年老代里，我生活了 年(每次GC加一岁)，然后被回收。</p><p><strong>MinorGc、MajorGC、FullGC的区别</strong></p><p>JVM在进行GC时，并非每次都对上面三个内存区域一起回收，大部分的只会针对于Eden区进行</p><p>在JVM标准中，他里面的GC按照回收区域划分为两种：</p><p> 一种是部分采集（Partial GC ）:</p><p>新生代采集（Minor GC / YongGC）：</p><p><strong>只采集新生代数据</strong></p><p>老年代采集（Major GC / Old GC）：</p><p><strong>只采集老年代数据，目前只有CMS会单独采集老年代</strong></p><p>混合采集（Mixed GC）：</p><p><strong>采集新生代与老年代部分数据，目前只有G1使用</strong></p><p>一种是整堆采集（Full GC）:</p><p><strong>收集整个堆与方法区的所有垃圾</strong></p><p><strong>GC触发策略</strong></p><p><strong>年轻代触发机制：</strong></p><p>当年青代空间不足时，就会触发MinorGc,这里年轻代满值得是Eden区中满了</p><p>因为Java大部分对象都是具备朝生熄灭的特性，所以MinorGC非常频繁，一般回收速度也快</p><p>MinorGc会出发STW行为，暂停其他用户的线程</p><p><strong>老年代GC触发机制：</strong></p><p>出现MajorGC经常会伴随至少一次MinorGC(非绝对，老年代空间不足时会尝试触发</p><p>MinorGC如果空间还是不足则会出发MajorGC)</p><p>MajorGC比MinorGC速度慢10倍，如果MajorGC后内存还是不足则会出现OOM</p><p><strong>FullGC触发</strong></p><p>调用System.gc()时</p><p>老年代空间不足时</p><p>方法区空间不足时</p><p>通过MinorGC进入老年代的平均大小大于老年代的可用内存</p><p>在Eden使用Survivor进行复制时，对象大小大于Survivor的可用内存，则该对象转入老年代，且</p><p>老年代的可用内存小于该对消</p><p>Full GC 是开发或者调优中尽量要避开的</p><p><strong>GC日志查看</strong></p><p>-Xms9m -Xmx9m -XX:+PrintGCDetails</p><img src="/2022/11/15/堆内存解析/image-20221115214857087.png" title="[堆内存解析]"><p><strong>TLAB（</strong>Thread Local Allocation Buffer）</p><p>什么是TLAB?</p><p>堆区是线程共享区，任何线程都可以访问堆中共享数据</p><p>由于对象示例的创建很频繁，在并发环境下对重划分内存空间是线程不安全的，如果需要避免多个线程对于同一地址操作，需要加锁，而加锁则会印象分配速度</p><p>所以JVM默认在堆区中开辟了一块空间，专门服务于每一个线程。他为每个线程分配了一个私有缓存区域，包含在Eden中，这就是TLAB</p><p>多线程同时分配内存是，使用TLAB可以避免一系列的非线程安全问题</p><p>TLAB会作为内存分配的首选，TLAB总空间只会占用EDEN空间的1% </p><p>一旦对象在TLAB空间分配失败，JVM会尝试使用加锁来保证数据操作的原子性，从而直接在Eden中分配</p><p><strong>对象逃逸与代码优化</strong></p><p><strong>堆是分配对象存储的唯一选择吗？</strong></p><p>在《深入理解JAVA虚拟机》一书中，有一段这样的描述：</p><p>随着JIT编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象分配到堆上也渐渐地变得不那么“绝对”了。</p><p>？？？？什么是栈上分配？？ 什么是标量替换？？ 什么叫逃逸分析技术？？？</p><p><strong>逃逸分析</strong></p><p>逃逸：</p><p>一个对象的作用域仅限于方法区域内部在使用的情况下，此种状况叫做非逃逸</p><p>一个对象如果被外部其他类调用，或者是作用于属性中，则此种现象被称之为对象逃逸</p><p>此种行为发生在字节码被编译后JIT对于代码的进一步优化</p><p><strong>逃逸分析案例</strong></p><p>一个对象的作用域仅限于方法区域内部在使用的情况下，此种状况加做非逃逸</p><img src="/2022/11/15/堆内存解析/image-20221115215131588.png" title="[堆内存解析]"><p>method2因为将当前sb返回出去进行使用，所以发生逃逸，</p><p>变更为methd3之后是构建一个新的String 对象，而StringBuffer对象未产生逃逸现象</p><img src="/2022/11/15/堆内存解析/image-20221115215235484.png" title="[堆内存解析]"><p><strong>逃逸分析：代码优化</strong></p><p>使用逃逸分析，编译器可以堆代码做如下优化：</p><p>1.栈上分配：JIT编译器在编译期间根据逃逸分析计算结果，如果发现当前对象没有发生逃逸现象，那么当前对象就可能被优化成栈上分配，会将对象直接分配在栈中</p><p>2.标量替换:有的对象可能不需要作为一个连续的内存结构存在也能被访问到，那么对象部分可以不存储在内存，而是存储在CPU寄存器中</p><p><strong>标量替换</strong></p><p><strong>标量</strong>：指一个无法在分解成更小的数据的数据。Java中的原始数据类型就是标量</p><p><strong>聚合量</strong>：Java中的聚合量指的就是类，封装的行为就是聚合</p><p><strong>标量替换</strong>：在未发生逃逸的情况下，函数内部生成的聚合量在经过JIT优化后会将其拆解为标量</p><p><strong>逃逸分析弊端</strong></p><p>需要进行一些列复杂的分析算法运算，相对耗时</p><p><strong>对象的生产与对象内存分布</strong></p><p><strong>对象创建的几种实例化方案</strong></p><p>1.new</p><p>2.Class.newInstance</p><p>3.Cpmstructor.newInstance(xxx)</p><p>4.obi.clone</p><p>5.反序列化</p><p><strong>字节码看对象内存创建过程</strong></p><img src="/2022/11/15/堆内存解析/image-20221115220014659.png" title="[堆内存解析]"><p>new=方法调用</p><p>dup = 复制</p><p>invokespecial = 调用构造器</p><img src="/2022/11/15/堆内存解析/image-20221115220108627.png" title="[堆内存解析]"><p><strong>对象内存布局</strong></p><img src="/2022/11/15/堆内存解析/image-20221115220127135.png" title="[堆内存解析]">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;运行时数据区&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&quot;/2022/11/15/堆内存解析/image-20221115214119142.png&quot; title=&quot;[堆内存解析]&quot;&gt;
&lt;p&gt;&lt;strong&gt;堆概述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.一个
      
    
    </summary>
    
    
      <category term="JVM" scheme="http://www.yppcat.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Activity问题</title>
    <link href="http://www.yppcat.top/2022/11/15/Activity%E9%97%AE%E9%A2%98/"/>
    <id>http://www.yppcat.top/2022/11/15/Activity问题/</id>
    <published>2022-11-15T12:50:50.000Z</published>
    <updated>2022-11-15T13:07:56.548Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Activity</strong>的启动流程</p><p><strong>Activity</strong>跨进程启动</p><p><a href="https://juejin.im/post/6844903959581163528#heading-1" target="_blank" rel="noopener">https://juejin.im/post/6844903959581163528#heading-1</a></p><p><a href="http://gityuan.com/2016/03/12/start-activity/" target="_blank" rel="noopener">http://gityuan.com/2016/03/12/start-activity/</a></p><p>启动流程：</p><p>点击桌面App图标，Launcher进程采用Binder IPC向system_server进程发起startActivity请求；</p><p>system_server进程接收到请求后，向zygote进程发送创建进程的请求；</p><p>Zygote进程fork出新的子进程，即App进程；</p><p>App进程，通过Binder IPC向sytem_server进程发起attachApplication请求；</p><p>system_server进程在收到请求后，进行一系列准备工作后，再通过binder IPC向App进 程发送</p><p>scheduleLaunchActivity请求；</p><p>App进程的binder线程（ApplicationThread）在收到请求后，通过handler向主线程发送LAUNCH_ACTIVITY消</p><p>息；</p><p>主线程在收到Message后，通过发射机制创建目标Activity，并回调Activity.onCreate()等方法。</p><p><strong>Activity</strong>进程内启动</p><p>请求进程A：startActivity—(hook插入点1) (AMP，ActivityManager代理对象)——&gt; system_server进程：</p><p>AMS(ActivityManagerService)解析Activity信息、处理启动参数、scheduleLaunchActivity/mH中EXECUTE_TRANSACTION消息处理(Android</p><p>P)–&gt;</p><p>回到请求进程A：ApplicationThread –&gt; ActivityThread -(hook插入点2)-&gt; Activity生命周期</p><img src="/2022/11/15/Activity问题/activity.png" title="[Activity问题]"><p><strong>1.2.onSaveInstanceState(),onRestoreInstanceState</strong>的掉用时机</p><p><strong>1.2.1onSaveInstanceState(Bundle outState)</strong>会在以下情况被调用：</p><p>1.2.1.1、从最近应用中选择运行其他的程序时。</p><p>1.2.1.2、当用户按下HOME键时。</p><p>1.2.1.3、屏幕方向切换时(无论竖屏切横屏还是横屏切竖屏都会调用)。</p><p>1.2.1.4、按下电源按键（关闭屏幕显示）时。</p><p>1.2.1.5、从当前activity启动一个新的activity时。</p><p>onPause -&gt; onSaveInstanceState -&gt; onStop。</p><p><strong>1.2.2onRestoreInstanceState(Bundle outState)</strong>会在以下情况被调用：onRestoreInstanceState(Bundle savedInstanceState)只有在activity确实是被系统回收，重新创建activity的情</p><p>况下才会被调用。</p><p>1.2.2.1.屏幕方向切换时，activity生命周期如下</p><p>onPause -&gt; onSaveInstanceState -&gt; onStop -&gt; onDestroy -&gt; onCreate -&gt; onStart -&gt; onRestoreInstanceState</p><p>-&gt; onResume</p><p>1.2.2.2.在后台被回收</p><p>1.2.2.3.按HOME键返回桌面,又马上点击应用图标回到原来页面时不会被回收</p><p>onStart -&gt; onRestoreInstanceState -&gt; onResume</p><p><strong>1.2.3</strong>源码</p><p>系统会调用ActivityThread的performStopActivity方法中掉用onSaveInstanceState， </p><p>将状态保存在mActivities</p><p>中，mActivities维护了一个Activity的信息表，当Activity重启时候，会从mActivities中查询到对应的</p><p>ActivityClientRecord。</p><p>如果有信息，则调用Activity的onResoreInstanceState方法，</p><p>在ActivityThread的performLaunchActivity方法中，统会判断ActivityClientRecord对象的state是否为空</p><p>不为空则通过Activity的onSaveInstanceState获取其UI状态信息，通过这些信息传递给Activity的onCreate方</p><p>法，</p><p><strong>1.3.activity</strong>的启动模式和使用场景</p><p><strong>1.3.1 android</strong>任务栈</p><p>我们每次打开一个新的Activity或者退出当前Activity都会在一个称为任务栈的结构中添加或者减少一个Activity组</p><p>件，一个任务栈包含了一个activity的集合。</p><p>android通过ActivityRecord、TaskRecord、ActivityStack，ActivityStackSupervisor，ProcessRecord有序地管</p><p>理每个activity。</p><p><strong>1.3.2 Standard</strong></p><p>默认模式，每次启动Activity都会创建一个新的Activity实例。</p><p><strong>1.3.3 SingleTop</strong></p><p>通知消息打开的页面</p><p>如果要启动的Activity已经在栈顶，则不会重新创建Activity，只会调用该该Activity的onNewIntent()方法。</p><p>如果要启动的Activity不在栈顶，则会重新创建该Activity的实例。</p><p><strong>1.3.4 SingleTask</strong></p><p>主界面</p><p>如果要启动的Activity已经存在于它想要归属的栈中，那么不会创建该Activity实例，将栈中位于该Activity上的所</p><p>有的Activity出栈，同时该Activity的onNewIntent()方法会被调用。</p><p><strong>1.3.5SingleInstance</strong></p><p>呼叫来电界面要创建在一个新栈，然后创建该Activity实例并压入新栈中，新栈中只会存在这一个Activity实例。</p><p><strong>1.4.Activity A</strong>跳转<strong>Activity B</strong>，再按返回键，生命周期执行的顺序</p><p><a href="https://www.sohu.com/a/402329833_611601" target="_blank" rel="noopener">https://www.sohu.com/a/402329833_611601</a></p><p><a href="https://www.jianshu.com/p/6d9d830a758d" target="_blank" rel="noopener">https://www.jianshu.com/p/6d9d830a758d</a></p><p>在A跳转B会执行：A onPause -&gt; B onCreate -&gt; B onStart -&gt; B onResume-&gt;A onStop</p><p>在B按下返回键会执行：B onPause -&gt; A onRestart -&gt; A onStart -&gt; A onResume-&gt; B onStop -&gt; B onDestroy</p><p>当A跳转到B的时候，A先执行onPause，然后居然是B再执行onCreate -&gt; onStart -&gt; onResume，最后才执行A</p><p>的onStop!!!</p><p>当B按下返回键，B先执行onPause，然后居然是A再执行onRestart -&gt; onStart -&gt; onResume，最后才是B执行</p><p>onStop -&gt; onDestroy!!!</p><p>当 B Activity 的 launchMode 为 singleInstance，singleTask 且对应的 B Activity 有可复用的实例时，生命周期</p><p>回调是这样的:</p><p>A.onPause -&gt; B.onNewIntent -&gt; B.onRestart -&gt; B.onStart -&gt; B.onResume -&gt; A.onStop -&gt; ( 如果 A 被移出栈的</p><p>话还有一个 A.onDestory)</p><p>当 B Activity 的 launchMode 为 singleTop且 B Activity 已经在栈顶时（一些特殊情况如通知栏点击、连点），</p><p>此时只有 B 页面自己有生命周期变化:</p><p>B.onPause -&gt; B.onNewIntent -&gt; B.onResume</p><p><strong>1.5.</strong>横竖屏切换<strong>,</strong>按<strong>home</strong>键<strong>,</strong>按返回键<strong>,</strong>锁屏与解锁屏幕<strong>,</strong>跳转透明<strong>Activity</strong>界面,</p><p><strong>启动一个</strong> <strong>Theme</strong> <strong>为</strong> <strong>Dialog</strong> <strong>的</strong> <strong>Activity</strong>，弹出<strong>Dialog</strong>时<strong>Activity</strong>的生命周期</p><p><strong>横竖屏切换</strong>：</p><p>从 Android 3.2 (API级别 13)开始</p><p><a href="https://www.jianshu.com/p/dbc7e81aead2" target="_blank" rel="noopener">https://www.jianshu.com/p/dbc7e81aead2</a></p><p>1、不设置Activity的androidconfifigChanges，或设置Activity的androidconfifigChanges=”orientation”，或设置</p><p>Activity的android:confifigChanges=”orientation|keyboardHidden”，切屏会重新调用各个生命周期，切横屏时会执</p><p>行一次，切竖屏时会执行一次。</p><p>2、配置 android:confifigChanges=”orientation|keyboardHidden|screenSize”，才不会销毁 activity，且只调</p><p>用 onConfifigurationChanged方法。</p><p>竖屏：</p><p>启动：onCreat-&gt;onStart-&gt;onResume.</p><p>切换横屏时：</p><p>onPause-&gt; onSaveInstanceState -&gt;onStop-&gt;onDestory</p><p>onCreat-&gt;onStart-&gt;onSaveInstanceState-&gt;onResume.</p><p>如果配置这个属性:androidconfifigChanges=”orientation|keyboardHidden|screenSize”</p><p>就不会在调用Activity的生命周期，只会调用onConfifigurationChanged方法<strong>HOME</strong>键的执行顺序：onPause-&gt;onStop-&gt;onRestart-&gt;onStart-&gt;onResume</p><p><strong>BACK</strong>键的顺序： onPause-&gt;onStop-&gt;onDestroy-&gt;onCreate-&gt;onStart-&gt;onResume</p><p><strong>锁屏</strong>：锁屏时只会调用onPause()，而不会调用onStop方法，开屏后则调用onResume()。</p><p><strong>弹出</strong> <strong>Dialog</strong>： </p><p>直接是通过 WindowManager.addView 显示的（没有经过 AMS），所以不会对生命周期有任何</p><p>影响。</p><p><strong>启动</strong>theme<strong>为</strong>DialogActivity,<strong>跳转透明</strong>Activity</p><p>A.onPause -&gt; B.onCrete -&gt; B.onStart -&gt; B.onResume</p><p>（ Activity 不会回调 onStop，因为只有在 Activity 切到后台不可见才会回调 onStop）</p><p><a href="https://www.sohu.com/a/402329833_611601" target="_blank" rel="noopener">https://www.sohu.com/a/402329833_611601</a></p><p><strong>1.6.onStart</strong> <strong>和</strong> <strong>onResume</strong>、<strong>onPause</strong> 和 <strong>onStop</strong> <strong>的区别</strong></p><p>onStart 和 onResume 从 Activity 可见可交互区分</p><p>onStart 用户可以看到部分activity但不能与它交互 onResume()可以获得activity的焦点，能够与用户交互</p><p>onStop 和 onPause 从 Activity 是否位于前台，是否有焦点区分</p><p>onPause表示当前页面失去焦点。</p><p>onStop表示当前页面不可见。</p><p>dialog的主题页面，这个时候，打开着一个页面，就只会执行onPause，而不会执行onStop。</p><p><strong>1.7.Activity</strong>之间传递数据的方式<strong>Intent</strong>是否有大小限制，如果传递的数据量</p><p><strong>偏大，有哪些方案</strong></p><p>startActivity-&gt;startActivityForResult-&gt;Instrumentation.execStartActivity</p><p>-&gt;ActivityManger.getService().startActivity</p><p>intent中携带的数据要从APP进程传输到AMS进程，再由AMS进程传输到目标Activity所在进程</p><p>通过Binder来实现进程间通信</p><p>1.Binder 驱动在内核空间创建一个数据接收缓存区。</p><p>2.在内核空间开辟一块内核缓存区，建立内核缓存区和内核空间的数据接收缓存区之间的映射关系，以及内核中</p><p>数据接收缓存区和接收进程用户空间地址的映射关系。</p><p>3.发送方进程通过系统调用 copyfromuser() 将数据 copy 到内核空间的内核缓存区，由于内核缓存区和接收进程</p><p>的用户空间存在内存映射，因此也就相当于把数据发送到了接收进程的用户空间，这样便完成了一次进程间的通信。</p><p>为当使用Intent来传递数据时，用到了Binder机制，数据就存放在了Binder的事务缓冲区里面，而事务缓冲区是</p><p>有大小限制的。普通的由Zygote孵化而来的用户进程，映射的Binder内存大小是不到1M的</p><p>Binder 本身就是为了进程间频繁-灵活的通信所设计的, 并不是为了拷贝大量数据</p><p>如果非 ipc</p><p>单例,eventBus,Application,sqlite、shared preference、fifile 都可以;如果是 ipc</p><p>1.共享内存性能还不错， </p><p>通过 MemoryFile 开辟内存空间，获得 FileDescriptor； </p><p>将 FileDescriptor 传递给其他</p><p>进程； </p><p>往共享内存写入数据； </p><p>从共享内存读取数据。(<a href="https://www.jianshu.com/p/4a4bc36000fc" target="_blank" rel="noopener">https://www.jianshu.com/p/4a4bc36000fc</a>)</p><p>2.Socket或者管道性能不太好，涉及到至少两次拷贝。</p><p><strong>1.8.Activity</strong>的<strong>onNewIntent()</strong>方法什么时候执行</p><p>果IntentActivity处于任务栈的顶端，也就是说之前打开过的Activity，现在处于onPause、onStop 状态的话，其</p><p>他应用再发送Intent的话，执行顺序为：onNewIntent，onRestart，onStart，onResume。</p><p>ActivityA已经启动过,处于当前应用的Activity堆栈中;</p><p>当ActivityA的LaunchMode为SingleTop时，如果ActivityA在栈顶,且现在要再启动ActivityA，这时会调用</p><p>onNewIntent()方法;</p><p>当ActivityA的LaunchMode为SingleInstance,SingleTask时,如果已经ActivityA已经在堆栈中，那么此时再次启动</p><p>会调用onNewIntent()方法;</p><p><strong>1.9.</strong>显示启动和隐式启动</p><p><strong>显示启动</strong></p><p>1、构造方法传入Component，最常用的方式</p><p>2、setComponent(componentName)方法</p><p>3、setClass/setClassName方法</p><p><strong>隐式启动</strong></p><p><a href="https://www.jianshu.com/p/12c6253f1851" target="_blank" rel="noopener">https://www.jianshu.com/p/12c6253f1851</a></p><p>隐式Intent是通过在AndroidManifest文件中设置action、data、category，让系统来筛选出合适的Activity</p><p><strong>action</strong>的匹配规则</p><p>Intent-fifilter action可以设置多条</p><p>intent中的action只要与intent-fifilter其中的一条匹配成功即可，且intent中action最多只有一条</p><p>Intent-fifilter内必须至少包含一个action。</p><p><strong>category</strong>的匹配规则</p><p>Intent-fifilter内必须至少包含一个category，android:name为android.intent.category.DEFAULT。</p><p>intent-fifilter中，category可以有多条</p><p>intent中，category也可以有多条</p><p>intent中所有的category都可以在intent-fifilter中找到一样的（包括大小写）才算匹配成功</p><p><strong>data</strong>的匹配规则</p><p>intent-fifilter中可以设置多个data</p><p>intent中只能设置一个dataintent-fifilter中指定了data，intent中就要指定其中的一个data</p><p><strong>1.10.scheme</strong>使用场景<strong>,</strong>协议格式<strong>,</strong>如何使用</p><p>scheme是一种页面内跳转协议，是一种非常好的实现机制，通过定义自己的scheme协议，可以非常方便跳转</p><p>app中的各个页面</p><p>APP根据URL跳转到另外一个APP指定页面</p><p>可以通过h5页面跳转app原生页面</p><p>服务器可以定制化跳转app页面</p><p>Scheme链接格式样式</p><p>样式scheme://host/path?query</p><p>Uri.parse(“hr://test:8080/goods?goodsId=8897&amp;name=test”)</p><p>hr代表Scheme协议名称</p><p>test代表Scheme作用的地址域</p><p>8080代表改路径的端口号</p><p>/goods代表的是指定页面(路径)</p><p>goodsId和name代表传递的两个参数</p><p>使用</p><p>掉用</p><p><strong>1.11.ANR</strong> <strong>的四种场景</strong></p><p>ANR 的四种场景：</p><p>Service TimeOut: service 未在规定时间执行完成：前台服务 20s，后台 200s</p><p><intent-filter></intent-filter></p><!-- 协议部分配置 ,注意需要跟web配置相同--><!--协议部分，随便设置 hr://test:8080/goods?name=test --><p>&lt;data android:scheme=”hr”</p><p>android:host=”test”</p><p>android:path=”/goods”</p><p>android:port=”8080”/&gt;</p><!--下面这几行也必须得设置--><category android:name="android.intent.category.DEFAULT"><category android:name="android.intent.category.BROWSABLE"><action android:name="android.intent.action.VIEW"><p></p><p>Intent intent = new Intent(Intent.ACTION_VIEW,Uri.parse(“hr://test:8080/goods?name=test”));</p><p>startActivity(intent);BroadCastQueue TimeOut: 未在规定时间内未处理完广播：前台广播 10s 内, 后台 60s 内</p><p>ContentProvider TimeOut: publish 在 10s 内没有完成</p><p>Input Dispatching timeout: 5s 内未响应键盘输入、触摸屏幕等事件</p><p>我们可以看到， Activity 的生命周期回调的阻塞并不在触发 ANR 的场景里面，所以并不会直接触发 ANR。</p><p>只不过死循环阻塞了主线程，如果系统再有上述的四种事件发生，就无法在相应的时间内处理从而触发 ANR。</p><p><strong>1.12.onCreate</strong>和<strong>onRestoreInstance</strong>方法中恢复数据时的区别</p><p>onSaveInstanceState 不一定会被调用，因为它只有在上次activity被回收了才会调用。</p><p>onCreate()里的Bundle参数可能为空，一定要做非空判断。 而onRestoreInstanceState的Bundle参数一定不会</p><p>是空值。</p><p><strong>1.13.activty</strong>间传递数据的方式</p><p>通过 Intent 传递（Intent.putExtra 的内部也是维护的一个 Bundle，因此，通过 putExtra 放入的 数据，取出时</p><p>也可以通过 Bundle 去取）</p><p>通过全局变量传递</p><p>通过 SharedPreferences 传递</p><p>通过数据库传递</p><p>通过文件传递</p><p><strong>1.14.</strong>跨<strong>App</strong>启动<strong>Activity</strong>的方式<strong>,</strong>注意事项</p><p><a href="https://www.jianshu.com/p/ad01ac11b4f1" target="_blank" rel="noopener">https://www.jianshu.com/p/ad01ac11b4f1</a></p><p><a href="https://juejin.im/post/6844904056461197326#heading-0" target="_blank" rel="noopener">https://juejin.im/post/6844904056461197326#heading-0</a></p><p><strong>使用</strong>intentFilter(<strong>隐式跳转</strong>)</p><p>在Manifest的Activity标签中添加：</p><p>启动时：startActivity(new Intent(“com.example.test.action.BActivity”))</p><p>如果有两个action属性值相同的Activity，那么在启动时手机系统会让你选择启动哪一个Activity</p><p>要解决这个问题，需要给被启动的Activity再加上一个属性，</p><p>然后再启动该Activity的Intent中加上一个URI，其中“app”必须与data属性的scheme的值一样，</p><p>intent=new Intent(“com.zs.appb.intent.action.BeStartActivity”, Uri.parse(“app://hello”));</p><p><strong>共享uid</strong>的<strong>App</strong></p><p>android中uid用于标识一个应用程序，uid在应用安装时被分配，并且在应用存在于手机上期间，都不会改变。</p><p>一个应用程序只能有一个uid，多个应用可以使用sharedUserId 方式共享同一个uid，前提是这些应用的签名要相</p><p>同。</p><p>在AndroidManifest中：manifest标签中添加android:sharedUserId=”xxxx”启动时：startActivity(new Intent().setComponent(new</p><p>ComponentName(“com.example.test”,”com.example.test.XxxActivity”)));</p><p><strong>使用</strong>exported</p><p>一旦设置了intentFilter之后，exported就默认被设置为true了</p><p>在Manifest中添加exported属性</p><p>启动时：startActivity(new Intent().setComponent(new</p><p>ComponentName(“com.example.zhu”,”com.example.zhu.XxxActivity”)));</p><p><strong>注意</strong>(如何防止自己的<strong>Activity</strong>被外部非正常启动):</p><p>如果AppB设置了android:permission=”xxx.xxx.xx”那么， </p><p>就必须在你的AppA的AndroidManifast.xml中uses</p><p>permission xxx.xxx.xx才能访问人家的东西。</p><p>给AppA的manifest中添加权限：</p><p>gei AppB中需要启动的Activity添加permission属性：</p><p>android:permission=”com.example.test”</p><p><strong>1.15.Activity</strong>任务栈是什么</p><p>1.android任务栈又称为Task，它是一个栈结构，具有后进先出的特性，用于存放我们的Activity组件。</p><p>2.我们每次打开一个新的Activity或者退出当前Activity都会在一个称为任务栈的结构中添加或者减少一个Activity</p><p>组件， </p><p>一个任务栈包含了一个activity的集合, 只有在任务栈栈顶的activity才可以跟用户进行交互。</p><p>3.在我们退出应用程序时，必须把所有的任务栈中所有的activity清除出栈时,任务栈才会被销毁。当然任务栈也</p><p>可以移动到后台, 并且保留了每一个activity的状态. 可以有序的给用户列出它们的任务, 同时也不会丢失Activity的状态</p><p>信息。</p><p>4.对应AMS中的ActivityRecord、TaskRecord、ActivityStack(AMS中的总结)</p><p><strong>1.16.</strong>有哪些<strong>Activity</strong>常用的标记位Flags</p><p>FLAG_ACTIVITY_NEW_TASK</p><p>此标记位作用是为Activity指定“singleTask”启动模式，其效果和在XML中指定相同</p><p>android:launchMode=”singleTask”</p><p>FLAG_ACTIVITY_SINGLE_TOP</p><p>此标记位作用是为Activity指定“singleTop”启动模式，其效果和在XML中指定相同</p><p>android:launchMode=”singleTop”</p><p>FLAG_ACTIVITY_CLEAR_TOP</p><p>具有此标记位的Activity，当它启动时，在同一个任务栈中位于它上面的Activity都要出栈。此标记位一般会和</p><p>singleTask启动模式一起出现，此情况下，若被启动的Activity实例存在，则系统会调用它的onNewIntent。</p><p><strong>1.17.Activity</strong>的数据是怎么保存的<strong>,</strong>进程被<strong>Kill</strong>后<strong>,</strong>保存的数据怎么恢复的</p><p><a href="https://www.wanandroid.com/wenda/show/12574在Activity的onSaveInstanceState方法回调时，put到参数outState（Bundle）里面。outState就是" target="_blank" rel="noopener">https://www.wanandroid.com/wenda/show/12574在Activity的onSaveInstanceState方法回调时，put到参数outState（Bundle）里面。outState就是</a></p><p>ActivityClientRecord的state。</p><p>ActivityClientRecord实例，都存放在ActivityThread的mActivities里面。</p><p>Activity变得不可见时（onSaveInstanceState和onStop回调之后），在应用进程这边会通过</p><p>ActivityTaskManagerService的activityStopped方法，把刚刚在onSaveInstanceState中满载了数据的Bundle对象，</p><p>传到系统服务进程那边！ </p><p>然后（在系统服务进程这边），会进一步将这个Bundle对象，赋值到对应ActivityRecord的</p><p>icicle上</p><p>ActivityRecord是用来记录对应Activity的各种信息的，如theme，启动模式、当前是否可见等等（为了排版更简</p><p>洁，上图只列出来一个icicle），它里面还有很多管理Activity状态的相关方法；</p><p>TaskRecord就是大家耳熟能详的任务栈（从上图可以看出并不真的是栈）了，它的主要职责就是管理</p><p>ActivityRecord。每当Activity启动时，会先找到合适的TaskRecord（或创建新实例），然后将该Activity所对应的</p><p>ActivityRecord添加到TaskRecord的mActivities中；</p><p>ActivityStack管理着TaskRecord，当新TaskRecord被创建后，会被添加到它mTaskHistory里面。</p></action></category></category>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Activity&lt;/strong&gt;的启动流程&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Activity&lt;/strong&gt;跨进程启动&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/6844903959581163528#heading-1
      
    
    </summary>
    
    
      <category term="面试" scheme="http://www.yppcat.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>JVM底层核心技术解析</title>
    <link href="http://www.yppcat.top/2022/11/09/JVM%E5%BA%95%E5%B1%82%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E8%A7%A3%E6%9E%90/"/>
    <id>http://www.yppcat.top/2022/11/09/JVM底层核心技术解析/</id>
    <published>2022-11-09T00:24:50.000Z</published>
    <updated>2022-11-09T12:28:19.068Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM是一种规范"><a href="#JVM是一种规范" class="headerlink" title="JVM是一种规范"></a><strong>JVM是一种规范</strong></h1><h2 id="JVM从编译到执行"><a href="#JVM从编译到执行" class="headerlink" title="JVM从编译到执行"></a><strong>JVM从编译到执行</strong></h2><h3 id="Java程序的执行过程"><a href="#Java程序的执行过程" class="headerlink" title="Java程序的执行过程"></a><strong>Java程序的执行过程</strong></h3><p>一个 Java 程序，首先经过 javac 编译成 .class 文件，然后 JVM 将其加载到方法区，执行引擎将会执行这些字节码。执行时，会翻译成操作系统相关的函数。JVM 作为 .class 文件的翻译存在，输入字节码，调用操作系统函数。</p><p>过程如下：Java 文件-&gt;编译器&gt;字节码-&gt;JVM-&gt;机器码。</p><p>JVM 全称 Java Virtual Machine，也就是我们耳熟能详的 Java 虚拟机。它能识别 .class后缀的文件，并且能够解析它的指令，最终调用操作系统上的函数，完成我们想要的操作。</p><h3 id="JVM、JRE、JDK的关系"><a href="#JVM、JRE、JDK的关系" class="headerlink" title="JVM、JRE、JDK的关系"></a><strong>JVM、JRE、JDK的关系</strong></h3><p>JVM只是一个翻译，把Class翻译成机器识别的代码，但是需要注意，JVM 不会自己生成代码，需要大家编写代码，同时需要很多依赖类库，这个时候就需要用到JRE。</p><p>JRE是什么，它除了包含JVM之外，提供了很多的类库（就是我们说的jar包，它可以提供一些即插即用的功能，比如读取或者操作文件，连接网络，使用I/O等等之类的）这些东西就是JRE提供的基础类库。JVM 标准加上实现的一大堆基础类库，就组成了 Java 的运行时环境JRE</p><p>但对于程序员来说，JRE还不够。我写完要编译代码，还需要调试代码，还需要打包代码、有时候还需要反编译代码。所以我们会使用JDK，因为JDK还提供了一些非常好用的小工具，比如 javac（编译代码）、java、jar （打包代码）、javap（反编译&lt;反汇编&gt;）等。这个就是JDK。</p><p>具体文档可以通过官网去下载：<a href="https://www.oracle.com/java/technologies/javase-jdk8-doc-downloads.html" target="_blank" rel="noopener">https://www.oracle.com/java/technologies/javase-jdk8-doc-downloads.html</a></p><p>JVM的作用是：从软件层面屏蔽不同操作系统在底层硬件和指令的不同.</p><p><strong>同时JVM是一个虚拟化的操作系统，类似于Linux或者Windows的操作系统，只是它架在操作class</strong></p><h2 id="从跨平台到跨语言"><a href="#从跨平台到跨语言" class="headerlink" title="从跨平台到跨语言"></a><strong>从跨平台到跨语言</strong></h2><p><strong>跨平台：</strong>我们写的一个类，在不同的操作系统上（Linux、Windows、MacOS 等平台）执行，效果是一样，这个就是JVM的跨平台性。</p><p>为了实现跨平台型，不同操作系统有对应的JDK的版本。</p><p><a href="https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html" target="_blank" rel="noopener">https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html</a></p><img src="/2022/11/09/JVM底层核心技术解析/ad8d9f5b17ea81c364a1718838c6dd89-92934.jpg" title="[JVM底层核心技术解析]"><p><strong>跨语言（语言无关性）：</strong>JVM只识别字节码，所以JVM其实跟语言是解耦的，也就是没有直接关联，JVM运行不是翻译Java文件，而是识别class文件，这个一般称之为字节码。还有像Groovy 、Kotlin、Scala等等语言，它们其实也是编译成字节码，所以它们也可以在JVM上面跑，这个就是JVM的跨语<strong>J**</strong>ava的跨语言性一定程度上奠定了非常强大的java语言生态圈**。</p><h2 id="JVM的发展（非重点）"><a href="#JVM的发展（非重点）" class="headerlink" title="JVM的发展（非重点）"></a><strong>JVM的发展（非重点）</strong></h2><h3 id="常见的JVM实现"><a href="#常见的JVM实现" class="headerlink" title="常见的JVM实现"></a><strong>常见的JVM实现</strong></h3><p>对于Java开发来说，《Java虚拟机规范》才是最为官方、准确的一个文档，了解这个规范可以让我们更深入地理解JVM。我们平常说的JVM其实更多说的是HotSpot</p><p><strong>规范文档如下，7版本做了中文翻译，8版本没有。</strong></p><img src="/2022/11/09/JVM底层核心技术解析/735171f135788cb149872d2894bdcd64-17673.jpg" title="[JVM底层核心技术解析]"><p><strong>Hotspot</strong>：目前使用的最多的Java虚拟机。在命令行 java –version。它会输出你现在使用的虚拟机的名字、版本等信息、执行模式。</p><img src="/2022/11/09/JVM底层核心技术解析/13e6e882363296551801ac7664da2d01-12425.jpg" title="[JVM底层核心技术解析]"><p><strong>Jrockit</strong>：原来属于 BEA公司，曾号称世界上最快的JVM，后被Oracle公司收购，合并于Hotspot</p><p><strong>J9:</strong> IBM有自己的java虚拟机实现，它的名字叫做J9. 主要是用在IBM产品（IBM WebSphere和IBM的AIX平台上）</p><p><strong>TaobaoVM:</strong> 只有一定体量、一定规模的厂商才会开发自己的虚拟机，比如淘宝有自己的VM,它实际上是Hotspot的定制版，专门为淘宝准备的，阿里、天猫都是用的这款虚拟机。</p><p><strong>LiquidVM:</strong> 它是一个针对硬件的虚拟机，它下面是没有操作系统的（不是Linux也不是windows）,下面直接就是硬件，运行效率比较高。</p><p><strong>zing:</strong> 它属于zual这家公司，非常牛，是一个商业产品，很贵！它的垃圾回收速度非常快（1毫秒)</p><p><strong>毕昇：</strong>毕昇JDK是华为内部OpenJDK定制版Huawei JDK的开源版本，是一个高性能、可用于生产环境的OpenJDK发行版。Huawei JDK运行在华为内部500多个产品上，积累了大量使用场景和java开发者反馈的问题和诉求，解决了业务实际运行中遇到的多个问题，并在ARM架构上进行了性能优化，毕昇JDK运行在大数据等场景下可以获得更好的性能。毕昇JDK 8与Java SE标准兼容，目前仅支持Linux/AArch64平台。</p><p>具体<a href="https://gitee.com/openeuler/bishengjdk-8" target="_blank" rel="noopener">https://gitee.com/openeuler/bishengjdk-8</a></p><h1 id="JVM的内存区域"><a href="#JVM的内存区域" class="headerlink" title="JVM的内存区域"></a><strong>JVM的内存区域</strong></h1><h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a><strong>运行时数据区域</strong></h2><p><strong>运行时数据区的定义</strong>：Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域</p><p>Java 引以为豪的就是它的自动内存管理机制。相比于 C++的手动内存管理、复杂难以理解java的内存管理方便实用</p><p>所以要深入理解JVM必须理解内存虚拟化的概念。</p><p>在JVM中，JVM 内存主要分为堆、程序计数器、方法区、虚拟机栈和本地方法栈等。</p><p>同时按照与线程的关系也可以这么划分区域：</p><p>线程私有区域：一个线程拥有单独的一份内存区域。</p><p>线程共享区域：被所有线程共享，且只有一份。</p><p>这里还有一个直接内存，这个虽然不是运行时数据区的一部分，但是会被频繁使用。你可以理解成没有被虚拟机化的操作系统上的其他内存（比如操作系统上有8G内存，被JVM虚拟化了3G，那么还剩余5G， JVM是借助一些工具使用这5G内存的，这个内存部分称之为直接内存</p><img src="/2022/11/09/JVM底层核心技术解析/05f552a197a27c4b1837393af6326239-29369.jpg" title="[JVM底层核心技术解析]"><h1 id="JAVA方法的运行与虚拟机栈"><a href="#JAVA方法的运行与虚拟机栈" class="headerlink" title="JAVA方法的运行与虚拟机栈"></a><strong>JAVA方法的运行与虚拟机栈</strong></h1><p><strong>虚拟机栈是用来存放线程运行java方法所需的数据，指令、返回地址。</strong></p><p>其实在我们实际的代码中，一个线程是可以运行多个方法的。</p><p>比如：</p><img src="/2022/11/09/JVM底层核心技术解析/a7a84689533093632b75630d3dfc56f9-34956.jpg" title="[JVM底层核心技术解析]"><p>这段代码很简单，就是起一个main方法，在main方法运行中调用A方法，A方法中调用B方法B方法调用了C方法</p><p>我们把代码跑起来，线程1来运行这段代码， 线程1跑起来，就会有一个对应 的虚拟机栈，同时在执行每个方法的时候都会打包成一个栈帧。</p><p>比如main开始运行，打包一个栈帧送入到虚拟机栈。</p><img src="/2022/11/09/JVM底层核心技术解析/5e66ad2ec20a2980e06994b83f70d521-7936.jpg" title="[JVM底层核心技术解析]"><img src="/2022/11/09/JVM底层核心技术解析/a92daf320c248a0517a6cbec2d71ae0f-12022.jpg" title="[JVM底层核心技术解析]"><img src="/2022/11/09/JVM底层核心技术解析/d1dfa7f3cfb910982f2ebd88c049e92d-16513.jpg" title="[JVM底层核心技术解析]"><img src="/2022/11/09/JVM底层核心技术解析/1c29dad9106f63452cb3b9a3c492bf9c-20448.jpg" title="[JVM底层核心技术解析]"><p>C方法运行完了，C方法出栈，接着B方法运行完了，B方法出栈、接着A方法运行完了，A方法出栈，最后main方法运行完了，main方法这个栈帧就出栈了。</p><p>这个就是Java方法运行对虚拟机栈的一个影响。虚拟机栈就是用来存储线程运行方法中的数据的。而每一个方法对应一个栈帧。</p><h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a><strong>虚拟机栈</strong></h3><p><strong>栈的数据结构：</strong>先进后出(FILO)的数据结构，</p><p><strong>虚拟机栈的作用：</strong>在JVM运行过程中存储当前线程运行方法所需的数据，指令、返回地址<strong>。</strong></p><p><strong>虚拟机栈是基于线程的</strong>：哪怕你只有一个 main() 方法，也是以线程的方式运行的。在线程的生命周期中，参与计算的数据会频繁地入栈和出栈，栈的生命周期是和线程一样的。</p><p>虚拟机栈的大小缺省为1M，可用参数 –Xss调整大小，例如-Xss256k。</p><p>参数官方文档（JDK1.8）：<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html</a></p><img src="/2022/11/09/JVM底层核心技术解析/83c91a9c69cf358f05447cd3ba20d012-35177.jpg" title="[JVM底层核心技术解析]"><p><strong>栈帧</strong>：在每个 Java 方法被调用的时候，都会创建一个栈帧，并入栈。一旦方法完成相应的调用，则出栈。</p><p><strong>栈帧大体都包含四个区域</strong>：(局部变量表、操作数栈、动态连接、返回地址)</p><ol><li><strong>局部变量表:</strong></li></ol><p>顾名思义就是局部变量的表，用于存放我们的局部变量的（方法中的变量）。首先它是一个32位的长度，主要存放我们的Java的八大基础数据类型，一般32位就可以存放下，如果是64位的就使用高低位占用两个也可以存放下，如果是局部的一些对象，比如我们的Object对象，我们只需要存放它的一个引用地址即可。</p><ol><li><strong>操作数据栈</strong>：</li></ol><p>存放java方法执行的操作数的，它就是一个栈，先进后出的栈结构，操作数栈，就是用来操作的，操作的的元素可以是任意的java数据类型，所以我们知道一个方法刚刚开始的时候，这个方法的操作数栈就是空的。</p><p><strong>操作数栈本质上是JVM执行引擎的一个工作</strong>区，也就是方法在执行，才会对操作数栈进行操作，如果代码不不执行，操作数栈其实就是空的。</p><ol><li><strong>动态连接:</strong></li></ol><p>Java语言特性多态（后续章节细讲，需要结合class与执行引擎一起来讲）。</p><ol><li><strong>返回地址:</strong></li></ol><p>正常返回（调用程序计数器中的地址作为返回）、异常的话（通过异常处理器表&lt;非栈帧中&gt;</p><p><strong>同时，</strong>虚拟机栈这个内存也不是无限大，它有大小限制，默认情况下是1M。</p><p>如果我们不断的往虚拟机栈中入栈帧，但是就是不出栈的话，那么这个虚拟机栈就会爆掉。</p><img src="/2022/11/09/JVM底层核心技术解析/cd16745c0ee8153207bf28463c301129-23745.jpg" title="[JVM底层核心技术解析]"><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a><strong>程序计数器</strong></h3><p>较小的内存空间，当前线程执行的字节码的行号指示器；各线程之间独立存储，互不影响。</p><p>程序计数器是一块很小的内存空间，主要用来记录各个线程执行的字节码的地址，例如，分支、循环、跳转、异常、线程恢复等都依赖于计数器。</p><p>由于 Java 是多线程语言，当执行的线程数量超过 CPU 核数时，线程之间会根据时间片轮询争夺 CPU 资源。如果一个线程的时间片用完了，或者是其它原因导致这个线程的 CPU 资源被提前抢夺，那么这个退出的线程就需要单独的一个程序计数器，来记录下一条运行的指令</p><p>因为JVM是虚拟机，内部有完整的指令与执行的一套流程，所以在运行Java方法的时候需要使用程序计数器（记录字节码执行的地址或行号），如果是遇到本地方法（native方法），这个方法不是JVM来具体执行，所以程序计数器不需要记录了，这个是因为在操作系统层面也有一个程序计数器，这个会记录本地代码的执行的地址，</p><p>另外程序计数器也是JVM中唯一不会OOM(OutOfMemory)的内存区域。</p><h2 id="栈帧执行对内存区域的影响"><a href="#栈帧执行对内存区域的影响" class="headerlink" title="栈帧执行对内存区域的影响"></a><strong>栈帧执行对内存区域的影响</strong></h2><p>对class进行反汇编 javap –c XXXX.class</p><p>字节码助记码解释地址：<a href="https://cloud.tencent.com/developer/article/1333540" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1333540</a></p><img src="/2022/11/09/JVM底层核心技术解析/10a57513a293d00c5d5d6e29b212afc5-45523.jpg" title="[JVM底层核心技术解析]"><p>在JVM中，基于解释执行的这种方式是基于栈的引擎，这个说的栈，就是操作数栈。</p><p><strong>虚拟机栈：</strong></p><p>每个线程私有的，线程在运行时，在执行每个方法的时候都会打包成一个栈帧，存储了局部变量表，操作数栈，动态链接，方法出口等信息，然后放入栈。每个时刻正在执行的当前方法就是虚拟机栈顶的栈桢。方法的执行就对应着栈帧在虚拟机栈中入栈和出栈的过程。</p><p>栈的大小缺省为1M，可用参数 –Xss调整大小，例如-Xss256k</p><p>在编译程序代码的时候，栈帧中需要多大的局部变量表，多深的操作数栈都已经完全确定了，并且写入到方法表的Code属性之中，因此一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现。</p><p><strong>局部变量表:</strong>顾名思义就是局部变量的表，用于存放我们的局部变量的。首先它是一个32位的长度，主要存放我们的Java的八大基础数据类型，一般32位就可以存放下，如果是64位的就使用高低位占用两个也可以存放下，如果是局部的一些对象，比如我们的Object对象，我们只需要存放它的一个引用地址即可。（基本数据类型、对象引用、returnAddress类型）</p><p><strong>操作数据栈</strong>：存放我们方法执行的操作数的，它就是一个栈，先进后出的栈结构，操作数栈，就是用来操作的，操作的的元素可以是任意的java数据类型，所以我们知道一个方法刚刚开始的时候，这个方法的操作数栈就是空的，操作数栈运行方法是会一直运行入栈/出栈的操作</p><p><strong>动态连接**</strong>:**Java语言特性多态（需要类加载、运行时才能确定具体的方法，后续有详细的讲解）动态分派</p><p><strong>完成出口(返回地址)**</strong>:**</p><p>正常返回：（调用程序计数器中的地址作为返回）</p><p>三步曲：</p><p>恢复上层方法的局部变量表和操作数栈、</p><p>把返回值（如果有的话）压入调用者栈帧的操作数栈中、</p><p>调整程序计数器的值以指向方法调用指令后面的一条指令、</p><p>异常的话：（通过异常处理表&lt;非栈帧中的&gt;来确定）</p><h2 id="运行时数据区及JVM的整体内存结构"><a href="#运行时数据区及JVM的整体内存结构" class="headerlink" title="运行时数据区及JVM的整体内存结构"></a><strong>运行时数据区及JVM的整体内存结构</strong></h2><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a><strong>本地方法栈</strong></h3><p>本地方法栈跟 Java 虚拟机栈的功能类似，Java 虚拟机栈用于管理 Java 函数的调用，而本地方法栈则用于管理本地方法的调用。但本地方法并不是用 Java 实现的，而是由 C 语言实现的(比如Object.hashcode方法)。</p><p>本地方法栈是和虚拟机栈非常相似的一个区域，它服务的对象是 native 方法。你甚至可以认为虚拟机栈和本地方法栈是同一个区域。</p><p>虚拟机规范无强制规定，各版本虚拟机自由实现 ，HotSpot直接把本地方法栈和虚拟机栈合二为一 。</p><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a><strong>方法区</strong></h3><p>方法区（Method Area）是可供各条线程共享的运行时内存区域。它存储了每一个类的结构信息，例如运行时常量池（Runtime Constant Pool）字段和方法数据、构造函数和普通方法的字节码内容、还包括一些在类、实例、接口初始化时用到的特殊方法</p><p>方法区是JVM对内存的“逻辑划分”，在JDK1.7及之前很多开发者都习惯将方法区称为“永久代”，是因为在HotSpot 虚拟机中，设计人员使用了永久代来实现了 JVM 规范的方法区。在JDK1.8及以后使用了元空间来实现方法区。</p><h1 id="JVM整体知识模块"><a href="#JVM整体知识模块" class="headerlink" title="JVM整体知识模块"></a><strong>JVM整体知识模块</strong></h1><p>  JVM能涉及非常庞大的一块知识体系，比如内存结构、垃圾回收、类加载、性能调优、JVM自身优化技术、执行引擎、类文件结构、监控工具等。</p><p>但是在所有的知识体系中，都或多或少跟内存结构有一定的关系：</p><p>比如垃圾回收回收的就是内存、类加载加载到的地方也是内存、性能优化也涉及到内存优化、执行引擎与内存密不可分、类文件结构与内存的设计有关系，监控工具也会监控内存。所以内存结构处于JVM中核心位置。也是属于我们入门JVM学习的最好的选择。</p><h4 id="元空间"><a href="#元空间" class="headerlink" title="元空间"></a><strong>元空间</strong></h4><p>方法区与堆空间类似，也是一个共享内存区，所以方法区是线程共享的。假如两个线程都试图访问方法区中的同一个类信息，而这个类还没有装入 JVM，那么此时就只允许一个线程去加载它，另一个线程必须等待。</p><p>在 HotSpot 虚拟机、Java7 版本中已经将永久代的静态变量和运行时常量池转移到了堆中，其余部分则存储在 JVM 的非堆内存中，而 Java8 版本已经将方法区中实现的永久代去掉了，并用元空间（class metadata）代替了之前的永久代，并且元空间的存储位置是本地内存。</p><p><strong>元空间大小参数：</strong></p><p>jdk1.7及以前（初始和最大值）：-XX:PermSize；-XX:MaxPermSize；</p><p>jdk1.8以后（初始和最大值）：-XX:MetaspaceSize； -XX:MaxMetaspaceSize</p><p>jdk1.8以后大小就只受本机总内存的限制（如果不设置参数的话）</p><p>JVM参数参考：<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html</a></p><p>Java8 为什么使用元空间替代永久代，这样做有什么好处呢？</p><p>官方给出的解释是：</p><p>移除永久代是为了融合 HotSpot JVM 与 JRockit VM 而做出的努力，因为 JRockit 没有永久代，所以不需要配置永久代。</p><p>永久代内存经常不够用或发生内存溢出，抛出异常 java.lang.OutOfMemoryError: PermGen。这是因为在 JDK1.7 版本中，指定的 PermGen 区大小为 8M，由于 PermGen 中类的元数据信息在每次 FullGC 的时候都可能被收集，回收率都偏低，成绩很难令人满意；还有为 PermGen 分配多大的空间很难确定，PermSize 的大小依赖于很多因素，比如，JVM 加载的 class 总数、常量池的大小和方法的大小等。</p><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a><strong>运行时常量池</strong></h3><p>运行时常量池（Runtime Constant Pool）是每一个类或接口的常量池（Constant_Pool）的运行时表示形式，它包括了若干种不同的常量：从编译期可知的数值字面量到必须运行期解析后才能获得的方法或字段引用。</p><p>运行时常量池是方法区的一部分。</p><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a><strong>堆</strong></h3><p>堆是 JVM 上最大的内存区域，我们申请的几乎所有的对象，都是在这里存储的。</p><p>堆空间一般是程序启动时，就申请了，但是并不一定会全部使用。堆一般设置成可伸缩的。</p><p>随着对象的频繁创建，堆空间占用的越来越多，就需要不定期的对不再使用的对象进行回收。这个在 Java 中，就叫作 GC（Garbage Collection）。</p><p>那一个对象创建的时候，到底是在堆上分配，还是在栈上分配呢？这和两个方面有关：对象的类型和在 Java 类中存在的位置。</p><p>Java 的对象可以分为基本数据类型和普通对象。</p><p>对于普通对象来说，JVM 会首先在堆上创建对象，然后在其他地方使用的其实是它的引用。比如，把这个引用保存在虚拟机栈的局部变量表中。</p><p>对于基本数据类型来说（byte、short、int、long、float、double、char)，有两种情况。</p><p>当你在方法体内声明了基本数据类型的对象，它就会在栈上直接分配。其他情况，都是在堆上分配。</p><p><strong>堆大小参数：</strong></p><p>-Xms：堆的最小值；</p><p>-Xmx：堆的最大值；</p><p>-Xmn：新生代的大小；</p><p>-XX:NewSize；新生代最小值；</p><p>-XX:MaxNewSize：新生代最大值；</p><p>例如- Xmx256m</p><img src="/2022/11/09/JVM底层核心技术解析/daa42c744e7377298fead4d084203fed-61705.jpg" title="[JVM底层核心技术解析]"><h3 id="直接内存（堆外内存）"><a href="#直接内存（堆外内存）" class="headerlink" title="直接内存（堆外内存）"></a><strong>直接内存（堆外内存）</strong></h3><p>直接内存有一种更加科学的叫法，堆外内存。</p><p>JVM 在运行时，会从操作系统申请大块的堆内存，进行数据的存储；同时还有虚拟机栈、本地方法栈和程序计数器，这块称之为栈区。操作系统剩余的内存也就是堆外内存。</p><p>它不是虚拟机运行时数据区的一部分，也不是java虚拟机规范中定义的内存区域；如果使用了NIO,这块区域会被频繁使用，在java堆内可以用directByteBuffer对象直接引用并操作；</p><p>这块内存不受java堆大小限制，但受本机总内存的限制，可以通过-XX:MaxDirectMemorySize来设置（默认与堆内存最大值一样），所以也会出现OOM异常。</p><p><strong>小结：</strong></p><p>1、直接内存主要是通过 DirectByteBuffer 申请的内存，可以使用参数“MaxDirectMemorySize”来限制它的大小。</p><p>2、其他堆外内存，主要是指使用了Unsafe 或者其他 JNI 手段直接直接申请的内存。</p><p>堆外内存的泄漏是非常严重的，它的排查难度高、影响大，甚至会造成主机的死亡。后续章节会详细讲。</p><p><strong>同时，要注意**</strong>Oracle<strong> </strong>之前<strong><a href="https://docs.google.com/document/d/1GDm_cAxYInmoHMor-AkStzWvwE9pw6tnz_CebJQxuUE/edit?pli=1" target="_blank" rel="noopener">计划在Java 9中去掉</a><a href="https://docs.google.com/document/d/1GDm_cAxYInmoHMor-AkStzWvwE9pw6tnz_CebJQxuUE/edit?pli=1" target="_blank" rel="noopener"> </a><a href="https://docs.google.com/document/d/1GDm_cAxYInmoHMor-AkStzWvwE9pw6tnz_CebJQxuUE/edit?pli=1" target="_blank" rel="noopener">sun.misc.Unsafe</a> </strong>API<strong>**。这里删除sun.misc.Unsafe的原因之一是使Java更加安全，并且有替代方案。</strong></p><p><strong>目前我们主要针对的JDK1.8，JDK1.9暂时不放入讨论范围中，我们大致知道java的发展即可。</strong></p><h1 id="深入理解JVM的内存区域"><a href="#深入理解JVM的内存区域" class="headerlink" title="深入理解JVM的内存区域"></a><strong>深入理解JVM的内存区域</strong></h1><h2 id="深入理解运行时数据区"><a href="#深入理解运行时数据区" class="headerlink" title="深入理解运行时数据区"></a><strong>深入理解运行时数据区</strong></h2><p>代码示例：</p><img src="/2022/11/09/JVM底层核心技术解析/a8fef8e29f5028c19f753261d52b83a7-39481.jpg" title="[JVM底层核心技术解析]"><ol><li>JVM 向操作系统申请内存：</li></ol><p>JVM 第一步就是通过配置参数或者默认配置参数向操作系统申请内存空间，根据内存大小找到具体的内存分配表，然后把内存段的起始地址和终止地址分配给 JVM，</p><ol><li>JVM 获得内存空间后，会根据配置参数分配堆、栈以及方法区的内存大小</li></ol><p>-Xms30m -Xmx30m -Xss1m -XX:MaxMetaspaceSize=30m</p><ol><li>类加载（类加载的细节后续章节会讲）：</li></ol><p>这里主要是把class放入方法区、还有class中的静态变量和常量也要放入方法区</p><ol><li>执行方法及创建对象：</li></ol><p>启动 main 线程，执行 main 方法，开始执行第一行代码。此时堆内存中会创建一个 student 对象，对象引用 student 就存放在栈中。</p><p>后续代码中遇到new关键字，会再创建一个 student 对象，对象引用 student 就存放在栈中。</p><img src="/2022/11/09/JVM底层核心技术解析/9349a35c4b34745f4918ef4b58dd0459-26553.jpg" title="[JVM底层核心技术解析]"><p><strong>总结一下JVM运行内存的整体流程</strong></p><p>JVM在操作系统上启动，申请内存，先进行运行时数据区的初始化，然后把类加载到方法区中</p><p>方法的执行和退出过程在内存上的体现上就是虚拟机栈中栈帧的入栈和出栈。</p><p>同时在方法的执行过程中创建的对象一般情况下都是放在堆中，最后堆中的对象也是需要进行垃圾回收清理的。</p><h2 id="从底层深入理解运行时数据区"><a href="#从底层深入理解运行时数据区" class="headerlink" title="从底层深入理解运行时数据区"></a><strong>从底层深入理解运行时数据区</strong></h2><h3 id="堆空间分代划分"><a href="#堆空间分代划分" class="headerlink" title="堆空间分代划分"></a><strong>堆空间分代划分</strong></h3><p>堆被划分为新生代和老年代（Tenured），新生代又被进一步划分为 Eden 和 Survivor 区，最后 Survivor 由 From Survivor 和 To Survivor 组成。</p><p>（先需要有概念，后续对象分配和垃圾回收会细讲这块）</p><img src="/2022/11/09/JVM底层核心技术解析/3c6974751e54c7b4d224827b88369b5f-11743.jpg" title="[JVM底层核心技术解析]"><h3 id="GC概念"><a href="#GC概念" class="headerlink" title="GC概念"></a><strong>GC概念</strong></h3><p>GC- Garbage Collection 垃圾回收，在JVM中是自动化的垃圾回收机制，我们一般不用去关注，在JVM中GC的重要区域是堆空间。</p><p>我们也可以通过一些额外方式主动发起它，比如System.gc(),主动发起。（项目中切记不要使用）</p><h3 id="JHSDB工具"><a href="#JHSDB工具" class="headerlink" title="JHSDB工具"></a><strong>JHSDB工具</strong></h3><p>JHSDB是一款基于服务性代理实现的进程外调试工具。</p><h4 id="JDK1-8的开启方式"><a href="#JDK1-8的开启方式" class="headerlink" title="JDK1.8的开启方式"></a><strong>JDK1.8的开启方式</strong></h4><p>开启HSDB工具</p><p>Jdk1.8启动JHSDB的时候必须将sawindbg.dll（一般会在JDK的目录下）复制到对应目录的jre下(注意在win上安装了JDK1.8后往往同级目录下有一个jre的目录)</p><img src="/2022/11/09/JVM底层核心技术解析/63edccc6d7db50a92e6681593abc5720-5997.jpg" title="[JVM底层核心技术解析]"><img src="/2022/11/09/JVM底层核心技术解析/972524a754061847dcb85d0c6129268e-70596.jpg" title="[JVM底层核心技术解析]"><p> 然后到目录：C:\Program Files\Java\jdk1.8.0_101\lib 进入命令行，执行 java -cp .\sa-jdi.jar sun.jvm.hotspot.HSDB</p><img src="/2022/11/09/JVM底层核心技术解析/f4f9bffa8663aba6bb3b4f2474f7cd87-20526.jpg" title="[JVM底层核心技术解析]"><h4 id="JDK1-9及以后的开启方式"><a href="#JDK1-9及以后的开启方式" class="headerlink" title="JDK1.9及以后的开启方式"></a><strong>JDK1.9及以后的开启方式</strong></h4><p>进入JDK的bin目录下，我们可以在命令行中使用 jhsdb hsdb 来启动它</p><h3 id="代码改造"><a href="#代码改造" class="headerlink" title="代码改造"></a><strong>代码改造</strong></h3><p>VM参数加入：</p><p>-XX:+UseConcMarkSweepGC</p><img src="/2022/11/09/JVM底层核心技术解析/e1a3c3cf44b4825c9172b1b5fe78d0f3-25393.jpg" title="[JVM底层核心技术解析]"><p>-XX:-UseCompressedOops</p><img src="/2022/11/09/JVM底层核心技术解析/e957dc2da3e0ac75429f5a7e5a5184d3-22751.jpg" title="[JVM底层核心技术解析]"><img src="/2022/11/09/JVM底层核心技术解析/d46a2e3e648f83d171545d34d377e681-102103.jpg" title="[JVM底层核心技术解析]"><h3 id="JHSDB中查看对象"><a href="#JHSDB中查看对象" class="headerlink" title="JHSDB中查看对象"></a><strong>JHSDB中查看对象</strong></h3><h4 id="实例代码启动"><a href="#实例代码启动" class="headerlink" title="实例代码启动"></a><strong>实例代码启动</strong></h4><img src="/2022/11/09/JVM底层核心技术解析/4d1d74845f0a34b73e8193d7b5784223-82593.jpg" title="[JVM底层核心技术解析]"><p>因为JVM启动有一个进程，需要借助一个命令 jps查找到对应程序的进程</p><img src="/2022/11/09/JVM底层核心技术解析/7fac4ceb927b05636b62636a12fb7e2e-13027.jpg" title="[JVM底层核心技术解析]"><p>在JHSDB工具中attach上去</p><img src="/2022/11/09/JVM底层核心技术解析/5258c23ee3108a8f8dc496996eacf213-11926.jpg" title="[JVM底层核心技术解析]"><img src="/2022/11/09/JVM底层核心技术解析/d6b2e658c74b70b0c1d477362a69d585-16588.jpg" title="[JVM底层核心技术解析]"><img src="/2022/11/09/JVM底层核心技术解析/759ba88e8789a5275272d0c753c36a6a-13115.jpg" title="[JVM底层核心技术解析]"><h4 id="JHSDB中查看对象-1"><a href="#JHSDB中查看对象-1" class="headerlink" title="JHSDB中查看对象"></a><strong>JHSDB中查看对象</strong></h4><p><strong>查看堆参数：</strong></p><img src="/2022/11/09/JVM底层核心技术解析/6e29bd2ce5bb7b4194994091e3c45778-20554.jpg" title="[JVM底层核心技术解析]"><img src="/2022/11/09/JVM底层核心技术解析/e42a3f8615b77b2f065e50432dfb0e18-19229.jpg" title="[JVM底层核心技术解析]"><p>上图中可以看到实际JVM启动过程中堆中参数的对照，可以看到，在不启动内存压缩的情况这是一篇连续的内存地址</p><p><strong>再来查看对象：</strong></p><img src="/2022/11/09/JVM底层核心技术解析/4dcc3bd040afcd1858b58b59a8630663-17928.jpg" title="[JVM底层核心技术解析]"><p>这里可以看到JVM中所有的对象，都是基于class的对象</p><img src="/2022/11/09/JVM底层核心技术解析/338f73e91d40a9bd8d8de5ca53a2fef8-45517.jpg" title="[JVM底层核心技术解析]"><p>全路径名搜索</p><img src="/2022/11/09/JVM底层核心技术解析/2a0c2da12ba6ff6f7b2887a8f66e9be7-44739.jpg" title="[JVM底层核心技术解析]"><p>双击出现这个Teacher类的对象，两个，就是T1和T2对象。</p><img src="/2022/11/09/JVM底层核心技术解析/1b3a05077d2032d32186e5c81aba5506-42815.jpg" title="[JVM底层核心技术解析]"><img src="/2022/11/09/JVM底层核心技术解析/8efd59b6f0f59d930b6fe38acddc02b6-47248.jpg" title="[JVM底层核心技术解析]"><img src="/2022/11/09/JVM底层核心技术解析/4c6bfd03a825f0b40b060dae8b215980-51026.jpg" title="[JVM底层核心技术解析]"><p>最后再对比一下堆中分代划分可以得出为什么T1在Eden,T2在老年代</p><img src="/2022/11/09/JVM底层核心技术解析/3cd487a42ebfb24dab04c7f144c3faf5-16637.jpg" title="[JVM底层核心技术解析]"><h3 id="JHSDB中查看栈"><a href="#JHSDB中查看栈" class="headerlink" title="JHSDB中查看栈"></a><strong>JHSDB中查看栈</strong></h3><img src="/2022/11/09/JVM底层核心技术解析/6925a2e9209edcbbd52f1535bab0e006-31070.jpg" title="[JVM底层核心技术解析]"><img src="/2022/11/09/JVM底层核心技术解析/9cf31d54b5196400f336fa63657479fd-45130.jpg" title="[JVM底层核心技术解析]"><p>从上图中可以验证栈内存，同时也可以验证到虚拟机栈和本地方法栈在Hotspot中是合二为一</p><img src="/2022/11/09/JVM底层核心技术解析/b60c7d10ff3c1df96fe57092009d8ccd-75765.jpg" title="[JVM底层核心技术解析]"><p>当我们通过 Java 运行以上代码时，JVM 的整个处理过程如下：</p><ol><li>JVM 向操作系统申请内存，JVM 第一步就是通过配置参数或者默认配置参数向操作系统申请内存空间。</li><li>JVM 获得内存空间后，会根据配置参数分配堆、栈以及方法区的内存大小。</li><li>完成上一个步骤后， JVM 首先会执行构造器，编译器会在.java 文件被编译成.class 文件时，收集所有类的初始化代码，包括静态变量赋值语句、静态代码块、静态方法，静态变量和常量放入方法区</li><li>执行方法。启动 main 线程，执行 main 方法，开始执行第一行代码。此时堆内存中会创建一个 Teacher 对象，对象引用 student 就存放在栈中。</li></ol><p>执行其他方法时，具体的操作：栈帧执行对内存区域的影响。栈帧执行对内存区域的影响</p><img src="/2022/11/09/JVM底层核心技术解析/e965af2e87c19418fc47fdd25d1988ee-144704.jpg" title="[JVM底层核心技术解析]"><img src="/2022/11/09/JVM底层核心技术解析/e1e87ae486afe54e701ee4daf1157dee-49321.jpg" title="[JVM底层核心技术解析]"><h2 id="内存溢出（重点）"><a href="#内存溢出（重点）" class="headerlink" title="内存溢出（重点）"></a><strong>内存溢出（重点）</strong></h2><h3 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a><strong>栈溢出</strong></h3><p>参数：-Xss1m， 具体默认值需要查看官网：[<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html#BABHDABI" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html#BABHDABI</a></p><p><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html /l BABHDABI" target="_blank" rel="noopener"></a></p><img src="/2022/11/09/JVM底层核心技术解析/dee835ad76430928ce2944aa73d4366c-58150.jpg" title="[JVM底层核心技术解析]"><p>HotSpot版本中栈的大小是固定的，是不支持拓展的。</p><p>java.lang.StackOverflowError一般的方法调用是很难出现的，如果出现了可能会是无限递归。</p><p>虚拟机栈带给我们的启示：方法的执行因为要打包成栈桢，所以天生要比实现同样功能的循环慢，所以树的遍历算法中：递归和非递归(循环来实现)都有存在的意义。递归代码简洁，非递归代码复杂但是速度较快。</p><p>OutOfMemoryError：不断建立线程，JVM申请栈内存，机器没有足够的内存。</p><p><strong>同时要注意，栈区的空间JVM没有办法去限制的，因为JVM在运行过程中会有线程不断的运行，没办法限制，所以只限制单个虚拟机栈的大小。</strong></p><h3 id="堆溢出"><a href="#堆溢出" class="headerlink" title="堆溢出"></a><strong>堆溢出</strong></h3><p>内存溢出：申请内存空间,超出最大堆内存空间。</p><p>如果是内存溢出，则通过 调大 -Xms，-Xmx参数。</p><p>如果不是内存泄漏，就是说内存中的对象却是都是必须存活的，那么久应该检查JVM的堆参数设置，与机器的内存对比，看是否还有可以调整的空间，再从代码上检查是否存在某些对象生命周期过长、持有状态时间过长、存储结构设计不合理等情况。</p><h3 id="方法区溢出"><a href="#方法区溢出" class="headerlink" title="方法区溢出"></a><strong>方法区溢出</strong></h3><p><strong>（1）</strong> 运行时常量池溢出</p><p><strong>（2）</strong>方法区中保存的Class对象没有被及时回收掉或者Class信息占用的内存超过了我们配置。</p><p><strong>注意Class要被回收，条件比较苛刻（仅仅是可以，不代表必然，因为还有一些参数可以进行设置</strong></p><ol><li><p>该类所有的实例都已经被回收，也就是堆中不存在该类的任何实例。</p></li><li><p>加载该类的ClassLoader已经被回收。</p></li><li><p>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该</p><img src="/2022/11/09/JVM底层核心技术解析/fe5c9f776176ce218d32920b78bd9927-18312.jpg" title="[JVM底层核心技术解析]"></li></ol><p><strong>代码示例：</strong></p><p>cglib是一个强大的，高性能，高质量的Code生成类库，它可以在运行期扩展Java类与实现Java接口。</p><p>CGLIB包的底层是通过使用一个小而快的<a href="https://baike.baidu.com/item/字节码 /t _blank" target="_blank" rel="noopener">字节码</a>处理框架ASM，来转换字节码并生成新的类。除了CGLIB包，<a href="https://baike.baidu.com/item/脚本语言 /t _blank" target="_blank" rel="noopener">脚本语言</a>例如Groovy和BeanShell，也是使用ASM来生成java的字节码。当然不鼓励直接使用ASM。</p><h3 id="本机直接内存溢出"><a href="#本机直接内存溢出" class="headerlink" title="本机直接内存溢出"></a><strong>本机直接内存溢出</strong></h3><p>直接内存的容量可以通过MaxDirectMemorySize来设置（默认与堆内存最大值一样），所以也会出现OOM异常；</p><p>由直接内存导致的内存溢出，一个比较明显的特征是在HeapDump文件中不会看见有什么明显的异常情况，如果发生了OOM，同时Dump文件很小，可以考虑重点排查下直接内存方面的原因</p><p><a href="https://j.youzan.com/0lt-j0" target="_blank" rel="noopener">  </a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JVM是一种规范&quot;&gt;&lt;a href=&quot;#JVM是一种规范&quot; class=&quot;headerlink&quot; title=&quot;JVM是一种规范&quot;&gt;&lt;/a&gt;&lt;strong&gt;JVM是一种规范&lt;/strong&gt;&lt;/h1&gt;&lt;h2 id=&quot;JVM从编译到执行&quot;&gt;&lt;a href=&quot;#JVM
      
    
    </summary>
    
    
      <category term="JVM" scheme="http://www.yppcat.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>kotlin笔记-标准函数</title>
    <link href="http://www.yppcat.top/2021/12/08/kotlin%E7%AC%94%E8%AE%B0-%E6%A0%87%E5%87%86%E5%87%BD%E6%95%B0/"/>
    <id>http://www.yppcat.top/2021/12/08/kotlin笔记-标准函数/</id>
    <published>2021-12-08T14:59:06.000Z</published>
    <updated>2021-12-08T15:14:46.728Z</updated>
    
    <content type="html"><![CDATA[<h4 id="let函数会将参数传入到lambda作用域中，返回作用域的最后一行"><a href="#let函数会将参数传入到lambda作用域中，返回作用域的最后一行" class="headerlink" title="let函数会将参数传入到lambda作用域中，返回作用域的最后一行"></a>let函数会将参数传入到lambda作用域中，返回作用域的最后一行</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> res = listOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>).first().let &#123;</span><br><span class="line">    it * it</span><br><span class="line">&#125;</span><br><span class="line">println(res)</span><br></pre></td></tr></table></figure><h4 id="also函数会返回接收者对象，作用域和功能类似，传入参数"><a href="#also函数会返回接收者对象，作用域和功能类似，传入参数" class="headerlink" title="also函数会返回接收者对象，作用域和功能类似，传入参数"></a>also函数会返回接收者对象，作用域和功能类似，传入参数</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> s = <span class="string">"hello"</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="string">""</span></span><br><span class="line">s.also &#123;</span><br><span class="line">    println(it)</span><br><span class="line">&#125;.also &#123;</span><br><span class="line">    m = it.uppercase()</span><br><span class="line">&#125;</span><br><span class="line">println(m)</span><br></pre></td></tr></table></figure><h4 id="apply函数会返回接受者对象并执行lambda中的内容，作用域中不需要再写当前参数"><a href="#apply函数会返回接受者对象并执行lambda中的内容，作用域中不需要再写当前参数" class="headerlink" title="apply函数会返回接受者对象并执行lambda中的内容，作用域中不需要再写当前参数"></a>apply函数会返回接受者对象并执行lambda中的内容，作用域中不需要再写当前参数</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> s = <span class="string">"hello"</span>.apply &#123;</span><br><span class="line">    capitalize()</span><br><span class="line">&#125;</span><br><span class="line">println(s)</span><br></pre></td></tr></table></figure><h4 id="run函数和apply作用域一样，但是返回lambda的结果，此外run还可以用来执行函数-链式调用也可以"><a href="#run函数和apply作用域一样，但是返回lambda的结果，此外run还可以用来执行函数-链式调用也可以" class="headerlink" title="run函数和apply作用域一样，但是返回lambda的结果，此外run还可以用来执行函数(链式调用也可以)"></a>run函数和apply作用域一样，但是返回lambda的结果，此外run还可以用来执行函数(链式调用也可以)</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> res = <span class="string">"hello"</span>.run &#123;</span><br><span class="line">        length</span><br><span class="line">    &#125;</span><br><span class="line">    println(res)</span><br><span class="line"></span><br><span class="line">    <span class="string">"The people of china"</span></span><br><span class="line">        .run(::isTooLong)</span><br><span class="line">        .run(::showMessage)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isTooLong</span><span class="params">(name : <span class="type">String</span>)</span></span> =  name.length &gt;= <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">showMessage</span><span class="params">(isLong: <span class="type">Boolean</span>)</span></span> :String&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (isLong)&#123;</span><br><span class="line">        println(<span class="string">"name is too long"</span>)</span><br><span class="line">        <span class="string">"name is too long"</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        println(<span class="string">"Please rename"</span>)</span><br><span class="line">        <span class="string">"Please rename"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="with函数功能和run一样，但是需要将值参作为第一个参数传入"><a href="#with函数功能和run一样，但是需要将值参作为第一个参数传入" class="headerlink" title="with函数功能和run一样，但是需要将值参作为第一个参数传入"></a>with函数功能和run一样，但是需要将值参作为第一个参数传入</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> isTooLong = with(<span class="string">"The people of China"</span>)&#123;</span><br><span class="line">        length &gt; <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(isTooLong)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="takeIf函数的lambda作用域和let相似，此函数需要在lambda作用域中给出true或者false-，true返回当前的对象，false返回Null"><a href="#takeIf函数的lambda作用域和let相似，此函数需要在lambda作用域中给出true或者false-，true返回当前的对象，false返回Null" class="headerlink" title="takeIf函数的lambda作用域和let相似，此函数需要在lambda作用域中给出true或者false ，true返回当前的对象，false返回Null"></a>takeIf函数的lambda作用域和let相似，此函数需要在lambda作用域中给出true或者false ，true返回当前的对象，false返回Null</h4><h4 id="takeUnless对于lambda的结果处理与之相反"><a href="#takeUnless对于lambda的结果处理与之相反" class="headerlink" title="takeUnless对于lambda的结果处理与之相反"></a>takeUnless对于lambda的结果处理与之相反</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> isLong = <span class="string">"The people of China"</span></span><br><span class="line">        .takeIf &#123; it.length &gt;= <span class="number">10</span> &#125;</span><br><span class="line">        ?.length</span><br><span class="line">    println(isLong)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//等价于上面</span></span><br><span class="line">    <span class="keyword">val</span> str = <span class="string">"The people of China"</span></span><br><span class="line">    isLong = <span class="keyword">if</span> (str.length &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">        str.length</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(isLong)</span><br><span class="line"></span><br><span class="line">    isLong = str</span><br><span class="line">        .takeUnless &#123; it.length &lt;= <span class="number">10</span> &#125;</span><br><span class="line">        ?.length</span><br><span class="line">    println(isLong)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;let函数会将参数传入到lambda作用域中，返回作用域的最后一行&quot;&gt;&lt;a href=&quot;#let函数会将参数传入到lambda作用域中，返回作用域的最后一行&quot; class=&quot;headerlink&quot; title=&quot;let函数会将参数传入到lambda作用域中，返回作
      
    
    </summary>
    
    
      <category term="kotlin" scheme="http://www.yppcat.top/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title>kotlin笔记-列表</title>
    <link href="http://www.yppcat.top/2021/12/08/kotlin%E7%AC%94%E8%AE%B0/"/>
    <id>http://www.yppcat.top/2021/12/08/kotlin笔记/</id>
    <published>2021-12-08T14:18:06.000Z</published>
    <updated>2021-12-08T14:59:33.174Z</updated>
    
    <content type="html"><![CDATA[<h4 id="kotlin普通列表"><a href="#kotlin普通列表" class="headerlink" title="kotlin普通列表"></a>kotlin普通列表</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="string">"jack"</span>, <span class="string">"lucy"</span>, <span class="string">"black"</span>)</span><br><span class="line">println(list.getOrElse(<span class="number">4</span>) &#123; <span class="string">"UnKnown"</span> &#125;)</span><br><span class="line">println(list.getOrNull(<span class="number">4</span>) ?: <span class="string">"UnKnown"</span>)</span><br><span class="line">println(list[<span class="number">2</span>])</span><br></pre></td></tr></table></figure><h4 id="list的for-each循环"><a href="#list的for-each循环" class="headerlink" title="list的for each循环"></a>list的for each循环</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="string">"jack"</span>, <span class="string">"jimmy"</span>, <span class="string">"jason"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (s <span class="keyword">in</span> list) &#123;</span><br><span class="line">    println(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">list.forEach &#123;</span><br><span class="line">    println(it)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">list.forEachIndexed &#123; index, s -&gt;</span><br><span class="line">    println(<span class="string">"<span class="variable">$index</span>  <span class="variable">$s</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此处的_参数被过滤掉，name proxy依次赋值0 1个元素</span></span><br><span class="line"><span class="keyword">val</span> (name,_,proxy) = listOf(<span class="string">"jack"</span>,<span class="string">"jimmy"</span>,<span class="string">"jason"</span>,<span class="string">"jacky"</span>)</span><br><span class="line">println(<span class="string">"name = <span class="variable">$name</span>   proxy = <span class="variable">$proxy</span>"</span>)</span><br></pre></td></tr></table></figure><h4 id="map列表"><a href="#map列表" class="headerlink" title="map列表"></a>map列表</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此处用了infix函数</span></span><br><span class="line"><span class="keyword">val</span> map = mapOf(<span class="string">"jack"</span> to <span class="number">20</span>, <span class="string">"jimmy"</span> to <span class="number">18</span>, <span class="string">"jason"</span> to <span class="number">24</span>)</span><br><span class="line">println(map)</span><br><span class="line"></span><br><span class="line"><span class="comment">//pair是map的子元素</span></span><br><span class="line"><span class="keyword">val</span> sMap = mapOf(Pair(<span class="string">"jack"</span>, <span class="number">20</span>), Pair(<span class="string">"jimmy"</span>, <span class="number">18</span>), Pair(<span class="string">"json"</span>, <span class="number">24</span>))</span><br><span class="line">println(map[<span class="string">"jack"</span>])</span><br><span class="line">println(sMap[<span class="string">"jimmy"</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">println(map.getOrElse(<span class="string">"jimmy"</span>) &#123; <span class="string">"UnKnown"</span> &#125;)</span><br><span class="line">println(map.getOrDefault(<span class="string">"jason"</span>) &#123; <span class="string">"UnKnown"</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//map的遍历</span></span><br><span class="line">map.forEach &#123;</span><br><span class="line">    println(<span class="string">"<span class="subst">$&#123;it.key&#125;</span>  <span class="subst">$&#123;it.value&#125;</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//map的遍历</span></span><br><span class="line">map.forEach &#123; (key, value) -&gt;</span><br><span class="line">    println(<span class="string">"key = <span class="variable">$key</span>  value = <span class="variable">$value</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="kotlin可变列表MutableList"><a href="#kotlin可变列表MutableList" class="headerlink" title="kotlin可变列表MutableList"></a>kotlin可变列表MutableList</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> mutableList = mutableListOf(<span class="string">"jack"</span>, <span class="string">"jimmy"</span>, <span class="string">"jacky"</span>)</span><br><span class="line">mutableList.add(<span class="string">"jason"</span>)</span><br><span class="line">mutableList.remove(<span class="string">"jack"</span>)</span><br><span class="line">println(mutableList)</span><br><span class="line"></span><br><span class="line">listOf(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>).toMutableList()</span><br><span class="line">mutableListOf(<span class="string">"m"</span>, <span class="string">"n"</span>, <span class="string">"o"</span>).toList()</span><br></pre></td></tr></table></figure><h4 id="kotlin可变列表MutableMap"><a href="#kotlin可变列表MutableMap" class="headerlink" title="kotlin可变列表MutableMap"></a>kotlin可变列表MutableMap</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> mutableMap = mutableMapOf(<span class="string">"Jack"</span> to <span class="number">20</span>, <span class="string">"Jason"</span> to <span class="number">18</span>, <span class="string">"Jacky"</span> to <span class="number">30</span>)</span><br><span class="line"><span class="comment">//此处用到了操作符重载</span></span><br><span class="line">mutableMap += <span class="string">"jimmy"</span> to <span class="number">1000</span></span><br><span class="line">mutableMap.put(<span class="string">"lucas"</span>, <span class="number">31</span>)</span><br><span class="line">mutableMap[<span class="string">"lucy"</span>] = <span class="number">30</span></span><br><span class="line"></span><br><span class="line">mutableMap.getOrPut(<span class="string">"lily"</span>)&#123; <span class="number">100</span> &#125;</span><br><span class="line"><span class="keyword">val</span> i = mutableMap.getOrPut(<span class="string">"jimmy"</span>)&#123; <span class="number">100</span> &#125;</span><br><span class="line"></span><br><span class="line">println(mutableMap)</span><br><span class="line">println(i)</span><br></pre></td></tr></table></figure><p>set列表</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> mutableSet = mutableSetOf(<span class="string">"Kotlin"</span>, <span class="string">"Java"</span>, <span class="string">"Scala"</span>)</span><br><span class="line">mutableSet += <span class="string">"Groovy"</span></span><br><span class="line"></span><br><span class="line">println(listOf(<span class="string">"Jack"</span>, <span class="string">"Jason"</span>, <span class="string">"Jacky"</span>,<span class="string">"Jacky"</span>).toSet().toList())</span><br><span class="line"></span><br><span class="line"><span class="comment">//去重的快捷函数</span></span><br><span class="line">println(listOf(<span class="string">"Jack"</span>, <span class="string">"Jason"</span>, <span class="string">"Jacky"</span>,<span class="string">"Jacky"</span>).distinct())</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;kotlin普通列表&quot;&gt;&lt;a href=&quot;#kotlin普通列表&quot; class=&quot;headerlink&quot; title=&quot;kotlin普通列表&quot;&gt;&lt;/a&gt;kotlin普通列表&lt;/h4&gt;&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;
      
    
    </summary>
    
    
      <category term="Kotlin" scheme="http://www.yppcat.top/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Activity启动流程</title>
    <link href="http://www.yppcat.top/2020/07/29/Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"/>
    <id>http://www.yppcat.top/2020/07/29/Activity启动流程/</id>
    <published>2020-07-29T03:40:07.000Z</published>
    <updated>2020-07-29T11:26:34.776Z</updated>
    
    <content type="html"><![CDATA[<p>我们看一下startActivity方法中到底发生了什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivity</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.startActivity(intent, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivity</span><span class="params">(Intent intent, @Nullable Bundle options)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (options != <span class="keyword">null</span>) &#123;</span><br><span class="line">            startActivityForResult(intent, -<span class="number">1</span>, options);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Note we want to go through this call for compatibility with</span></span><br><span class="line">            <span class="comment">// applications that may have overridden the method.</span></span><br><span class="line">            startActivityForResult(intent, -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivityForResult</span><span class="params">(@RequiresPermission Intent intent, <span class="keyword">int</span> requestCode,</span></span></span><br><span class="line"><span class="function"><span class="params">            @Nullable Bundle options)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">            options = transferSpringboardActivityOptions(options);</span><br><span class="line">            Instrumentation.ActivityResult ar =</span><br><span class="line">                mInstrumentation.execStartActivity(</span><br><span class="line">                    <span class="keyword">this</span>, mMainThread.getApplicationThread(), mToken, <span class="keyword">this</span>,</span><br><span class="line">                    intent, requestCode, options);</span><br><span class="line">            <span class="keyword">if</span> (ar != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mMainThread.sendActivityResult(</span><br><span class="line">                    mToken, mEmbeddedID, requestCode, ar.getResultCode(),</span><br><span class="line">                    ar.getResultData());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (requestCode &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// If this start is requesting a result, we can avoid making</span></span><br><span class="line">                <span class="comment">// the activity visible until the result is received.  Setting</span></span><br><span class="line">                <span class="comment">// this code during onCreate(Bundle savedInstanceState) or onResume() will keep the</span></span><br><span class="line">                <span class="comment">// activity hidden during this time, to avoid flickering.</span></span><br><span class="line">                <span class="comment">// This can only be done when a result is requested because</span></span><br><span class="line">                <span class="comment">// that guarantees we will get information back when the</span></span><br><span class="line">                <span class="comment">// activity is finished, no matter what happens to it.</span></span><br><span class="line">                mStartedActivity = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            cancelInputsAndStartExitTransition(options);</span><br><span class="line">            <span class="comment">// TODO Consider clearing/flushing other event sources and events for child windows.</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (options != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mParent.startActivityFromChild(<span class="keyword">this</span>, intent, requestCode, options);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Note we want to go through this method for compatibility with</span></span><br><span class="line">                <span class="comment">// existing applications that may have overridden it.</span></span><br><span class="line">                mParent.startActivityFromChild(<span class="keyword">this</span>, intent, requestCode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到最终都会走到上述的方法中，我们关注一下mParent==null这种情况，上面的ApplicationThread其实是ActivityThread的一个内部类，我们看下execStartActivity方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ActivityResult <span class="title">execStartActivity</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            Context who, IBinder contextThread, IBinder token, Activity target,</span></span></span><br><span class="line"><span class="function"><span class="params">            Intent intent, <span class="keyword">int</span> requestCode, Bundle options)</span> </span>&#123;</span><br><span class="line">        IApplicationThread whoThread = (IApplicationThread) contextThread;</span><br><span class="line">        Uri referrer = target != <span class="keyword">null</span> ? target.onProvideReferrer() : <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (referrer != <span class="keyword">null</span>) &#123;</span><br><span class="line">            intent.putExtra(Intent.EXTRA_REFERRER, referrer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mActivityMonitors != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mSync) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> N = mActivityMonitors.size();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++) &#123;</span><br><span class="line">                    <span class="keyword">final</span> ActivityMonitor am = mActivityMonitors.get(i);</span><br><span class="line">                    ActivityResult result = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (am.ignoreMatchingSpecificIntents()) &#123;</span><br><span class="line">                        result = am.onStartActivity(intent);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        am.mHits++;</span><br><span class="line">                        <span class="keyword">return</span> result;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (am.match(who, <span class="keyword">null</span>, intent)) &#123;</span><br><span class="line">                        am.mHits++;</span><br><span class="line">                        <span class="keyword">if</span> (am.isBlocking()) &#123;</span><br><span class="line">                            <span class="keyword">return</span> requestCode &gt;= <span class="number">0</span> ? am.getResult() : <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            intent.migrateExtraStreamToClipData();</span><br><span class="line">            intent.prepareToLeaveProcess(who);</span><br><span class="line">            <span class="keyword">int</span> result = ActivityManager.getService()</span><br><span class="line">                .startActivity(whoThread, who.getBasePackageName(), intent,</span><br><span class="line">                        intent.resolveTypeIfNeeded(who.getContentResolver()),</span><br><span class="line">                        token, target != <span class="keyword">null</span> ? target.mEmbeddedID : <span class="keyword">null</span>,</span><br><span class="line">                        requestCode, <span class="number">0</span>, <span class="keyword">null</span>, options);</span><br><span class="line">            checkStartActivityResult(result, intent);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Failure from system"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到最终都是由ActivityManager.getService()的startActivity方法来完成的</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们看一下startActivity方法中到底发生了什么：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span 
      
    
    </summary>
    
    
      <category term="android" scheme="http://www.yppcat.top/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Okhttp源码分析</title>
    <link href="http://www.yppcat.top/2020/07/27/Okhttp%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://www.yppcat.top/2020/07/27/Okhttp源码分析/</id>
    <published>2020-07-27T09:10:53.000Z</published>
    <updated>2020-07-28T10:11:11.552Z</updated>
    
    <content type="html"><![CDATA[<p>首先看Okhttp发起一个异步的请求：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testOkHttp</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        OkHttpClient okHttpClient = <span class="keyword">new</span> OkHttpClient.Builder().build();    <span class="comment">//构造 OkHttpClient</span></span><br><span class="line">        Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">                .get()  <span class="comment">//Method GET</span></span><br><span class="line">                .url(<span class="string">"www.baidu.com"</span>)</span><br><span class="line">                .build();    <span class="comment">//构造请求信息</span></span><br><span class="line"></span><br><span class="line">        okHttpClient.newCall(request)</span><br><span class="line">                .enqueue(<span class="keyword">new</span> Callback() &#123;    <span class="comment">//发起异步请求</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(<span class="keyword">final</span> Call call, <span class="keyword">final</span> Response response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                        <span class="comment">//成功拿到响应</span></span><br><span class="line">                        <span class="keyword">int</span> code = response.code();</span><br><span class="line">                        ResponseBody body = response.body();</span><br><span class="line">                        String string = body.string();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(<span class="keyword">final</span> Call call, <span class="keyword">final</span> IOException e)</span> </span>&#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们看下newCall方法，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Call <span class="title">newCall</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> RealCall(<span class="keyword">this</span>, request);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><code>newCall(Request)</code> 方法调用了 <code>RealCall.newRealCall()</code> 方法，这个 <code>RealCall.newRealCall()</code> 方法创建了一个新的<code>RealCall</code>对象，这个<code>RealCall</code>是<code>okhttp3.Call`</code> 接口的一个实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Call</span> <span class="keyword">extends</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">  <span class="comment">//返回这个请求关联的 Request 对象</span></span><br><span class="line">  <span class="function">Request <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//立即执行请求，阻塞等待拿到响应</span></span><br><span class="line">  <span class="function">Response <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//请求入队，异步执行</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Callback responseCallback)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//取消一个请求</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isExecuted</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isCanceled</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Call <span class="title">clone</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">interface</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function">Call <span class="title">newCall</span><span class="params">(Request request)</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，我们前面发起异步请求的 <code>enqueue()</code> 方法是定义在 <code>Call</code> 中的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">okHttpClient.newCall(request)</span><br><span class="line">                .enqueue(new Callback() &#123; ...&#125;);        //原来就是 Call 的方法</span><br></pre></td></tr></table></figure><p>在 OkHttp 中，<code>Call</code> 的唯一实现就是 <code>RealCall</code>，它表示一个准备好被执行的请求。和 <code>Request</code> 不同在于，它还提供了发起请求、取消等方法。</p><p>拿到 <code>OkHttp.Call</code> 的实例、<code>RealCall</code> 对象后，我们调用了它的 <code>enqueue()</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RealCall.enqueue()</span></span><br><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Callback responseCallback)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already Executed"</span>);</span><br><span class="line">    executed = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  captureCallStackTrace();</span><br><span class="line">  eventListener.callStart(<span class="keyword">this</span>);</span><br><span class="line">  client.dispatcher().enqueue(<span class="keyword">new</span> AsyncCall(responseCallback));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心就在最后这句 <code>client.dispatcher().enqueue(new AsyncCall(responseCallback));</code>，它做了两件事：</p><ol><li>创建一个 <code>AsyncCall</code> 对象</li><li>调用 <code>Dispatcher.enqueue()</code> 方法将请求入队</li></ol><p>先看下 <code>AsyncCall</code> 是何方神圣：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncCall</span> <span class="keyword">extends</span> <span class="title">NamedRunnable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Callback responseCallback;</span><br><span class="line"></span><br><span class="line">  AsyncCall(Callback responseCallback) &#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="string">"OkHttp %s"</span>, redactedUrl());</span><br><span class="line">    <span class="keyword">this</span>.responseCallback = responseCallback;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">String <span class="title">host</span><span class="params">()</span> </span>&#123;    <span class="comment">//用于标识这个请求</span></span><br><span class="line">    <span class="keyword">return</span> originalRequest.url().host();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Request <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> originalRequest;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">RealCall <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> RealCall.<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到， <code>AsyncCall</code> 就是一个 Runnable，用于异步执行任务。</p><p>接着看 <code>client.dispatcher()</code> 方法，它返回一个调度器 <code>Dispatcher</code>，这是 OkHttp 中比较核心的一个类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Dispatcher</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> maxRequests = <span class="number">64</span>;    <span class="comment">//同时最多发起 64 个请求</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> maxRequestsPerHost = <span class="number">5</span>;    <span class="comment">//同一 host 最多发起 5 个请求</span></span><br><span class="line">  <span class="keyword">private</span> <span class="meta">@Nullable</span> Runnable idleCallback;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="meta">@Nullable</span> ExecutorService executorService;    <span class="comment">//将会异步创建的线程池</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//等待被执行的异步请求队列</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;AsyncCall&gt; readyAsyncCalls = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//正在运行的异步请求队列（其中也包括取消后没有完成的请求）</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;AsyncCall&gt; runningAsyncCalls = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//正在运行的同步请求队列</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;RealCall&gt; runningSyncCalls = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Dispatcher</span><span class="params">(ExecutorService executorService)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.executorService = executorService;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Dispatcher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> ExecutorService <span class="title">executorService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (executorService == <span class="keyword">null</span>) &#123;</span><br><span class="line">      executorService = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">60</span>, TimeUnit.SECONDS,</span><br><span class="line">          <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(<span class="string">"OkHttp Dispatcher"</span>, <span class="keyword">false</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> executorService;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在一个 <code>OkHttpClient</code> 中一般只有一个 <code>Dispatcher</code>，因此一个 <code>OkHttpClient</code> 能发起的最多请求就是 <code>Dispatcher</code> 中定义的 64 个</li><li>同样，同一 host 能发起的最多请求是 5 个</li><li><code>Dispatcher</code> 中用三个队列保存同步、异步请求</li><li>默认线程池核心线程数量为 0，最多数量不限制，消息队列为 <code>SynchronousQueue</code>，因此有请求时会不断创建新线程</li></ul><p>接着我们看一下<strong>NamedRunnable</strong> 的execute在AsyncCall的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">boolean</span> signalledCallback = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Response response = getResponseWithInterceptorChain(forWebSocket);</span><br><span class="line">        <span class="keyword">if</span> (canceled) &#123;</span><br><span class="line">          signalledCallback = <span class="keyword">true</span>;</span><br><span class="line">          responseCallback.onFailure(RealCall.<span class="keyword">this</span>, <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          signalledCallback = <span class="keyword">true</span>;</span><br><span class="line">          responseCallback.onResponse(RealCall.<span class="keyword">this</span>, response);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (signalledCallback) &#123;</span><br><span class="line">          <span class="comment">// Do not signal the callback twice!</span></span><br><span class="line">          logger.log(Level.INFO, <span class="string">"Callback failure for "</span> + toLoggableString(), e);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          responseCallback.onFailure(RealCall.<span class="keyword">this</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        client.dispatcher().finished(<span class="keyword">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到，这个方法中先通过 <code>getResponseWithInterceptorChain()</code> 方法拿到了响应 <code>Response</code>，然后进行了回调，最后在 <code>finally</code> 代码块中调用了 <code>client.dispatcher().finished(this)</code> 方法，这个方法的作用是从调度器 Dispatcher 里移除当前这个请求，执行下一个。</p><p>我们重点看 <code>getResponseWithInterceptorChain()</code> 方法，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Response <span class="title">getResponseWithInterceptorChain</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// Build a full stack of interceptors.</span></span><br><span class="line">    List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    interceptors.addAll(client.interceptors());</span><br><span class="line">    interceptors.add(retryAndFollowUpInterceptor);</span><br><span class="line">    interceptors.add(<span class="keyword">new</span> BridgeInterceptor(client.cookieJar()));</span><br><span class="line">    interceptors.add(<span class="keyword">new</span> CacheInterceptor(client.internalCache()));</span><br><span class="line">    interceptors.add(<span class="keyword">new</span> ConnectInterceptor(client));</span><br><span class="line">    <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">      interceptors.addAll(client.networkInterceptors());</span><br><span class="line">    &#125;</span><br><span class="line">    interceptors.add(<span class="keyword">new</span> CallServerInterceptor(forWebSocket));</span><br><span class="line"></span><br><span class="line">    Interceptor.Chain chain = <span class="keyword">new</span> RealInterceptorChain(interceptors, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">0</span>,</span><br><span class="line">        originalRequest, <span class="keyword">this</span>, eventListener, client.connectTimeoutMillis(),</span><br><span class="line">        client.readTimeoutMillis(), client.writeTimeoutMillis());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> chain.proceed(originalRequest);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a><strong>小结</strong></h5><p>至此我们对 <code>OkHttp</code> 如何发起请求、逐层处理、拿到响应有了一个基本的认识，三句话概括一下：</p><ol><li>发起异步请求后会构造异步任务 <code>AsyncCall</code> 入队，等被执行时会调用它的 <code>execute()</code> 方法</li><li>这个执行方法会通过拦截器链，挨个调用我们自定义的和系统内置的 5 个拦截器，对请求信息和响应做处理，最后返回结果，回调我们传入的参数</li><li>然后从队列中移除当前任务，执行下一个，以此循环</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先看Okhttp发起一个异步的请求：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;lin
      
    
    </summary>
    
    
      <category term="android" scheme="http://www.yppcat.top/tags/android/"/>
    
  </entry>
  
</feed>
