{"meta":{"title":"Eric笔记","subtitle":"Eric笔记","description":null,"author":"Eric笔记","url":"http://www.yppcat.top"},"pages":[{"title":"","date":"2022-11-20T14:35:53.505Z","updated":"2019-01-24T12:45:02.000Z","comments":false,"path":"categories/index.html","permalink":"http://www.yppcat.top/categories/index.html","excerpt":"","text":""},{"title":"","date":"2020-07-27T09:11:27.113Z","updated":"2019-01-24T12:44:24.000Z","comments":false,"path":"tags/index.html","permalink":"http://www.yppcat.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"handler笔记","slug":"handler笔记","date":"2023-02-07T00:50:28.000Z","updated":"2023-02-07T01:14:07.596Z","comments":true,"path":"2023/02/07/handler笔记/","link":"","permalink":"http://www.yppcat.top/2023/02/07/handler笔记/","excerpt":"","text":"用一句话概括Handler，并简述其原理 Handler是Android系统的根本，在Android应用被启动的时候，会分配一个单独的虚拟机，虚拟机会执行ActivityThread中的main方法，在main方法中对主线程Looper进行了初始化，也就是几乎所有代码都执行在Handler内部。Handler也可以作为主线程和子线程通讯的桥梁。Handler通过sendMessage发送消息，将消息放入MessageQueue中，在MessageQueue中通过时间的维度来进行排序，Looper通过调用loop方法不断的从MessageQueue中获取消息，执行Handler的dispatchMessage，最后调用handleMessage方法。 为什么系统不建议在子线程访问UI？（为什么不能在子线程更新UI？） 在某些情况下，在子线程中是可以更新UI的。但是在ViewRootImpl中对UI操作进行了checkThread，但是我们在OnCreate和onResume中可以使用子线程更新UI，由于我们在ActivityThread中的performResumeActivity方法中通过addView创建了ViewRootImpl，这个行为是在onResume之后调用的，所以在OnCreate和onResume可以进行更新UI。 但是我们不能在子线程中更新UI，因为如果添加了耗时操作之后，一旦ViewRootImpl被创建将会抛出异常。一旦在子线程中更新UI，容易产生并发问题。 一个Thread可以有几个Looper？几个Handler？ 一个线程只能有一个Looper，可以有多个Handler，在线程中我们需要调用Looper.perpare,他会创建一个Looper并且将Looper保存在ThreadLocal中，每个线程都有一个LocalThreadMap，会将Looper保存在对应线程中的LocalThreadMap，key为ThreadLocal，value为Looper 可以在子线程直接new一个Handler吗？那该怎么做？ 可以在子线程中创建Handler，我们需要调用Looper.perpare和Looper.loop方法。或者通过获取主线程的looper来创建Handler Message可以如何创建？哪种效果更好，为什么？ Message.obtain来创建Message。这样会复用之前的Message的内存，不会频繁的创建对象，导致内存抖动。 主线程中Looper的轮询死循环为何没有阻塞主线程？ Looper轮询是死循环，但是当没有消息的时候他会block，ANR是当我们处理点击事件的时候5s内没有响应，我们在处理点击事件的时候也是用的Handler，所以一定会有消息执行，并且ANR也会发送Handler消息，所以不会阻塞主线程。 使用Hanlder的postDealy()后消息队列会发生什么变化？ Handler发送消息到消息队列，消息队列是一个时间优先级队列，内部是一个单向链表。发动postDelay之后会将该消息进行时间排序存放到消息队列中 点击页面上的按钮后更新TextView的内容，谈谈你的理解？ 点击按钮的时候会发送消息到Handler，但是为了保证优先执行，会加一个标记异步，同时会发送一个target为null的消息，这样在使用消息队列的next获取消息的时候，如果发现消息的target为null，那么会遍历消息队列将有异步标记的消息获取出来优先执行，执行完之后会将target为null的消息移除。(同步屏障) 生产者-消费者设计模式懂不？ 举个例子，面包店厨师不断在制作面包，客人来了之后就购买面包，这就是一个典型的生产者消费者设计模式。但是需要注意的是如果消费者消费能力大于生产者，或者生产者生产能力大于消费者，需要一个限制，在java里有一个blockingQueue。当目前容器内没有东西的时候，消费者来消费的时候会被阻塞，当容器满了的时候也会被阻塞。Handler.sendMessage相当于一个生产者,MessageQueue相当于容器，Looper相当于消费者。 Handler是如何完成子线程和主线程通信的？ 在主线程中创建Handler，在子线程中发送消息，放入到MessageQueue中,通过Looper.loop取出消息进行执行handleMessage，由于looper我们是在主线程初始化的，在初始化looper的时候会创建消息队列，所以消息是在主线程被执行的。 关于ThreadLocal，谈谈你的理解？ ThreadLocal类似于每个线程有一个单独的内存空间，不共享，ThreadLocal在set的时候会将数据存入对应线程的ThreadLocalMap中，key=ThreadLocal，value=值 享元设计模式有用到吗？ 享元设计模式就是重复利用内存空间，减少对象的创建，Message中使用到了享元设计模式。内部维护了一个链表，并且最大长度是50，当消息处理完之后会将消息内的属性设置为空，并且插入到链表的头部，使用obtain创建的Message会从头部获取空的Message Handler内存泄漏问题及解决方案 内部类持有外部类的引用导致了内存泄漏，如果Activity退出的时候，MessageQueue中还有一个Message没有执行，这个Message持有了Handler的引用，而Handler持有了Activity的引用，导致Activity无法被回收，导致内存泄漏。使用static关键字修饰，在onDestory的时候将消息清除。 Handler异步消息处理（HandlerThread） 内部使用了Handler+Thread，并且处理了getLooper的并发问题。如果获取Looper的时候发现Looper还没创建，则wait，等待looper创建了之后在notify 子线程中维护的Looper，消息队列无消息的时候处理方案是什么？有什么用？ 子线程中创建了Looper，当没有消息的时候子线程将会被block，无法被回收，所以我们需要手动调用quit方法将消息删除并且唤醒looper，然后next方法返回null退出loop 既然可以存在多个Handler往MessageQueue中添加数据(发消息是各个handler可能处于不同线程)，那他内部是如何确保线程安全的？ 在添加数据和执行next的时候都加了this锁，这样可以保证添加的位置是正确的，获取的也会是最前面的。 关于IntentService，谈谈你的理解 HandlerThread+Service实现，可以实现Service在子线程中执行耗时操作，并且执行完耗时操作时候会将自己stop。 Glide是如何维护生命周期的？ 一般想问的应该都是这里 @NonNull private RequestManagerFragment getRequestManagerFragment( @NonNull final android.app.FragmentManager fm, @Nullable android.app.Fragment parentHint,boolean isParentVisible) { RequestManagerFragment current = (RequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG); if (current == null) { current = pendingRequestManagerFragments.get(fm); if (current == null) { current = new RequestManagerFragment(); current.setParentFragmentHint(parentHint); if (isParentVisible) { current.getGlideLifecycle().onStart(); } pendingRequestManagerFragments.put(fm, current); fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss(); handler.obtainMessage(ID_REMOVE_FRAGMENT_MANAGER, fm).sendToTarget(); } } return current; } 1.为什么会判断两次null，再多次调用with的时候，commitAllowingStateLoss会被执行两次，所以我们需要使用一个map集合来判断，如果map中已经有了证明已经添加过了 2.handler.obtainMessage(ID_REMOVE_FRAGMENT_MANAGER, fm).sendToTarget();我们需要将map里面的记录删除。 Linux的epoll机制 epoll的通俗解释 epoll的通俗解释是一种当文件描述符的内核缓冲区非空的时候，发出可读信号进行通知，当写缓冲区不满的时候，发出可写信号通知的机制 epoll的核心是3个API，核心数据结构是：1个红黑树和1个链表 epoll_create1 : 创建一个epoll实例，文件描述符 epoll_ctl : 将监听的文件描述符添加到epoll实例中，实例代码为将标准输入文件描述符添加到epoll中 epoll_wait : 等待epoll事件从epoll实例中发生， 并返回事件以及对应文件描述符 epoll：采用回调机制。在执行epoll_ctl的add操作时，不仅将文件描述符放到红黑树上，而且也注册了回调函数， 内核在检测到某文件描述符可读/可写时会调用回调函数，该回调函数将文件描述符放在就绪链表中。 epoll高效的本质在于： 减少了用户态和内核态的文件句柄拷贝 减少了对可读可写文件句柄的遍历mmap 加速了内核与用户空间的信息传递，epoll是通过内核与用户mmap同一块内存，避免了无谓的内存拷贝 IO性能不会随着监听的文件描述的数量增长而下降 使用红黑树存储fd，以及对应的回调函数，其插入，查找，删除的性能不错，相比于hash，不必预先分配很多的空间","categories":[],"tags":[{"name":"android","slug":"android","permalink":"http://www.yppcat.top/tags/android/"}]},{"title":"jetpack","slug":"jetpack","date":"2022-12-28T03:07:25.000Z","updated":"2022-12-28T03:13:12.879Z","comments":true,"path":"2022/12/28/jetpack/","link":"","permalink":"http://www.yppcat.top/2022/12/28/jetpack/","excerpt":"","text":"Lifecycle 1.Activity实现了LifecycleOwner被观察者 addObserver添加观察者 map存入观察者2.LiveData粘性事件是因为添加时当前的version和被观察者的version不一致导致，可通过反射hook的方式修改3.Activity内部添加了ReportFragment来感知生命周期向观察者发送事件4.Activity实现了状态机，能够顺序显示和退出 同事同步自己的状态给被观察者5.LiveData观察者接收事件后再setValue会导致后续的观察者只能收到新的事件6.postValue本质是切到主线程在setValue 回调在主线程 ViewModel Boudle作为数据存储，就已经和当前Activity实例没有任何关系了！存储手段， 表层应用的是一个Hashmap 不受Activity实例影响，Bundle理解为进程中的共享数据区Activity继承ComponentActivity在内部通过LifeCycle监听到onSaveInstanceState事件通过mSavedStateRegistryController.performSave(outState)将数据存入到Bundle中内部通过LifeCycle监听到onDestroy事件通过getViewModelStore().clear()去清除Map中的数据，此处map中放的是ViewModel中的数据销毁重建走onCreate通过mSavedStateRegistryController.performRestore(savedInstanceState)从Bundle中恢复数据本质上是Bundle的上层封装，Bundle通过类名去查找数据本质是两个Activity之间的数据传递，上一个被销毁的Activity与新建的这个Activity建立的Bundle数据传递 WorkManager 1.架构上使用JobServiceManager或AlarmService进行调用执行2.数据传递上使用Database进行存储3.执行角度上利用线程池提供具体的执行能力4.编译完manifest会生成contentProvider 和receiver等 1.WorkManger最大的特色， 是不依赖于当前用户进程 当前用户进行killed，任务能够继续执行 保活！ 绝对意义上的保活 2.WorkManager区别于Service提供了一系列的便于我们处理任务的业务 任务链 触发条件执行 WorkManager 1.架构设计 独立于当前APP进程，由第三方进行进行调用 2.业务设计 支持条件约束 支持循环任务 支持任务链 1.底层提供能力的是线程池 2.封装成了一个线性的队列执行 3.当前SDK版本&gt;23的情况下，是由jobservice提供调用支持 4.如果是小于23的情况下是AlarmService提供调用支持！ 从创建角度上来将 1.默认会生成CP 作为组件进行注册 1.1. 构建一个线程池提供具体的执行能力 1.2. 根据版本构建JSM 或AlarmService进行调用执行 通过recevier支持各种约束环节！ 对应数据直接入了数据库 在使用时，取数据库中的数据提取进行处理 1.架构上用JSM 或AlarmService进行调用执行 2.数据传递上用Database进行存储 3.执行角度利用线程池提供具体执行能力 能不能做保活？？ 各大手机厂商，对于ROM的系统，隔一段事件 直接一次性清除掉非系统进程的所有进程 WorkManager这东西用不了！ 有时候会失效，就是因为厂商做了处理 ROM厂商定制 连JMS ALARMSERVICE","categories":[],"tags":[{"name":"Jetpack","slug":"Jetpack","permalink":"http://www.yppcat.top/tags/Jetpack/"}]},{"title":"IO加解密核心与dex文件改造过程分析","slug":"IO加解密核心与dex文件改造过程分析","date":"2022-12-06T12:33:42.000Z","updated":"2022-12-06T12:45:21.299Z","comments":true,"path":"2022/12/06/IO加解密核心与dex文件改造过程分析/","link":"","permalink":"http://www.yppcat.top/2022/12/06/IO加解密核心与dex文件改造过程分析/","excerpt":"","text":"IO及序列化 IO及序列化学习完成后，我能用用他们做什么？数据的加解密文件的读写网络数据的传输 加解密的核心原理 加密原理其实很简单，通俗的说就是打乱所加密文件的内容，举个简单例子：你的桌面图标是不是可以按顺序排列，按时间排列，按大小排列，按内容排列？对的就是这个原理 加密就是打乱信息内容，比如把第一个字放在最后，在吧最后一个字放在前面，按照一定的算法，给一个自己编写的函数，比如递归加密，异或加密等等，解密的时候倒过来解密，异或加密，倒过来解密就是先或在异。 有的加密，把内容打乱后在进行2次整体加密。。完了后在加…… 其实不用加密软软件：我根据加密的原理自己手动加密，一个简单的方法。。你把文件后缀名改掉，比如JPG，改成CHM,log.WIN等等。。个人倾向改成系统问价后缀，然后把改了的文件在压缩，，压缩后在吧压缩文件后缀RAR在改掉、、，，恶心吧。。多改几次。。别人怎么能打开？当然你的指导顺序在改回来。。一般我是最后改成INF或者COM系统后缀放在C盘的系统问文件夹下面。。。一般别人也不会动、。 数字签名-哈希散列 MD5算法:MD5 用的是 哈希函数，它的典型应用是对一段信息产生 信息摘要，以 防止被篡改。严格来说，MD5 不是一种 加密算法 而是 摘要算法。无论是多长的输入，MD5 都会输出长度为 128bits 的一个串 (通常用 16 进制 表示为 32 个字符)。。对称加密和非对称加密加密算法分 对称加密 和 非对称加密，其中对称加密算法的加密与解密 密钥相同，非对称加密算法的加密密钥与解密 密钥不同，此外，还有一类 不需要密钥 的 散列算法。 SHA1算法：HA1 是和 MD5 一样流行的 消息摘要算法，然而 SHA1 比 MD5 的 安全性更强。对于长度小于 2 ^ 64 位的消息，SHA1 会产生一个 160 位的 消息摘要。基于 MD5、SHA1 的信息摘要特性以及 不可逆 (一般而言)，可以被应用在检查 文件完整性 以及 数字签名 等场景。 对称加密与非对称加密 AES算法:AES 加密算法是密码学中的 高级加密标准，该加密算法采用 对称分组密码体制，密钥长度的最少支持为 128 位、 192 位、256 位，分组长度 128 位，算法应易于各种硬件和软件实现。这种加密算法是美国联邦政府采用的 区块加密标准。 RSA算法：RSA 加密算法是目前最有影响力的 公钥加密算法，并且被普遍认为是目前 最优秀的公钥方案 之一。RSA 是第一个能同时用于 加密 和 数字签名 的算法，它能够 抵抗 到目前为止已知的 所有密码攻击，已被 ISO 推荐为公钥数据加密标准。 ECC算法：ECC 也是一种 非对称加密算法，主要优势是在某些情况下，它比其他的方法使用 更小的密钥，比如 RSA 加密算法，提供 相当的或更高等级 的安全级别。不过一个缺点是 加密和解密操作 的实现比其他机制 时间长 (相比 RSA 算法，该算法对 CPU 消耗严重)。。 各算法比较 散列 对称加密算法 非对称算法 大厂中加密思想：算法自定义，数学与性能的考虑，CPU利用与汇编底层的融合 APK反编译原理及实战 加固的总体思想 一个程序员的故事：辛辛苦苦找到一个对象，婚后家里主权为大，老婆管钱，导致这程序员木有经费去做一些爱做的事情。然而这个程序员很努力，平时除了上班，还能够做点外包，赚点外快。 所以他就想到了把工资卡上交，而把赚到的外快放到了自己的小金库。从此过上了性福生活。结果被你反手一掏，小金库没了，从此欲哭无泪。钱 = 代码金库 = 编译过程反手一套 = 破解过程 加固基本原理 Dex文件 是什么？ 加固的目的是保护dex，直接而言就是对dex文件进 行操作，对dex文件动刀子，必须知道dex文件是什 么，能否直接动刀子。什么是源dex？什么是壳dex？ Apk打包 流程 加壳是在原来apk的基础上加一层保护壳，dex文件 修改了就需要重新打包，否则apk安装不了。这就需 要我们详细学习apk如何打包的， Dex文件加 载流程 加壳后的文件是不能直接用的，dex文件是加密的， 所以我们需要对他进行解密，解密后的dex文件如何 加载？ APK加载流程 加壳步骤 1、制作原始项目的apk，这里称作original.apk；2、制作一个壳项目（具体功能见ps），编译通过后得到它的classes.dex文件，这里称作shell.dex，而壳项目的apk称作shell.apk（需要签名）；3、制作一个加壳工具（java工程就可以），按照以下流程工作：1）读取original.apk的byte流，并加密；2）读取shell.dex的byte流；3）new一个新的byte数组，长度为1）和2）的长度之和+4，因为我们要在shell.dex中保存original.apk的长度；4）在new byte数组中写入2），写入1），写入1）的长度；5）根据dex文件的结构，修改checksum文件头、Signature文件头和file_size文件头，最终生成一个新的classes.dex；4、替换掉2中的shell.apk中的classes.dex，并使用工具重新签名；5、生成的新签名apk就是我们加壳过的apk了。 脱壳流程","categories":[],"tags":[{"name":"IO","slug":"IO","permalink":"http://www.yppcat.top/tags/IO/"}]},{"title":"序列化","slug":"序列化","date":"2022-12-06T02:50:54.000Z","updated":"2022-12-06T03:11:25.646Z","comments":true,"path":"2022/12/06/序列化/","link":"","permalink":"http://www.yppcat.top/2022/12/06/序列化/","excerpt":"","text":"序列化定义以及相关概念 由于在系统底层，数据的传输形式是简单的字节序列形式传递，即在底层，系统不认识对象，只认识字节序列，而为了达到进程通讯的目的，需要先将数据序列化，而序列化就是将对象转化字节序列的过程。相反地，当字节序列被运到相应的进程的时候，进程为了识别这些数据，就要将其反序列化，即把字节序列转化为对象 无论是在进程间通信、本地数据存储又或者是网络数据传输都离不开序列化的支持。而针对不同场景选择合适的序列化方案对于应用的性能有着极大的影响。 从广义上讲，数据序列化就是将数据结构或者是对象转换成我们可以存储或者传输的数据格式的一个过程，在序列化的过程中，数据结构或者对象将其状态信息写入到临时或者持久性的存储区中，而在对应的反序列化过程中，则可以说是生成的数据被还原成数据结构或对象的过程。 序列化本质上其实就是将数据结构或对象转换成二进制串的过程。反序列化本质是将在序列化过程中所生成的二进制串转换成数据结构或者对象的过程 数据结构、对象与二进制串 不同的计算机语言中，数据结构，对象以及二进制串的表示方式并不相同。 数据结构和对象：对于类似 Java 这种完全面向对象的语言，工程师所操作的一切都是对象（Object），来自于类的实例化。在 Java 语言中最接近数据结构的概念，就是 POJO（Plain Old JavaObject）或者 Javabean－－那些只有 setter/getter 方法的类。而在 C 二进制串：序列化所生成的二进制串指的是存储在内存中的一块数据。C 语言的字符串可以直接被传输层使用，因为其本质上就是以’0’结尾的存储在内存中的二进制串。在 Java 语言里面，二进制串的概念容易和String 混淆。实际上String 是 Java 的一等公民，是一种特殊对象（Object）。对于跨语言间的通讯，序列化后的数据当然不能是某种语言的特殊数据类型。二进制串在 Java 里面所指的是 byte[]，byte 是 Java 的 8 中原生数据类型之一（Primitive data types）。 序列化协议特性 通用性技术层面，序列化协议是否支持跨平台、跨语言。如果不支持，在技术层面上的通用性就大大降低了。流行程度，序列化和反序列化需要多方参与，很少人使用的协议往往意味着昂贵的学习成本；另一方面，流行度低的协议，往往缺乏稳定而成熟的跨语言、跨平台的公共包。 强健性 / 鲁棒性成熟度不够语言 / 平台的不公平性 可调试性 / 可读性支持不到位访问限制 性能性能包括两个方面，时间复杂度和空间复杂度。空间开销（Verbosity）， 序列化需要在原有的数据上加上描述字段，以为反序列化解析之用。如果序列化过程引入的额外开销过高，可能会导致过大的网络，磁盘等各方面的压力。对于海量分布式存储系统，数据量往往以 TB 为单位，巨大的的额外空间开销意味着高昂的成本。时间开销（Complexity），复杂的序列化协议会导致较长的解析时间，这可能会使得序列化和反序列化阶段成为整个系统的瓶颈。 可扩展性 / 兼容性移动互联时代，业务系统需求的更新周期变得更快，新的需求不断涌现，而老的系统还是需要继续维护。如果序列化协议具有良好的可扩展性，支持自动增加新的业务字段，而不影响老的服务，这将大大提供系统的灵活度。安全性 / 访问限制在序列化选型的过程中，安全性的考虑往往发生在跨局域网访问的场景。当通讯发生在公司之间或者跨机房的时候，出于安全的考虑，对于跨局域网的访问往往被限制为基于 HTTP/HTTPS 的 80 和 443 端口。如果使用的序列化协议没有兼容而成熟的 HTTP 传输层框架支持，可能会导致以下三种结果之一：因为访问限制而降低服务可用性；被迫重新实现安全协议而导致实施成本大大提高；开放更多的防火墙端口和协议访问，而牺牲安全性注意点：Android的Parcelable也有安全漏洞 广义上的序列化和反序列化协议 XML&amp;SOAPXML 是一种常用的序列化和反序列化协议，具有跨机器，跨语言等优点，SOAP（Simple ObjectAccess protocol） 是一种被广泛应用的，基于 XML 为序列化和反序列化协议的结构化消息传递协议JSON 起源于弱类型语言 Javascript， 它的产生来自于一种称之为”Associative array”的概念，其本质是就是采用”Attribute－value”的方式来描述对象。实际上在 Javascript 和 PHP 等弱类型语言中，类的描述方式就是 Associative array。JSON 的如下优点，使得它快速成为最广泛使用的序列化协议之一。这种 Associative array 格式非常符合工程师对对象的理解。它保持了 XML 的人眼可读（Human-readable）的优点。相对于 XML 而言，序列化后的数据更加简洁。 来自于的以下链接的研究表明：XML 所产生序列化之后文件的大小接近 JSON 的两倍它具备 Javascript 的先天性支持，所以被广泛应用于 Web browser 的应用常景中，是 Ajax 的事实标准协议。与 XML 相比，其协议比较简单，解析速度比较快。松散的 Associative array 使得其具有良好的可扩展性和兼容性ProtobufProtobuf 具备了优秀的序列化协议的所需的众多典型特征。标准的 IDL 和 IDL 编译器，这使得其对工程师非常友好。序列化数据非常简洁，紧凑，与 XML 相比，其序列化之后的数据量约为 1/3 到 1/10。解析速度非常快，比对应的 XML 快约 20-100 倍。提供了非常友好的动态库，使用非常简介，反序列化只需要一行代码。 Android人员如何去选择序列化方案 Serializable接口Serializable 用来标识当前类可以被 ObjectOutputStream 序列化，以及被 ObjectInputStream 反序列化。 Parcelable接口Parcelable是Android为我们提供的序列化的接口,Parcelable相对于Serializable的使用相对复杂一些,但Parcelable的效率相对Serializable也高很多,这一直是Google工程师引以为傲的,有时间的可以看一下Parcelable和Serializable的效率对比 Parcelable vs Serializable 号称快10倍的效率 Serialzable接口 JAVA提供，依赖于ObjectOutputStream/ObjectInputStream进行操作 序列化经常会遇到的问题 1.什么是serialVersionUID，如果不定义这个，会发生什么？ 2.假设你有一个类，他序列化并存储在持久性中，然后修改了该类以添加新字段。如果对已序列化的对象进行反序列化会发生什么情况？ serialVersionUID的作用serialVersionUID 用来表明类的不同版本间的兼容性。如果你修改了此类, 要修改此值。否则以前用老版本的类序列化的类恢复时会报错: InvalidClassException 为了在反序列化时，确保类版本的兼容性，最好在每个要序列化的类中加入 private static final long serialVersionUID这个属性，具体数值自己定义。这样，即使某个类在与之对应的对象 已经序列化出去后做了修改，该对象依然可以被正确反序列化。否则，如果不显式定义该属性，这个属性值将由JVM根据类的相关信息计算，而修改后的类的计算 结果与修改前的类的计算结果往往不同，从而造成对象的反序列化因为类版本不兼容而失败。不显式定义这个属性值的另一个坏处是，不利于程序在不同的JVM之间的移植。因为不同的编译器实现该属性值的计算策略可能不同，从而造成虽然类没有改变，但是因为JVM不同，出现因类版本不兼容而无法正确反序列化的现象出现 因此 JVM 规范强烈 建议我们手动声明一个版本号，这个数字可以是随机的，只要固定不变就可以。同时最好是 private 和 final 的，尽量保证不变。 3.序列化时，你希望某些成员不要序列化？你如何实现它？ 有时候也会变着形式去问，比如问什么是瞬态trasient 变量？瞬态变量和静态变量会不会得到序列化等，所以，如果你不希望字段是对象状态的一部分，然后声明他静态或者瞬态，根据你的需要，他不会被包含在序列化过程之内 4.为什么序列化一定需要一个无参构造？ 在序列化的过程中，他将构造函数的信息数据存储在ObjectStreamClass的类中，反序列化是提取到当前数据，拿到cons中的构造属性进行反射调用无参构造 Parcelable Parcelable是因为，在android体系当中，为了应用层面使用便捷，在数据的传输过程中，能够直接应用JAVABean进行数据处理，但是传统的serializable依赖于IO，对于android特定场景跨进程间通信来说效率太慢，大量的应用IO会导致各种资源损耗，所以android另外开辟一套序列化方案，本质上也还是对于JAVA类对象的序列化与反序列化，但是其核心目的是为了解决跨进程间通信问题，而不是为了网络数据传输与持久化保存数据，所以他依托于Binder机制，去掉IO，将数据的传输层应用在内存角度。导致其速度比serializable快 Parcelable与Serializable对比 类型 Serializable Parcelable 操作方案 通过IO操作，速度慢 直接在内存操作，效率高 数据大小 大小不受限制 因为Binder，一般不超过1M 其他 大量反射，内存碎片多 面试相关 1.反序列化后的对象，需要调用构造函数重新构造吗？ 反序列化时，类的构造函数不会被执行 2.序列前的对象与序列化后的对象是什么关系？==？equal?浅复制？深复制？ 深复制 3.SerialVersionID的作用是什么？ 4.Android中Intent/Bundle的通信原理及大小限制 Bundle内部是由ArrayMap实现的，ArrayMap的内部实现是两个数组，一个int数组是存储对象数据对应下标，一个对象数组保存key和value，内部使用二分法对key进行排序，所以在添加、删除、查找数据的时候，都会使用二分法查找，只适合于小数据量操作，如果在数据量比较大的情况下，那么它的性能将退化。而HashMap内部则是数组+链表结构，所以在数据量较少的时候，HashMap的Entry Array比ArrayMap占用更多的内存。因为使用Bundle的场景大多数为小数据量，我没见过在两个Activity之间传递10个以上数据的场景，所以相比之下，在这种情况下使用ArrayMap保存数据，在操作速度和内存占用上都具有优势，因此使用Bundle来传递数据，可以保证更快的速度和更少的内存占用。另外一个原因，则是在Android中如果使用Intent来携带数据的话，需要数据是基本类型或者是可序列化类型，HashMap使用Serializable进行序列化，而Bundle则是使用Parcelable进行序列化。而在Android平台中，更推荐使用Parcelable实现序列化，虽然写法复杂，但是开销更小，所以为了更加快速的进行数据的序列化和反序列化，系统封装了Bundle类，方便我们进行数据的传输。 Intent 中的 Bundle 是使用 Binder 机制进行数据传送的。能使用的 Binder 的缓冲区是有大小限制的（有些手机是 2 M），而一个进程默认有 16 个 Binder 线程，所以一个线程能占用的缓冲区就更小了（ 有人以前做过测试，大约一个线程可以占用 128 KB）。所以当你看到 The Binder transaction failed because it was too large 这类 TransactionTooLargeException 异常时，你应该知道怎么解决了 5.为何Intent不能直接在组件间传递对象，而要通过序列化 Intent在启动其他组件时，会离开当前应用程序进程，进入ActivityManagerService进程（intent.prepareToLeaveProcess()），这也就意味着，Intent所携带的数据要能够在不同进程间传输。首先我们知道，Android是基于Linux系统，不同进程之间的java对象是无法传输，所以我们此处要对对象进行序列化，从而实现对象在 应用程序进程 和 ActivityManagerService进程 之间传输。而Parcel或者Serializable都可以将对象序列化，其中，Serializable使用方便，但性能不如Parcel容器，后者也是Android系统专门推出的用于进程间通信等的接口 6.序列化与持久化的关系和区别是什么？ 序列化可以将一个复杂的对象转化为一维的数据，而这为持久化提供了很大的方便，因为文件就是一维的，将一维的东西写入文件自然比较方便。 不过持久化是个很宽泛的概念，可以是写入文件，也可以是存入数据库，写入注册表等多种方式。其本意是延长对象或数据的生命周期，让其可以超越程序的生命周期，程序关闭了，甚至服务器关机了，下次运行程序时又可以让对象或数据恢复到原来的状态。 而序列化也不一定是用来持久化的，可以是用来传递使用，如从计算机A传递到计算机B；也可以用来进行深拷贝；总之序列化主要解决从复杂的数据结构转化为一维结构，或者从一维结构从新构建复杂的数据结构 总结 什么是序列化?本质上就是一套固定数据格式的方案Parcelable与serializable本质区别应用角度：Parcelable目的是为了支持跨进程间数据通信Serializable目的是提供对于JAVA对象的序列化支持，他考虑的场景覆盖全面，IO","categories":[],"tags":[{"name":"IO","slug":"IO","permalink":"http://www.yppcat.top/tags/IO/"}]},{"title":"BIO与NIO","slug":"BIO与NIO","date":"2022-12-05T08:33:28.000Z","updated":"2022-12-05T08:53:54.845Z","comments":true,"path":"2022/12/05/BIO与NIO/","link":"","permalink":"http://www.yppcat.top/2022/12/05/BIO与NIO/","excerpt":"","text":"android 人员对于IO的诉求 IO对于系统的影响性能层面基础的单位影响使用率：是指磁盘处理io的时间百分比。过高的使用率(比如超过80%)，通常意味着磁盘io存在性能瓶颈。饱和度：是指磁盘处理io的繁忙程度。过高的饱和度，意味着磁盘存在着严重的性能瓶颈。当饱和度为100%时，磁盘无法接受新的io请求。IOPS：是指每秒的io请求数，适用于大量小文件的情景吞吐量：是指每秒的io请求大小，适用与大文件的情景响应时间：是指io请求从发出到收到响应的时间间隔IO模型对于性能的影响阻塞IO、非阻塞IO、复用IO、信号驱动IO、异步IO android对于IO需要注意的场景1.设备（手机）作为S端2.IO复用可能导致的空指针3.设备数据的传递4.dex加壳与脱壳IO的优化是在解决CPU的瓶颈问题，但是通常在C端喝少会出现，所以在学习IO的角度上来说，我们不会吧重点放在CPU瓶颈的解决，而是会探寻IO本质原理及序列化的应用与Dex文件的加壳脱壳 IO的基本常识-内核空间 在对于IO学习之前， 我们首先需要了解一定的常识，比如内核、JVM、堆区、这些概念是必备的 内核=一套软件，操作系统用于支撑基础使用的功能程序 APP=上层应用–》很多基础功能是需要调用内核去进行完成 数据读写的方案 内核（linux）的IO栈 我们可以吧Linux存储系统的io栈，由上到下分为三个层次，分别是文件系统层、通用块层和设备层。文件系统层，包括虚拟文件系统和其他各种文件系统的具体实现。它为上层的应用程序，提供标准的文件访问接口；对下会通过通用块层，来存储和管理磁盘数据。通用块层，包括块设备io队列和io调度器。它会对文件系统的io请求进行排队，再通过重新排序和请求合并，然后才发送给下一级的设备层。设备层，包括存储设备和相应的驱动程序，负责最终物理设备的io操作。存储系统的io，通常是整个系统中最慢的一环。所以，Linux通过多种缓存机制来优化io效率。为了优化存储系统访问文件的性能，会使用页缓存、索引节点缓存、目录项缓存等多种缓存机制，以及减少对下层块设备的直接调用。为了优化块设备的访问效率，会使用缓冲区，来缓存块设备的数据。 内核空间对于IO的操作方案 页：4K数据为一页， 一页数据是IO操作的基本单位 空间局部性原理：在常规操作下， 如果数据量较大的情况下可能会出现预占位4~16K的情况 JAVA 对于Basic IO 的支撑 Basic IO : API提供的基础功能分析及相关应用场景与特点 MappedByteBuffer缓冲区 java io操作中通常采用BufferedReader，BufferedInputStream等带缓冲的IO类处理大文件，不过java nio中引入了一种基于MappedByteBuffer操作大文件的方式，其读写性能极高 FileChannel提供了map方法把文件映射到虚拟内存，通常情况可以映射整个文件，如果文件比较大，可以进行分段映射。 MappedByteBuffer使用虚拟内存，因此分配(map)的内存大小不受JVM的-Xmx参数限制，但是也是有大小限制的。如果当文件超出1.5G限制时，可以通过position参数重新map文件后面的内容。MappedByteBuffer在处理大文件时的确性能很高，但也存在一些问题，如内存占用、文件关闭不确定，被其打开的文件只有在垃圾回收的才会被关闭，而且这个时间点是不确定的。javadoc中也提到：A mapped byte buffer and the file mapping that it represents remain valid until the buffer itself is garbage-collected.* 性能分析 从代码层面上看，从硬盘上将文件读入内存，都要经过文件系统进行数据拷贝，并且数据拷贝操作是由文件系统和硬件驱动实现的，理论上来说，拷贝数据的效率是一样的。但是通过内存映射的方法访问硬盘上的文件，效率要比read和write系统调用高，这是为什么？ read()是系统调用，首先将文件从硬盘拷贝到内核空间的一个缓冲区，再将这些数据拷贝到用户空间，实际上进行了两次数据拷贝；map()也是系统调用，但没有进行数据拷贝，当缺页中断发生时，直接将文件从硬盘拷贝到用户空间，只进行了一次数据拷贝。所以，采用内存映射的读写效率要比传统的read/write性能高。 IO模型概念 IO分两阶段进行：1.数据准备阶段2.内核空间复制回用户进程缓冲区阶段 所谓模型就是在这两阶段当中的实现方案 POSIX POSIX(可移植操作系统接口)把同步IO操作定义为导致进程阻塞直到IO完成的操作，反之则是异步IO 阻塞IO模型：使用recv的默认参数一直等数据直到拷贝到用户空间，这段时间内进程始终阻塞。A同学用杯子装水，打开水龙头装满水然后离开。这一过程就可以看成是使用了阻塞IO模型，因为如果水龙头没有水，他也要等到有水并装满杯子才能离开去做别的事情。很显然，这种IO模型是同步的。 非阻塞IO模型：改变flags，让recv不管有没有获取到数据都返回，如果没有数据那么一段时间后再调用recv看看，如此循环。B同学也用杯子装水，打开水龙头后发现没有水，它离开了，过一会他又拿着杯子来看看……在中间离开的这些时间里，B同学离开了装水现场(回到用户进程空间)，可以做他自己的事情。这就是非阻塞IO模型。但是它只有是检查无数据的时候是非阻塞的，在数据到达的时候依然要等待复制数据到用户空间(等着水将水杯装满)，因此它还是同步IO。 传统阻塞IO 非阻塞IO IO复用模型 这里在调用recv前先调用select或者poll，这2个系统调用都可以在内核准备好数据(网络数据到达内核)时告知用户进程，这个时候再调用recv一定是有数据的。因此这一过程中它是阻塞于select或poll，而没有阻塞于recv，有人将非阻塞IO定义成在读写操作时没有阻塞于系统调用的IO操作(不包括数据从内核复制到用户空间时的阻塞，因为这相对于网络IO来说确实很短暂)，如果按这样理解，这种IO模型也能称之为非阻塞IO模型，但是按POSIX来看，它也是同步IO，那么也和楼上一样称之为同步非阻塞IO吧。 这种IO模型比较特别，分个段。因为它能同时监听多个文件描述符(fd)。这个时候C同学来装水，发现有一排水龙头，舍管阿姨告诉他这些水龙头都还没有水，等有水了告诉他。于是等啊等(select调用中)，过了一会阿姨告诉他有水了，但不知道是哪个水龙头有水，自己看吧。于是C同学一个个打开，往杯子里装水(recv)。这里再顺便说说鼎鼎大名的epoll(高性能的代名词啊)，epoll也属于IO复用模型，主要区别在于舍管阿姨会告诉C同学哪几个水龙头有水了，不需要一个个打开看(当然还有其它区别)。 信号驱动IO模型 通过调用sigaction注册信号函数，等内核数据准备好的时候系统中断当前程序，执行信号函数(在这里面调用recv)。D同学让舍管阿姨等有水的时候通知他(注册信号函数)，没多久D同学得知有水了，跑去装水。是不是很像异步IO？很遗憾，它还是同步IO(省不了装水的时间啊)。 异步IO模型 调用aio_read，让内核等数据准备好，并且复制到用户进程空间后执行事先指定好的函数。E同学让舍管阿姨将杯子装满水后通知他。整个过程E同学都可以做别的事情(没有recv)，这才是真正的异步IO。 五种IO模型不同 IO的五个模型故事解释 OKIO对于JAVAIO的优化 官方的解释是这样的：Okio是一个库，是对java.io和java.nio的补充，通过这个库，我们可以更简单的使用和存储我们的数据。 Okio提供了两种新的类型，这两种类型有很多新的功能，并且使用比较简单。这两中类型分别是：ByteString和Buffer。 ByteString是不可变的字节序列（请参考String，String是不可变的字符串）。String是基本的字符数据，ByteString相当于是String的兄弟，ByteString让处理二进制数据变得简单了。这个类是符合人们的编程习惯的，它知道怎么使用比如hax，base64,UTF-8等编码格式将它自己编码或解码。 Buffer是一个可变的字符序列。你不需要提前设置它的大小，它在写入数据的时候会将数据放在最后，而在读取的时候会在最前面开始读取（这很类似与队列），你也不需要关心它的位置，限制，容量等等。 OKIO 采取的方案 OKIO在读取数据时，先从Buffer对象中获取了一个Segment，然后向Segment中读取数据，每个Segment最多可以存入8K数据。这里需要提一下Buffer中数据的数据结构，Buffer中的数据是存在于一个双向链表中，链表中的每个节点都是一个Segment OKIO 解决了什么 不管是读入还是写出，缓冲区的存在必然涉及copy的过程，而如果涉及双流操作，比如从一个输入流读入，再写入到一个输出流，那么这种情况下，在缓冲存在的情况下，数据走向是：-&gt; 从输入流读出到缓冲区-&gt; 从输入流缓冲区copy到 b[]-&gt; 将 b[] copy 到输出流缓冲区-&gt; 输出流缓冲区读出数据到输出流 OK是将两个缓冲合并成一份 Okio核心竞争力为，增强了流于流之间的互动，使得当数据从一个缓冲区移动到另一个缓冲区时，可以不经过copy能达到： 以Segment作为存储结构，真实数据以类型为byte[]的成员变量data存在，并用其它变量标记数据状态，在需要时，如果可以，移动Segment引用，而非copy data数据Segment在Segment线程池中以单链表存在以便复用，在Buffer中以双向链表存在存储数据，head指向头部，是最老的数据Segment能通过slipt()进行分割，可实现数据共享，能通过compact()进行合并。由Buffer来进行数据调度，基本遵守 “大块数据移动引用，小块数据进行copy” 的思想Source 对应输入流，Sink 对应输出流TimeOut 以达到在期望时间内完成IO操作的目的，同步超时在每次IO操作中检查耗时，异步超时开启另一线程间隔时间检查耗时 OK核心是解决双流操作的问题","categories":[],"tags":[{"name":"IO","slug":"IO","permalink":"http://www.yppcat.top/tags/IO/"}]},{"title":"AQS","slug":"AQS","date":"2022-12-05T00:05:16.000Z","updated":"2022-12-05T00:16:55.258Z","comments":true,"path":"2022/12/05/AQS/","link":"","permalink":"http://www.yppcat.top/2022/12/05/AQS/","excerpt":"","text":"什么是AQS？ AQS，全程AbstractQueuedSynchronizer，位于java.util.concurrent.locks包下。 是JDK1.5提供的一套用于实现阻塞锁和一系列依赖FIFO等待队列的同步器(First Input First Output先进先出)的框架实现。是除了java自带的synchronized 关键字之外的锁机制。 可以将AQS作为一个队列来理解。 我们常用的ReentrantLock、Semaphore、CountDownLatch、CyclicBarrier等并发类均是基于AQS来实现的。具体用法是通过继承AQS，并实现其模板方法，来达到同步状态的管理。 AQS的功能在使用中可以分为两种:独占锁和共享锁独占锁：每次只能有一个线程持有锁。eg: ReentrantLock就是独占锁共享锁：允许多个线程同时获得锁，并发访问共享资源。eg: ReentrantReadWriteLock中的读 AQS核心思想 AQS核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。 AQS使用方式 AQS设计是基于模板方法模式的，一般的使用方式是：使用者继承AbstractQueuedSynchronizer并重写指定的方法。（这些重写方法很简单，无非是对于共享资源state的获取和释放） 将AQS组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。 AQS定义的这些可重写的方法：protected boolean tryAcquire(int arg): 独占式获取同步状态，试着获取，成功返回true，反之为falseprotected boolean tryRelease(int arg) ：独占式释放同步状态，等待中的其他线程此时将有机会获取到同步状态；protected int tryAcquireShared(int arg) ：共享式获取同步状态，返回值大于等于0，代表获取成功；反之获取失败；protected boolean tryReleaseShared(int arg) ：共享式释放同步状态，成功为true，失败为falseprotected boolean isHeldExclusively()： 是否在独占模式下被线程占用。 AQS的模板方法 独占锁：void acquire(int arg);// 独占式获取同步状态，如果获取失败则插入同步队列进行等待；void acquireInterruptibly(int arg);// 与acquire方法相同，但在同步队列中进行等待的时候可以检测中断；boolean tryAcquireNanos(int arg, long nanosTimeout);// 在acquireInterruptibly基础上增加了超时等待功能，在超时时间内没有获得同步状态返回false;boolean release(int arg);// 释放同步状态，该方法会唤醒在同步队列中的下一个节点 共享锁：void acquireShared(int arg);// 共享式获取同步状态，与独占式的区别在于同一时刻有多个线程获取同步状态；void acquireSharedInterruptibly(int arg);// 在acquireShared方法基础上增加了能响应中断的功能；boolean tryAcquireSharedNanos(int arg, long nanosTimeout);// 在acquireSharedInterruptibly基础上增加了超时等待的功能；boolean releaseShared(int arg);// 共享式释放同步状态 自定义，使用总结 首先，我们需要去继承AbstractQueuedSynchronizer这个类，然后我们根据我们的需求去重写相应的方法，比如要实现一个独占锁，那就去重写tryAcquire，tryRelease方法，要实现共享锁，就去重写tryAcquireShared，tryReleaseShared； 然后，在我们的组件中调用AQS中的模板方法就可以了，而这些模板方法是会调用到我们之前重写的那些方法的。也就是说，我们只需要很小的工作量就可以实现自己的同步组件，重写的那些方法，仅仅是一些简单的对于共享资源state的获取和释放操作，至于像是获取资源失败，线程需要阻塞之类的操作，自然是AQS帮我们完成了 AQS源码分析 AQS的基本实现： AQS维护一个共享资源state，通过内置的FIFO来完成获取资源线程的排队工作。（这个内置的同步队列称为”CLH”队列）。该队列由一个一个的Node结点组成，每个Node结点维护一个prev引用和next引用，分别指向自己的前驱和后继结点。AQS维护两个指针，分别指向队列头部head和尾部tail。 当线程获取资源失败（比如tryAcquire时试图设置state状态失败），会被构造成一个结点加入CLH队列中，同时当前线程会被阻塞在队列中（通过LockSupport.park实现，其实是等待态）。当持有同步状态的线程释放同步状态时，会唤醒后继结点，然后此结点线程继续加入到对同步状态的争夺中。 ReentrantLock与AQS ReentrantLock加锁流程 条件变量实现原理 每个条件变量其实就对应着一个等待队列，其实现类是 ConditionObject await 流程开始 Thread-0 持有锁，调用 await，进入 ConditionObject 的 addConditionWaiter 流程创建新的 Node 状态为 -2（Node.CONDITION），关联 Thread-0，加入等待队列尾部 同步方案对比 wait/notify：依托于synchronized，基于VM底层对于阻塞的实现，使用waitSet作为等待机制，set结构的问题，要么是随机一个（set的提取算法），要么是全部提出来唤醒 await/signal：依赖于ReentrantLock条件变量，已经用条件变量与AQS体系作为唤醒机制，本质上底层是park/unpark实现阻塞 park/unpark:以thread为操作对象,操作更精准，可以准确地唤醒某一个线程（notify随机唤醒一个线程，notifyAll唤醒所有等待的线程），增加了灵活性。 其实park/unpark的设计原理核心是“许可”：park是等待一个许可，unpark是为某线程提供一个许可 但是这个“许可”是不能叠加的，“许可”是一次性的。比如线程B连续调用了三次unpark函数，当线程A调用park函数就使用掉这个“许可”，如果线程A再次调用park，则进入等待状态。 ReentrantReadWriteLock读写锁 读写锁指一个资源能够被多个读线程访问，或者被一个写线程访问，但是不能同时存在读写线程ReentrantReadWriteLock中有两个静态内部类：ReadLock读锁和WriteLock写锁，这两个锁实现了Lock接口ReentrantReadWriteLock支持可重入，同步功能依赖自定义同步器（AbstractQueuedSynchronizer）实现，读写状态就是其同步器的同步状态 写锁的获取和释放：写锁WriteLock是支持重进入的排他锁。如果当前线程已经获取了写锁，则增加写状态。如果当前线程在获取读锁时，读锁已经被获取或者该线程不是已获取写锁的线程，则当前线程进入等待状态。读写锁确保写锁的操作对读锁可见。写锁释放每次减少写状态，当前写状态为0时表示写锁已背释放。 读锁的获取与释放：读锁ReadLock是支持重进入的共享锁（共享锁为shared节点，对于shared节点会进行一连串的唤醒，知道遇到一个读节点），它能够被多个线程同时获取，在没有其他写线程访问（写状态为0）时，读锁总是能够被成功地获取，而所做的也只是增加读状态（线程安全）。如果当前线程已经获取了读锁，则增加读状态。如果当前线程在获取读锁时，写锁已经被获取，则进入等待状态。 CyclicBarrier和CountDownLatch CountDownLatch：一个或者多个线程，等待其他多个线程完成某件事情之后才能执行； CyclicBarrier：多个线程互相等待，直到到达同一个同步点，再继续一起执行。而且可以重用 CountDownLatch是计数器，线程完成一个记录一个，只不过计数不是递增而是递减，而CyclicBarrier更像是一个阀门，需要所有线程都到达，阀门才能打开，然后继续执行。","categories":[],"tags":[{"name":"JUC","slug":"JUC","permalink":"http://www.yppcat.top/tags/JUC/"}]},{"title":"线程池","slug":"线程池","date":"2022-12-03T11:49:42.000Z","updated":"2022-12-03T12:03:06.462Z","comments":true,"path":"2022/12/03/线程池/","link":"","permalink":"http://www.yppcat.top/2022/12/03/线程池/","excerpt":"","text":"异步模式之工作线程 让有限的工作线程轮流异步处理无限多的任务，也可以将其归类为分工模式，他的典型实现就是线程池，也体现了经典设计模式中的享元模式 例如,海底捞的服务员（线程），轮流处理每位顾客的点餐（任务），如果每位顾客都配一个专属服务员，则成本太过高昂 注意：不同任务类型应该使用不同的线程池，这样能够避免饥饿现象，且效率上得到合理分配 线程饥饿现象： 本质上是在出现多任务混合在同一个池中，如果出现相互影响的状况出现类似死锁的问题 享元设计模式 本质：运用内存共享的原理，去有效支撑大量的细颗粒度的对象 享元工厂：一个享元工厂，用来创建并管理对象，他主要是用来确保合理地共享对象，当用户请求一个对象是，由工厂提供一个已创建的对象示例或者创建一个 享元对象：一个重复的对象 使用场景：如果一个程序对于某个对象进行大量应用，且使用生命周期短，可以考虑采取享元模式进行复用 线程数量与核心数 处理器核数： 线程核心数是一种执行资源，资源数量就是核的个数，应用程序的线程数就是服务请求数，而操作系统的作用如何调配有限的资源来服务更多的请求，这就是进程调度的概念。一般情况下，服务其你去线程会“相对公平”的分配到核上运行，并且在时间片上轮流使用，这就是所谓的并发执行。 比如系统有4个核，如果3个线程，分配到3个核上8个线程，每个核分配两个线程执行10个线程，有些核跑3个有些跑2个 所以，并非线程数量越大，速度越快，线程数量太过于庞大会导致各种内存问题，因为一个线程的开辟还会涉及到线程上下文的应用 创建多少线程合适？ CPU密集型运算： 通常采用CPU核数 + 1 能够实现最优的CPU利用率，+1是保证当线程由于页缺失故障（操作系统）或其他原因导致暂停时，额外的这个线程就能顶上去，保证CPU始终周期不被浪费 I/O密集型运算： CPU不总是处于繁忙状态，例如，当你执行业务计算时，这时候会使用CPU资源，但当你执行IO操作、或者远程的RPC调用时，包括进行数据库操作等，这个时候CPU会闲下来，你可以利用多线程提高他的利用率 经验公式如下：线程数 = 核数 期望CPU利用率 总时间（CPU计算时间+等待时间） / CPU计算时间 例如：4核CPU，计算时间是50%，其他等待时间是50%，期望CPU被100%利用，套用公式 4 100% 100% / 50% = 8 自定义线程池 由主线程往一个队列中去添加任务，由线程池控制线程去进行消费 JDK中提供的线程池 ThreadPoolExecutor 状态模型： 构造方法 工作模式 JDK中的拒绝策略 ThreadPoolExecutor自己已经提供了四个拒绝策略，分别是 CallerRunsPolicy：在任务被拒绝添加后，会调用当前线程池的所在的线程去执行被拒绝的任务。这个策略的缺点就是可能会阻塞主线程。 AbortPolicy：默认的拒绝策略就是AbortPolicy。直接抛出异常。抛出个RejectedExecutionException异常，也不执行这个任务了 DiscardPolicy：这个东西什么都没干。 DiscardOldestPolicy：当任务呗拒绝添加时，会抛弃任务队列中最旧的任务也就是最先加入队列的，再把这个新任务添加进去。 变量压缩合并的好处 合并算法 目的：将另个整数值打包到一个整数值下 步骤： 1.拆分短位与长位数值 短位=常量（状态） 长位 = 动态值（长度） 2.打包算法 : 长位 &amp; ~ mask | 短位 &amp; mask mask为分界位，如 一个整数值 短位占用3位，则长位占用29位，mask作用是用来对于短位数值进行换算，所有，如果短位需要占用三位则需要用111&lt;&lt;29位来占据前三位作为等值 ThreadPoolExecutor与当前自定义的区别 1.救急线程的应用 提升性能 2.状态设置 对于线程池的管理 3.原子合并 利用位运算，进行CAS的优化 4.工厂模式的应用 Timer缺点 Timer的优点在于简单易用，但是由于所有任务都是同一线程来调度执行，所有任务是串行，如果前面任务有延迟，会影响后面任务执行 解决办法： ScheduledExecutorService 线程池的调度 fork/join线程池 fork/join是JDK 1.7后加入的心得线程池实现，他主要体现是分治思想，适用于能够进行任务拆分的CPU密集型运算 他是为了处理大数据诞生的 所谓任务拆分，是将一个大任务拆分为算法上相同的小任务，直至不能拆分可以直接求解。跟递归相关的一些计算，如归并排序、斐波拉切数列，都可以进行分治完成 Fork/Join在分治的基础上加入了多线程，可以把每个任务的分解和合并交给不同的线程来完成，进一步提升运算效率 Fork/Join 默认会创建于CPU核心数大小相同的线程池 最常见业务，对于文件夹的操作","categories":[],"tags":[{"name":"JUC","slug":"JUC","permalink":"http://www.yppcat.top/tags/JUC/"}]},{"title":"CAS与原子变量","slug":"CAS与原子变量","date":"2022-11-27T13:08:34.000Z","updated":"2022-11-28T01:54:19.332Z","comments":true,"path":"2022/11/27/CAS与原子变量/","link":"","permalink":"http://www.yppcat.top/2022/11/27/CAS与原子变量/","excerpt":"","text":"为什么无锁状态下的运行效率会高？ 单纯的CAS理论： 单纯的CAS理论只是为了完成一次比较确认值的同步与代码块的同步并没有关系 CAS理论应用下的锁实现原理：利用volatile变量与CAS理论保证在一定时间段内变量结果的一致性同步对于线程进行阻塞 CAS无锁状态下与synchronize有锁状态下的本质区别无锁情况下，即使重试失败，线程始终在高速运行，没有停歇，而synchronized会让线程在没有获得锁的时候，发生上下文切换，进入阻塞比喻：高速上飙车，当前自己开200码，正常的高速运行，但是一旦发生上下文切换，需要减速停车，换路，在加速，代价相对高昂无锁状态下，因为线程需要保持运行，则需要额外CPU的支持，CPU在这里就是高速公路，没路我们走不下去，一开始没有加锁，不会有阻塞，但是没有时间片，会导致上下文切换，所以CAS需要有多核CPU对于其进行支撑，单核体系下效率不一定 CAS效率分析 结合CAS与volatile实现无锁并发情况的适用场景： 多核CPU场景下，且线程数少CAS基于乐观锁思想，最乐观结果，不怕别的线程来修改共享变量，改了也没事，我在重试synchronize基于悲观锁思想：最悲观结果，得放着其他线程来修改共享变量，我上锁，你们都别改，我改了解开你们才有机会 CAS体现的是无锁并发，无阻塞并发 因为没有synchronized，线程不会陷入阻塞，这是效率提升的因素之一 如果竞争几率，重试必然发生频繁，效率会下降 最好结果为线程数不超过CPU核心数 线程的上下文切换 本质：CPU切换前把当前任务的状态保存下来，以便下次切换回这个任务时可以再次加载这个任务的状态，然后加载下一任务的状态并执行。任务的状态保存及再加载, 这段过程就叫做上下文切换。 每个线程都有一个程序计数器（记录要执行的下一条指令），一组寄存器（保存当前线程的工作变量），堆栈（记录执行历史，其中每一帧保存了一个已经调用但未返回的过程）。 寄存器 是 CPU 内部的数量较少但是速度很快的内存（与之对应的是 CPU 外部相对较慢的 RAM 主内存）。寄存器通过对常用值（通常是运算的中间值）的快速访问来提高计算机程序运行的速度。 程序计数器是一个专用的寄存器，用于表明指令序列中 CPU 正在执行的位置，存的值为正在执行的指令的位置或者下一个将要被执行的指令的位置。 上下文切换会导致额外的开销，常常表现为高并发执行时速度会慢串行，因此减少上下文切换次数便可以提高多线程程序的运行效率。 直接消耗：指的是CPU寄存器需要保存和加载, 系统调度器的代码需要执行, TLB实例需要重新加载, CPU 的pipeline需要刷掉间接消耗：指的是多核的cache之间得共享数据, 间接消耗对于程序的影响要看线程工作区操作数据的大小 Atomic Variables（原子变量） 本质上是一组工具，位置在atomic包下 ​ 处理并发安全问题上：​ 1.单个原子处理​ 2.块处理 ​ 本质上分类两类，​ 1.保证基本数据类型的原子性（AtomicInteger…）​ 2.保证引用类型的原子性（AtomicReference） 原子引用与ABA问题 ABA问题： 在多线程对于原子变量操作时，会发生将数据变更回去的现象，CAS在判断时会造成概念上的认知错误，但是实际上对业务结果是不变的 但是实际业务运用过程中可能会需要知道整个运行过程值是否改变 通过AtomicStampedReference 追溯版本号通过AtomicMarkableReference 得到是否更改结果 不同场景下的原子变量操作方案 AtomicReference本质上是对于引用类型的地址但是我们常规使用中，更多的业务是要判定内部数据是否一致原子数组： 保证数组内元素的线程安全字段： 字段更新器 AtomicReferenceFieldUpdater累加业务： 原子累加器 LongAdder与Atomic比较 性能提升的原因很简单，就是有竞争时，设置多个累加单元，然后最后结果汇总，他这样的累加操作不同的cell变量，因此减少了Cas重试失败，从而提高性能 LongAdder原理分析 性能提升的原因很简单，就是有竞争时，设置多个累加单元，然后最后结果汇总，他这样的累加操作不同的cell变量，因此减少了Cas重试失败，从而提高性能 LongAdder伪共享原理与缓存行 什么是伪共享？ ​ CPU高度缓冲器的存储体系下，一个基本的缓存单位叫做缓存行，一个缓存行的大小为64byte,​ 数组是一块连续的空间，因为副本数据的原因，数组加载到缓存当中，数据超过64字节会占用多行,若小于64字节则占用一行 总结 对于并发处理，从业务角度我们看做为两块： ​ 1.原子变量操作 ​ 2.业务代码块的并发 并发手段现在接触的是两种： ​ 1.加锁并发：synchronize（悲观体现） ​ 2.无锁并发：CAS应用实现（乐观体现）","categories":[],"tags":[{"name":"JUC","slug":"JUC","permalink":"http://www.yppcat.top/tags/JUC/"}]},{"title":"锁","slug":"锁","date":"2022-11-24T00:33:55.000Z","updated":"2022-11-24T00:44:09.608Z","comments":true,"path":"2022/11/24/锁/","link":"","permalink":"http://www.yppcat.top/2022/11/24/锁/","excerpt":"","text":"JAVA下的线程安全分析 在系统处理过程中，最为常见的问题是同一线程对于相同资源进行访问所造成的数据处理异常问题 下面代码中可能出现的结果是多少？ 出现问题的过程指令分析-线程的上下文切换 临界区与竞态条件 临界区：一个程序运行多个线程本身没有问题出现问题最大的地方在于多个线程访问共享资源多个线程读共享资源其实也没有问题在多个线程对共享资源读写操作时发生指令交错，就会出现问题一段代码块内如果存在对共享资源的多线程读写操作，称这段代码为临界区 竞态条件:多个线程在临界区内执行，由于代码执行序列不同而导致结果无法预测，称之为静态条件 应用之互斥 为了避免临界区的竞态条件发生，JAVA提供多种手段进行规避阻塞式的解决方案：synchronized,Lock非阻塞式的解决方案：原子变量 synchronized对象锁：采用互斥方式让统一时刻之多只有一个线程持有对象锁，其他线程在获取这个对象锁会被阻塞，不用担心线程上下文切换 synchronized—本质与等价方案 Mark中的数据对于并发的支持 Monitor对象与synchronized 注意事项 执行同步代码块内容，然后唤醒entryList中其他线程时，此处采取竞争策略，先到不一定先得，所以synchronize锁是非公平 非公平锁： 在锁可用的时候，一个新到来的线程要占有锁，可以不需要排队，直接获得。 公平锁： 在锁可用的时候，一个新到来的线程要占有锁，需要排队，等待执行 有没有比synchronized速度更快的方案？ 利用CPU的CAS指令，同时借助JNI来完成Java的非阻塞算法。其它原子操作都是利用类似的特性完成的。而整个J.U.C都是建立在CAS之上的，因此对于synchronized阻塞算法，J.U.C在性能上有了很大的提升。 什么是CAS？ CAS是英文单词Compare And Swap的缩写，翻译过来就是比较并替换。 CAS机制当中使用了3个基本操作数：内存地址V旧的预期值A要修改的新值B 更新一个变量的时候，只有当变量的预期值A和内存地址V当中的实际值相同时，才会将内存地址V对应的值修改为B。 CAS机制当中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B。","categories":[],"tags":[{"name":"JUC","slug":"JUC","permalink":"http://www.yppcat.top/tags/JUC/"}]},{"title":"JMM内存模型与线程并发","slug":"JMM内存模型与线程并发","date":"2022-11-23T00:09:15.000Z","updated":"2022-11-23T00:27:46.051Z","comments":true,"path":"2022/11/23/JMM内存模型与线程并发/","link":"","permalink":"http://www.yppcat.top/2022/11/23/JMM内存模型与线程并发/","excerpt":"","text":"多核并发缓存架构解析 CPU 核心数和线程数的关系 多核心:也指单芯片多处理器( Chip Multiprocessors,简称 CMP),CMP 是由美国斯坦福大学提出的,其思想是将大规模并行处理器中的 SMP(对称多处理器)集成到同一芯片内,各个处理器并行执行不同的进程。这种依靠多个 CPU 同时并行地运行程序是实现超高速计算的一个重要方向,称为并行处理 多线程: Simultaneous Multithreading.简称 SMT.让同一个处理器上的多个线程同步执行并共享处理器的执行资源。核心数、线程数:目前主流 CPU 都是多核的。增加核心数目就是为了增加线程数,因为操作系统是通过线程来执行任务的,一般情况下它们是 1:1 对应关系,也就是说四核 CPU 一般拥有四个线程。但 Intel 引入超线程技术后,使核心数与线程数形成 1:2 的关系 CPU 时间片轮转机制 时间片轮转调度中唯一有趣的一点是时间片的长度。从一个进程切换到另一个进程是需要定时间的,包括保存和装入寄存器值及内存映像,更新各种表格和队列等。假如进程切( processwitch),有时称为上下文切换( context switch),需要 5ms, 再假设时间片设为 20ms,则在做完 20ms 有用的工作之后,CPU 将花费 5ms 来进行进程切换。CPU 时间的 20%被浪费在了管理开销上了。为了提高 CPU 效率,我们可以将时间片设为 5000ms。这时浪费的时间只有0.1%。但考虑到在一个分时系统中,如果有 10 个交互用户几乎同时按下回车键, 将发生什么情况?假设所有其他进程都用足它们的时间片的话,最后一个不幸的进程不得不等待 5s 才获得运行机会。多数用户无法忍受一条简短命令要 5 才能做出响应。结论可以归结如下:时间片设得太短会导致过多的进程切换,降低了CPU 效率: 而设得太长又可能引起对短的交互请求的响应变差。将时间片设为 100ms 通常是一个比较合理的折衷 并发与并行 我们举个例子,如果有条高速公路 A 上面并排有 8 条车道,那么最大的并行车辆就是 8 辆此条高速公路 A 同时并排行走的车辆小于等于 8 辆的时候,车辆就可以并行运行。CPU 也是这个原理,一个 CPU 相当于一个高速公路 A,核心数或者线程数就相当于并排可以通行的车道;而多个CPU 就相当于并排有多条高速公路,而每个高速公路并排有多个车道。当谈论并发的时候一定要加个单位时间,也就是说单位时间内并发量是多少? 离开了单位时间其实是没有意义的。俗话说,一心不能二用,这对计算机也一样,原则上一个 CPU 只能分配给一个进程,以便运行这个进程。我们通常使用的计算机中只有一个 CPU,也就是说只有一颗心,要让它一心多用同时运行多个进程,就必须使用并发技术。实现并发技术相当复杂,最容易理解的是“时间片轮转进程调度算法”。 CPU物理内核架构 多核CPU缓存架构 JMM内存模型 JAVA多线程内存模型跟CPU内存模型类似，是基于CPU缓存模型来建立的，java线程内存模型是标准化的，屏蔽了底层计算机的不同 JMM内存模型8大原子操作 read(读取)：从主内存中读取数据load(载入)：将主内存读取到的数据写入工作内存use(使用)：从工作内存读取数据来计算assign(赋值)：将计算好的值重新赋值到工作内存当中store(存储)：将工作内存数据写入主内存write(写入)：将存入的数据变量值赋值给主内存中的共享变量lock(锁定)：将主内存变量加锁unlock(解锁)：将主内存变量解锁 缓存一致协议（MESI）：多个CPU从主内存读取同一个数据到各自的高速缓存，当其中某个CPU修改了缓存里的数据，该数据马上同步会主内存，其他的CPU通过总线嗅探机制可以感知到数据的变化从而将自己缓存的数据失效 缓存加锁：缓存锁的核心机制是遵循与缓存一致性协议，一个处理器的缓存回写到内存会导致其他处理器的缓存失效，IA-32和Inter 64处理器使用MESI实现缓存一致性协议，Arm架构下是AMBA协议 Volatile可见性底层实现原理 Volatile缓存可见性实现原理：底层实现主要通过一条汇编指令lock前缀指令，他会锁定这块内存区域的缓存（缓存行锁定）并写回到主内存中Inter架构软件开发者手册中对lock指令的解释：会将当前处理器缓存行的数据立即写回到系统内存这个写回内存操作会引起其他CPU缓存了该地址的数据无效(MESI)提供内存屏障功能，是lock指令不会进行重排 JAVA底层对应转换汇编语言查看 -server -Xcomp -XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly -XX:CompileCommand=compileonly,*JMMTest.prepare dex工具使用 工具位置：SDK目录下\\build-tools\\版本\\dx.bat使用方式：配置该路径为环境变量作用：将.class编译为dex字节码转换指令：dx –dex –min-sdk-version=28 –verbose –dump-to=JmmTest.dex.txt –dump-method=JMMTest.prepare –verbose-dump JMMTest.class -server -Xcomp -XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly -XX:CompileCommand=compileonly,*VolatileVisibilltyTest.prepareData 指令重排序 在计算机执行指令的顺序在经过程序编译器编译之后形成的指令序列 一般而言，这个指令序列是会输出确定的结果；以确保每一次的执行都有确定的结果 但是，一般情况下，CPU和编译器为了提升程序执行的效率，会按照一定的规则允许进行指令优化 在某些情况下，这种优化会带来一些执行的逻辑问题，主要的原因是代码逻辑之间是存在一定的先后顺序 在并发执行情况下，会发生二义性，即按照不同的执行逻辑，会得到不同的结果信息。 规则: 改变指令的先后顺序会导致最终的结果不一致，则不会发生指令重排,反之 如果不会发生结果不一致则会发生重排指令重排主要反映在读和写的过程中 不会发生重排 名称 代码示例 说明 写后读 a = 1;b = a; 写一个变量之后，再读这个位置。 写后写 a = 1;a = 2; 写一个变量之后，再写这个变量。 读后写 a = b;b = 1; 读一个变量之后，再写这个变量 指令重排序规则 在计算机执行指令的顺序在经过程序编译器编译之后形成的指令序列 一般而言，这个指令序列是会输出确定的结果；以确保每一次的执行都有确定的结果 但是，一般情况下，CPU和编译器为了提升程序执行的效率，会按照一定的规则允许进行指令优化在某些情况下，这种优化会带来一些执行的逻辑问题，主要的原因是代码逻辑之间是存在一定的先后顺序 在并发执行情况下，会发生二义性，即按照不同的执行逻辑，会得到不同的结果信息。 Happens-Before 程序次序规则：在一个线程内一段代码的执行结果是有序的。就是还会指令重排，但是随便它怎么排，结果是按照我们代码的顺序生成的不会变。管程锁定规则：就是无论是在单线程环境还是多线程环境，对于同一个锁来说，一个线程对这个锁解锁之后，另一个线程获取了这个锁都能看到前一个线程的操作结果！(管程是一种通用的同步原语，synchronized就是管程的实现）volatile变量规则：就是如果一个线程先去写一个volatile变量，然后一个线程去读这个变量，那么这个写操作的结果一定对读的这个线程可见。线程启动规则：在主线程A执行过程中，启动子线程B，那么线程A在启动子线程B之前对共享变量的修改结果对线程B见。线程终止规则：在主线程A执行过程中，子线程B终止，那么线程B在终止之前对共享变量的修改结果在线程A中可见。也称线程join()规则。线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程代码检测到中断事件的发生，可以通过Thread.interrupted()检测到是否发生中断。传递性规则：这个简单的，就是happens-before原则具有传递性，即hb(A, B) ， hb(B, C)，那么hb(A, C)。对象终结规则：这个也简单的，就是一个对象的初始化的完成，也就是构造函 内存屏障 实际上就是如果CPU在指令优化时给与一个标记位置，碰到此位置不进行优化 Store：将处理器缓存的数据刷新到内存中。Load：将内存存储的数据拷贝到处理器的缓存中。","categories":[],"tags":[{"name":"JUC","slug":"JUC","permalink":"http://www.yppcat.top/tags/JUC/"}]},{"title":"JVM指令手册","slug":"JVM指令手册","date":"2022-11-20T13:30:37.000Z","updated":"2022-11-20T13:32:44.679Z","comments":true,"path":"2022/11/20/JVM指令手册/","link":"","permalink":"http://www.yppcat.top/2022/11/20/JVM指令手册/","excerpt":"","text":"JVM指令手册## 一、栈和局部变量操作 ### 将常量压入栈的指令 aconst_null 将null对象引用压入栈 iconst_m1 将int类型常量-1压入栈 iconst_0 将int类型常量0压入栈 iconst_1 将int类型常量1压入栈 iconst_2 将int类型常量2压入栈 iconst_3 将int类型常量3压入栈 iconst_4 将int类型常量4压入栈 iconst_5 将int类型常量5压入栈 lconst_0 将long类型常量0压入栈 lconst_1 将long类型常量1压入栈 fconst_0 将float类型常量0压入栈 fconst_1 将float类型常量1压入栈 dconst_0 将double类型常量0压入栈 dconst_1 将double类型常量1压入栈 bipush 将一个8位带符号整数压入栈 sipush 将16位带符号整数压入栈 ldc 把常量池中的项压入栈 ldc_w 把常量池中的项压入栈（使用宽索引） ldc2_w 把常量池中long类型或者double类型的项压入栈（使用宽索引） ### 从栈中的局部变量中装载值的指令 iload 从局部变量中装载int类型值 lload 从局部变量中装载long类型值 fload 从局部变量中装载float类型值 dload 从局部变量中装载double类型值 aload 从局部变量中装载引用类型值（refernce） iload_0 从局部变量0中装载int类型值 iload_1 从局部变量1中装载int类型值 iload_2 从局部变量2中装载int类型值 iload_3 从局部变量3中装载int类型值 lload_0 从局部变量0中装载long类型值 lload_1 从局部变量1中装载long类型值 lload_2 从局部变量2中装载long类型值 lload_3 从局部变量3中装载long类型值 fload_0 从局部变量0中装载float类型值 fload_1 从局部变量1中装载float类型值 fload_2 从局部变量2中装载float类型值 fload_3 从局部变量3中装载float类型值 dload_0 从局部变量0中装载double类型值 dload_1 从局部变量1中装载double类型值 dload_2 从局部变量2中装载double类型值 dload_3 从局部变量3中装载double类型值 aload_0 从局部变量0中装载引用类型值 aload_1 从局部变量1中装载引用类型值 aload_2 从局部变量2中装载引用类型值 aload_3 从局部变量3中装载引用类型值 iaload 从数组中装载int类型值 laload 从数组中装载long类型值 faload 从数组中装载float类型值 daload 从数组中装载double类型值 aaload 从数组中装载引用类型值 baload 从数组中装载byte类型或boolean类型值 caload 从数组中装载char类型值 saload 从数组中装载short类型值 ### 将栈中的值存入局部变量的指令 istore 将int类型值存入局部变量 lstore 将long类型值存入局部变量 fstore 将float类型值存入局部变量 dstore 将double类型值存入局部变量 astore 将将引用类型或returnAddress类型值存入局部变量 istore_0 将int类型值存入局部变量0 istore_1 将int类型值存入局部变量1 istore_2 将int类型值存入局部变量2 istore_3 将int类型值存入局部变量3 lstore_0 将long类型值存入局部变量0 lstore_1 将long类型值存入局部变量1 lstore_2 将long类型值存入局部变量2 lstore_3 将long类型值存入局部变量3 fstore_0 将float类型值存入局部变量0 fstore_1 将float类型值存入局部变量1 fstore_2 将float类型值存入局部变量2 fstore_3 将float类型值存入局部变量3 dstore_0 将double类型值存入局部变量0 dstore_1 将double类型值存入局部变量1 dstore_2 将double类型值存入局部变量2 dstore_3 将double类型值存入局部变量3 astore_0 将引用类型或returnAddress类型值存入局部变量0 astore_1 将引用类型或returnAddress类型值存入局部变量1 astore_2 将引用类型或returnAddress类型值存入局部变量2 astore_3 将引用类型或returnAddress类型值存入局部变量3 iastore 将int类型值存入数组中 lastore 将long类型值存入数组中 fastore 将float类型值存入数组中 dastore 将double类型值存入数组中 aastore 将引用类型值存入数组中 bastore 将byte类型或者boolean类型值存入数组中 castore 将char类型值存入数组中 sastore 将short类型值存入数组中 wide指令 wide 使用附加字节扩展局部变量索引 ### 通用(无类型）栈操作 nop 不做任何操作 pop 弹出栈顶端一个字长的内容 pop2 弹出栈顶端两个字长的内容 dup 复制栈顶部一个字长内容 dup_x1 复制栈顶部一个字长的内容，然后将复制内容及原来弹出的两个字长的内容压入栈 dup_x2 复制栈顶部一个字长的内容，然后将复制内容及原来弹出的三个字长的内容压入栈 dup2 复制栈顶部两个字长内容 dup2_x1 复制栈顶部两个字长的内容，然后将复制内容及原来弹出的三个字长的内容压入栈 dup2_x2 复制栈顶部两个字长的内容，然后将复制内容及原来弹出的四个字长的内容压入栈 swap 交换栈顶部两个字长内容 ## 二、类型转换 i2l 把int类型的数据转化为long类型 i2f 把int类型的数据转化为float类型 i2d 把int类型的数据转化为double类型 l2i 把long类型的数据转化为int类型 l2f 把long类型的数据转化为float类型 l2d 把long类型的数据转化为double类型 f2i 把float类型的数据转化为int类型 f2l 把float类型的数据转化为long类型 f2d 把float类型的数据转化为double类型 d2i 把double类型的数据转化为int类型 d2l 把double类型的数据转化为long类型 d2f 把double类型的数据转化为float类型 i2b 把int类型的数据转化为byte类型 i2c 把int类型的数据转化为char类型 i2s 把int类型的数据转化为short类型 ## 三、整数运算 iadd 执行int类型的加法 ladd 执行long类型的加法 isub 执行int类型的减法 lsub 执行long类型的减法 imul 执行int类型的乘法 lmul 执行long类型的乘法 idiv 执行int类型的除法 ldiv 执行long类型的除法 irem 计算int类型除法的余数 lrem 计算long类型除法的余数 ineg 对一个int类型值进行取反操作 lneg 对一个long类型值进行取反操作 iinc 把一个常量值加到一个int类型的局部变量上 ## 四、逻辑运算 ### 移位操作 ishl 执行int类型的向左移位操作 lshl 执行long类型的向左移位操作 ishr 执行int类型的向右移位操作 lshr 执行long类型的向右移位操作 iushr 执行int类型的向右逻辑移位操作 lushr 执行long类型的向右逻辑移位操作 ### 按位布尔运算 iand 对int类型值进行“逻辑与”操作 land 对long类型值进行“逻辑与”操作 ior 对int类型值进行“逻辑或”操作 lor 对long类型值进行“逻辑或”操作 ixor 对int类型值进行“逻辑异或”操作 lxor 对long类型值进行“逻辑异或”操作 ### 浮点运算 fadd 执行float类型的加法 dadd 执行double类型的加法 fsub 执行float类型的减法 dsub 执行double类型的减法 fmul 执行float类型的乘法 dmul 执行double类型的乘法 fdiv 执行float类型的除法 ddiv 执行double类型的除法 frem 计算float类型除法的余数 drem 计算double类型除法的余数 fneg 将一个float类型的数值取反 dneg 将一个double类型的数值取反 ## 五、对象和数组 ### 对象操作指令 new 创建一个新对象 checkcast 确定对象为所给定的类型。后跟目标类，判断栈顶元素是否为目标类 / 接口的实例。如果不是便抛出异常 getfield 从对象中获取字段 putfield 设置对象中字段的值 getstatic 从类中获取静态字段 putstatic 设置类中静态字段的值 instanceof 判断对象是否为给定的类型。后跟目标类，判断栈顶元素是否为目标类 / 接口的实例。是则压入 1，否则压入 0 ### 数组操作指令 newarray 分配数据成员类型为基本上数据类型的新数组 anewarray 分配数据成员类型为引用类型的新数组 arraylength 获取数组长度 multianewarray 分配新的多维数组 ## 六、控制流 ### 条件分支指令 ifeq 如果等于0，则跳转 ifne 如果不等于0，则跳转 iflt 如果小于0，则跳转 ifge 如果大于等于0，则跳转 ifgt 如果大于0，则跳转 ifle 如果小于等于0，则跳转 if_icmpcq 如果两个int值相等，则跳转 if_icmpne 如果两个int类型值不相等，则跳转 if_icmplt 如果一个int类型值小于另外一个int类型值，则跳转 if_icmpge 如果一个int类型值大于或者等于另外一个int类型值，则跳转 if_icmpgt 如果一个int类型值大于另外一个int类型值，则跳转 if_icmple 如果一个int类型值小于或者等于另外一个int类型值，则跳转 ifnull 如果等于null，则跳转 ifnonnull 如果不等于null，则跳转 if_acmpeq 如果两个对象引用相等，则跳转 if_acmpnc 如果两个对象引用不相等，则跳转 ### 比较指令 lcmp 比较long类型值 fcmpl 比较float类型值（当遇到NaN时，返回-1） fcmpg 比较float类型值（当遇到NaN时，返回1） dcmpl 比较double类型值（当遇到NaN时，返回-1） dcmpg 比较double类型值（当遇到NaN时，返回1） ### 无条件转移指令 goto 无条件跳转 goto_w 无条件跳转（宽索引） ### 表跳转指令 tableswitch 通过索引访问跳转表，并跳转 lookupswitch 通过键值匹配访问跳转表，并执行跳转操作 ### 异常 athrow 抛出异常或错误。将栈顶异常抛出 finally子句 jsr 跳转到子例程 jsr_w 跳转到子例程（宽索引） rct 从子例程返回 ## 七、方法调用与返回 ### 方法调用指令 invokcvirtual 运行时按照对象的类来调用实例方法 invokespecial 根据编译时类型来调用实例方法 invokestatic 调用类（静态）方法 invokcinterface 调用接口方法 ### 方法返回指令 ireturn 从方法中返回int类型的数据 lreturn 从方法中返回long类型的数据 freturn 从方法中返回float类型的数据 dreturn 从方法中返回double类型的数据 areturn 从方法中返回引用类型的数据 return 从方法中返回，返回值为void ### 线程同步 montiorenter 进入并获取对象监视器。即：为栈顶对象加锁 monitorexit 释放并退出对象监视器。即：为栈顶对象解锁 ## 八、JVM指令助记符 变量到操作数栈：iload,iload_,lload,lload_,fload,fload_,dload,dload_,aload,aload_ 操作数栈到变量：istore,istore_,lstore,lstore_,fstore,fstore_,dstore,dstor_,astore,astore_ 常数到操作数栈：bipush,sipush,ldc,ldc_w,ldc2_w,aconst_null,iconst_ml,iconst_,lconst_,fconst_,dconst_ 加：iadd,ladd,fadd,dadd 减：isub,lsub,fsub,dsub 乘：imul,lmul,fmul,dmul 除：idiv,ldiv,fdiv,ddiv 余数：irem,lrem,frem,drem 取负：ineg,lneg,fneg,dneg 移位：ishl,lshr,iushr,lshl,lshr,lushr 按位或：ior,lor 按位与：iand,land 按位异或：ixor,lxor 类型转换：i2l,i2f,i2d,l2f,l2d,f2d(放宽数值转换) i2b,i2c,i2s,l2i,f2i,f2l,d2i,d2l,d2f(缩窄数值转换) 创建类实便：new 创建新数组：newarray,anewarray,multianwarray 访问类的域和类实例域：getfield,putfield,getstatic,putstatic 把数据装载到操作数栈：baload,caload,saload,iaload,laload,faload,daload,aaload 从操作数栈存存储到数组：bastore,castore,sastore,iastore,lastore,fastore,dastore,aastore 获取数组长度：arraylength 检相类实例或数组属性：instanceof,checkcast 操作数栈管理：pop,pop2,dup,dup2,dup_xl,dup2_xl,dup_x2,dup2_x2,swap 有条件转移：ifeq,iflt,ifle,ifne,ifgt,ifge,ifnull,ifnonnull,if_icmpeq,if_icmpene, if_icmplt,if_icmpgt,if_icmple,if_icmpge,if_acmpeq,if_acmpne,lcmp,fcmpl fcmpg,dcmpl,dcmpg 复合条件转移：tableswitch,lookupswitch 无条件转移：goto,goto_w,jsr,jsr_w,ret 调度对象的实便方法：invokevirtual 调用由接口实现的方法：invokeinterface 调用需要特殊处理的实例方法：invokespecial 调用命名类中的静态方法：invokestatic 方法返回：ireturn,lreturn,freturn,dreturn,areturn,return 异常：athrow finally关键字的实现使用：jsr,jsr_w,ret","categories":[],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://www.yppcat.top/tags/JVM/"}]},{"title":"class字节码文件结构","slug":"class字节码文件结构","date":"2022-11-20T13:30:19.000Z","updated":"2022-11-20T13:32:28.054Z","comments":true,"path":"2022/11/20/class字节码文件结构/","link":"","permalink":"http://www.yppcat.top/2022/11/20/class字节码文件结构/","excerpt":"","text":"class字节码文件结构## class字节码文件结构 | 类型 | 名称 | 说明 | 长度 | 数量 | | ————– | ——————- | ———————- | ——- | ——————— | | u4 | magic | 魔数,识别Class文件格式 | 4个字节 | 1 | | u2 | minor_version | 副版本号(小版本) | 2个字节 | 1 | | u2 | major_version | 主版本号(大版本) | 2个字节 | 1 | | u2 | constant_pool_count | 常量池计数器 | 2个字节 | 1 | | cp_info | constant_pool | 常量池表 | n个字节 | constant_pool_count-1 | | u2 | access_flags | 访问标识 | 2个字节 | 1 | | u2 | this_class | 类索引 | 2个字节 | 1 | | u2 | super_class | 父类索引 | 2个字节 | 1 | | u2 | interfaces_count | 接口计数器 | 2个字节 | 1 | | u2 | interfaces | 接口索引集合 | 2个字节 | interfaces_count | | u2 | fields_count | 字段计数器 | 2个字节 | 1 | | field_info | fields | 字段表 | n个字节 | fields_count | | u2 | methods_count | 方法计数器 | 2个字节 | 1 | | method_info | methods | 方法表 | n个字节 | methods_count | | u2 | attributes_count | 属性计数器 | 2个字节 | 1 | | attribute_info | attributes | 属性表 | n个字节 | attributes_count | ## Class文件版本号和平台的对应 | 主版本（十进制） | 副版本（十进制） | 编译器版本 | | —————- | —————- | ———- | | 45 | 3 | 1.1 | | 46 | 0 | 1.2 | | 47 | 0 | 1.3 | | 48 | 0 | 1.4 | | 49 | 0 | 1.5 | | 50 | 0 | 1.6 | | 51 | 0 | 1.7 | | 52 | 0 | 1.8 | | 53 | 0 | 1.9 | | 54 | 0 | 1.10 | | 55 | 0 | 1.11 | ## class文件数据类型 | 数据类型 | 定义 | 说明 | | ——– | ———————————————————— | ———————————————————— | | 无符号数 | 无符号数可以用来描述数字、索引引用、数量值或按照utf-8编码构成的字符串值。 | 其中无符号数属于基本的数据类型。 以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节 | | 表 | 表是由多个无符号数或其他表构成的复合数据结构。 | 所有的表都以“_info”结尾。 由于表没有固定长度，所以通常会在其前面加上个数说明。 | ## 类型描述符 | 标志符 | 含义 | | —— | —————————————————- | | B | 基本数据类型byte | | C | 基本数据类型char | | D | 基本数据类型double | | F | 基本数据类型float | | I | 基本数据类型int | | J | 基本数据类型long | | S | 基本数据类型short | | Z | 基本数据类型boolean | | V | 代表void类型 | | L | 对象类型，比如：Ljava/lang/Object; | | [ | 数组类型，代表一维数组。比如：double[][][] is [[[D | ## 常量类型和结构 | 类型 | 标志(或标识) | 描述 | | ——————————– | ———— | ———————- | | CONSTANT_utf8_info | 1 | UTF-8编码的字符串 | | CONSTANT_Integer_info | 3 | 整型字面量 | | CONSTANT_Float_info | 4 | 浮点型字面量 | | CONSTANT_Long_info | 5 | 长整型字面量 | | CONSTANT_Double_info | 6 | 双精度浮点型字面量 | | CONSTANT_Class_info | 7 | 类或接口的符号引用 | | CONSTANT_String_info | 8 | 字符串类型字面量 | | CONSTANT_Fieldref_info | 9 | 字段的符号引用 | | CONSTANT_Methodref_info | 10 | 类中方法的符号引用 | | CONSTANT_InterfaceMethodref_info | 11 | 接口中方法的符号引用 | | CONSTANT_NameAndType_info | 12 | 字段或方法的符号引用 | | CONSTANT_MethodHandle_info | 15 | 表示方法句柄 | | CONSTANT_MethodType_info | 16 | 标志方法类型 | | CONSTANT_InvokeDynamic_info | 18 | 表示一个动态方法调用点 | ## 常量类型和结构细节 常量类型和结构 标志 常量 描述 细节 长度 细节描述 1 CONSTANT_utf8_info UTF-8编码的字符串 tag u1 值为1 length u2 UTF-8编码的字符串占用的字符数 bytes u1 长度为length的UTF-8编码的字符串 3 CONSTANT_Integer_info 整型字面量 tag u1 值为3 bytes u4 按照高位在前存储的int值 4 CONSTANT_Float_info 浮点型字面量 tag u1 值为4 bytes u4 按照高位在前存储的float值 5 CONSTANT_Long_info 长整型字面量 tag u1 值为5 bytes u8 按照高位在前存储的long值 6 CONSTANT_Double_info 双精度浮点型字面量 tag u1 值为6 bytes u8 按照高位在前存储的double值 7 CONSTANT_Class_info 类或接口的符号引用 tag u1 值为7 index u2 指向全限定名常量项的索引 8 CONSTANT_String_info 字符串类型字面量 tag u1 值为8 index u2 指向字符串字面量的索引 9 CONSTANT_Fieldref_info 字段的符号引用 tag u1 值为9 index u2 指向声明字段的类或接口描述符CONSTANT_Class_info的索引项 index u2 指向字段描述符CONSTANT_NameAndType的索引项 10 CONSTANT_Methodref_info 类中方法的符号引用 tag u1 值为10 index u2 指向声明方法的类描述符CONSTANT_Class_Info的索引项 index u2 指向名称及类型描述符CONSTANT_NameAndType的索引项 11 CONSTANT_InterfaceMethodref_info 接口中方法的符号引用 tag u1 值为11 index u2 指向声明方法的接口描述符CONSTANT_Class_Info的索引项 index u2 指向名称及类型描述符CONSTANT_NameAndType的索引项 12 CONSTANT_NameAndType_info 字段或方法的符号引用 tag u1 值为12 index u2 指向该字段或方法名称常量项的索引 index u2 指向该字段或方法描述符常量项的索引 15 CONSTANT_MethodHandle_info 表示方法句柄 tag u1 值为15 reference_kind u1 值必须在1-9之间，它决定了方法句柄的类型方法句柄类型的值表示方法句柄的字节码行为 reference_index u2 值必须是对常量池的有效索引 16 CONSTANT_MethodType_info 标志方法类型 tag u1 值为16 descriptor_index u2 值必须是对常量池的有效索引，常量池在该索引处的项必须是CONSTANT_Utf8_info结构，表示方法的描述符 18 CONSTANT_InvokeDynamic_info 表示一个动态方法调用点 tag u1 值为18 bootstrap_method_attr u2 值必须是对当前Class文件中引导方法表的bootstrap_methods[]数组的有效索引 name_and_type_index u2 值必须是对当前常量池的有效索引，常量池在该索引处的项必须是CONSTANT_NameAndType_Info结构，表示方法名和方法描述符 ## 访问标志 | 标志名称 | 标志值 | 含义 | | ————– | —— | ———————————————————— | | ACC_PUBLIC | 0x0001 | 标志为public类型 | | ACC_FINAL | 0x0010 | 标志被声明为final，只有类可以设置 | | ACC_SUPER | 0x0020 | 标志允许使用invokespecial字节码指令的新语义，JDK1.0.2之后编译出来的类的这个标志默认为真。（使用增强的方法调用父类方法） | | ACC_INTERFACE | 0x0200 | 标志这是一个接口 | | ACC_ABSTRACT | 0x0400 | 是否为abstract类型，对于接口或者抽象类来说，次标志值为真，其他类型为假 | | ACC_SYNTHETIC | 0x1000 | 标志此类并非由用户代码产生（即：由编译器产生的类，没有源码对应） | | ACC_ANNOTATION | 0x2000 | 标志这是一个注解 | | ACC_ENUM | 0x4000 | 标志这是一个枚举 | ## 字段表访问标志 | 标志名称 | 标志值 | 含义 | | ————- | —— | ————————– | | ACC_PUBLIC | 0x0001 | 字段是否为public | | ACC_PRIVATE | 0x0002 | 字段是否为private | | ACC_PROTECTED | 0x0004 | 字段是否为protected | | ACC_STATIC | 0x0008 | 字段是否为static | | ACC_FINAL | 0x0010 | 字段是否为final | | ACC_VOLATILE | 0x0040 | 字段是否为volatile | | ACC_TRANSTENT | 0x0080 | 字段是否为transient | | ACC_SYNCHETIC | 0x1000 | 字段是否为由编译器自动产生 | | ACC_ENUM | 0x4000 | 字段是否为enum | ## 类索引、父类索引、接口索引 | 长度 | 含义 | | —- | —————————- | | u2 | this_class | | u2 | super_class | | u2 | interfaces_count | | u2 | interfaces[interfaces_count] | ## 属性的通用格式 | 类型 | 名称 | 数量 | 含义 | | —- | ——————– | —————- | ———- | | u2 | attribute_name_index | 1 | 属性名索引 | | u4 | attribute_length | 1 | 属性长度 | | u1 | info | attribute_length | 属性表 | ## 数据类型和默认初始值对应 | 类型 | 默认初始值 | | ——— | ———- | | byte | (byte)0 | | short | (short)0 | | int | 0 | | long | 0L | | float | 0.0f | | double | 0.0 | | char | \\u0000 | | boolean | false | | reference | null |","categories":[],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://www.yppcat.top/tags/JVM/"}]},{"title":"字节码文件与类加载","slug":"字节码文件与类加载","date":"2022-11-20T13:11:06.000Z","updated":"2022-11-20T13:48:32.227Z","comments":true,"path":"2022/11/20/字节码文件与类加载/","link":"","permalink":"http://www.yppcat.top/2022/11/20/字节码文件与类加载/","excerpt":"","text":"Dalvik虚拟机执行的是dex字节码，解释执行。从Android 2.2版本开始，支持在程序运行的过程中进行选择热点代码（经常执行的代码）进行编译或者优化。 而ART（Android Runtime） 是在 Android 4.4 中引入的一个开发者选项，也是 Android 5.0 及更高版本的默认 Android 运行时。ART虚拟机执行的是本地机器码。Android的运行时从Dalvik虚拟机替换成ART虚拟机，并不要求开发者将自己的应用直接编译成目标机器码，APK仍然是一个包含dex字节码的文件。 那么，ART虚拟机执行的本地机器码是从哪里来？ 前端编译器与后端编译器 解释执行&amp;JIT&amp;AOT 解释执行 ： 程序运行过程中，逐行进行代码编译 JIT ：程序运行过程中，将热点代码进行编译缓存执行 AOT：运行之前，将所有代码打包编译成机器码 dex2aot Dalvik下应用在安装的过程，会执行一次优化，将dex字节码进行优化生成odex文件。 而Art下将应用的dex字节码翻译成本地机器码的最恰当AOT时机也就发生在应用安装的时候。ART 引入了预先编译机制（Ahead Of Time），在安装时，ART 使用设备自带的 dex2oat 工具来编译应用，dex中的字节码将被编译成本地机器码 Android N的运作方式 ART 使用预先 (AOT) 编译，并且从 Android N混合使用AOT编译，解释和JIT。 1、最初安装应用时不进行任何 AOT 编译（安装又快了），运行过程中解释执行，对经常执行的方法进行JIT，经过 JIT 编译的方法将会记录到Profile配置文件中。 2、当设备闲置和充电时，编译守护进程会运行，根据Profile文件对常用代码进行 AOT 编译。待下次运行时直接使用。 “类（文件）”的生命周期 类的生命周期概述 在JAVA中数据类型分为引用数据类型与基本数据类型，基本数据类型由虚拟机预先定义，引用数据类型则需要进行类加载。 按照JAVA虚拟机规范，从class文件到加载到内存当中的类，到类写在出内存位置，他的整个生命周期包含下述七个阶段 类的卸载 我们需要知道的是，一个我自己写的代码文件如何到内存当中被使用以及释放的过程 ​ 1.写代码—.java—&gt;前段编译器—&gt;.class—–&gt;通过IO读取进来—-&gt;解析文件结构，约定固定套路 ​ —-&gt;将解出来的数据扔到方法区—-&gt;将当前这个类的信息提取出来—&gt;推到堆当中生成Class对象 ​ —-&gt;具体使用—&gt;cinit—-&gt;卸载 字节码解析 类加载器 类加载： ​ 读取指定目录下面的相关字节码文件，解析文 ​ 系统类加载器/启动类加载器/根类加载器 ​ 加载jre下的内容 ​ 扩展类加载器 ​ 加载ext文件夹下的内容 ​ 应用程序类加载器 ​ 加载自己工程当中的内容 ​ 自定义类加载器（热修复） ​ 提供自己去写类加载器的方案，自己去指定某个路径或者某个文件，只要你是符合jvm字节码规范 ​ Dex—&gt;N个Class文件—》应用程序类加载器–》不支持。自己写 ​ ​ 类加载器的分类=类加载器的种类 ​ 不是继承关系，每个人都是独立的，每个人干自己不同的活，加载代码的路径不一致 ​ ART ！= JVM ​ BootClassLoader—&gt;DexBaseClassloader Android的应用程序类加载器 类加载–》物理读取字节码文件的动作 ​ loadClass—》双亲委派–》为了保证我找不到，其他人能够去找 ​ findClass—&gt;找一个路径，读取这个文件出来，形成一个字节码数组 ​ defindClass—》将字节码文件读取完后进行校验，然后生成Class数据对象 ​ ​ defindClass结束，类加载结束—- 热修复原理 热修复原理就是类加载器的核心 热修复文章 ： https://blog.csdn.net/sahadev_/article/details/53318251","categories":[],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://www.yppcat.top/tags/JVM/"}]},{"title":"GC及调优","slug":"GC及调优","date":"2022-11-18T11:25:19.000Z","updated":"2022-11-18T11:54:40.354Z","comments":true,"path":"2022/11/18/GC及调优/","link":"","permalink":"http://www.yppcat.top/2022/11/18/GC及调优/","excerpt":"","text":"GC核心概述Java自动化内存管理 好处： 无需开发人员手动参与内存分配与回收，降低内存泄漏与溢出风险 缺点： 弱化了开发人员在程序出现内存溢出时定位问题和解决问题的能 对于我们现在的意义：我们必须堆这些自动化技术的原理进行了解，学会如何去监控和调节 垃圾：指在程序中没有任何指针指向的对象，这个对象就是需要被回收的垃圾 内存碎片概念 存储地址空间是指对存储器编码（编码地址）的范围。所谓编码就是对每一个物理存储单元（一个字节）分配一个号码，通常叫作“编址”。分配一个号码给一个存储单元的目的是为了便于找到它，完成数据的读写，这就是所谓的“寻址”（所以，有人也把地址空间称为寻址空间）。地址空间的大小和物理存储器的大小并不一定相等。举个例子来说明这个问题：某层楼共有17个房间，其编号为801～817。这17个房间是物理的，而其地址空间采用了三位编码，其范围是800～899共100个地址，可见地址空间是大于实际房间数量的。 为什么需要GC？ 对于系统而言，内存迟早都会被消耗完，因为不断的分配内存空间而不进行回溯，就好像不停的产生生活垃圾 但是除了释放垃圾对象，也需要对于内存空间进行碎片管理，没有GC就不能保证应用程序的正常化进行 GC核心算法1.垃圾确认算法–标记阶段算法 引用计数算法 GCRoot可达性分析算法2.清除垃圾算法–清除阶段算法 标记-清除算法 复制算法 标记-压缩算法 引用计数算法 原理：对每一个对象保存一个整形的引用计数器属性，用于记录对象被引用的情况。 例：一个对象A只要有任何一个对象引用了A则A的引用计数器就+1，当引用失效时，引用计数器就-1.只要对象A的引用计数器的值为0，即标识对象A不可能再被使用，可进行回收 优点：实现简单，垃圾对象便于识别，判断效率高 缺点： 他需要单独的字段存储计数器，这样的做法增加的存储空间的开销 每次赋值需要额外的加减法计算，增加了时间开销 引用计数算法最大的问题是无法处理循环引用的情况，这是一个比较致命的缺陷 引用计数算法循环引用问题 可达性分析算法 相对于引用计数算法，他有效的解决了在引用计数算法中的循环引用问题，防止内存泄漏发生这种类型的垃圾收集也叫作追踪性垃圾收集 概念： 可达性分析算法以跟对象集合为起点，按照从上至下的方式搜索被跟对象集合所链接的对象目标是否可达 使用可达性分析算法后，内存中的存货对象会被跟对象集合直接或者间接连接着，搜索所走过的路径称之为引用链 如果目标对象没有任何阴影链项链，则是不可达的，意味着该对象已经死亡，可以标记为垃圾对象。 在可达性分析算法中只有能够被根对象集合直接或间接连接的对象才是存活对象。 GCRoots 虚拟机栈汇总的引用对象例：各个线程被调用的方法中使用的参数、局部变量等本地方法栈内JNI引用的对象 方法区中类静态属性引用对象例：JAVA类的引用类型静态变量 方法区中常量引用的对象例：字符串常量池里面的引用 所有被同步所synchronize持有的对象 java虚拟机内部引用的对象例：基本数据类型对应的Class对象，一些常驻的异常对象（NullPointerException等）,系统类加载器 总结：一个指针，他保存了堆里面的对象，但自己又不在堆当中，那么他就是一个Root 标记-清除（Mark-Sweep）算法 背景：标记清除算法是一种非常基础和常见的垃圾收集算法，该算法被J.McCarthy等人在1960年提出并应用于Lisp语言 执行过程：当堆空间中有效内存空间被耗尽时，就会停止这个程序（Stop the world），然后进行两项工作，标记，清除这两部分标记：从引用根节点上开始遍历（可达性分析算法）标记所有被引用的对象。一般是在对象Header中记录为可达对象。清除：对堆内存从头到尾进行线性遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收缺点：效率不高；在进行GC的时候需要停止整个应用程序，导致用户体验差；且会产生的大量的内存碎片 注意：在这里的清除不是去干掉具体内存中的数据，而是本身分配的是一组连续的内存编码给我们使用，清除就是在回收这些空闲地址，将他们保存在空闲地址表当中，下次有新的对象需要空间时去判断是否够用 复制（Copying）算法 背景：为了解决标记-清除算法在垃圾收集效率方面的缺陷，M.LMinsky与1963年发表了著名论文，”使用双存储区的Lisp语言垃圾收集器“，该论文中被描述的算法被人们称之为复制算法。 执行过程：将内存空间分为两块，每次只使用其中一块，在垃圾回收的时候，将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块，交换两个内存角色。缺点：1.需要两倍空间2.GC需要维护对象的引用关系，时间开销加大此种方案使用与垃圾对象较少，量级不大的情况 应用场景 在年青代中，对常规应用的垃圾回收，一次通常可以回收70%-99%的内存空间。回收性价比高。所以年青代一般采用这种 标记-压缩/整理（Mark-Compact）算法 背景：复制算法的高效是简历在存货对象少、垃圾对象多的前提下。这种情况在新生代中经常法神，但是在老年代，更常见的情况是大部分对象都是存货的。如果依然使用复制算法，由于存货对象多，复制成本也会非常高。因此基于老年代使用复制算法并不适用。 执行过程：第一阶段与标记清除算法一致。第二阶段将所有的存货对象压缩到内存的一段，按照顺讯排放，之后清理边界外所有空间 优劣：标记压缩算法的最终效果等同于标记-清除算法执行完成后在进行一次内存碎片的整理，因此，也可以把他称之为标记-清除-压缩（Mark-Sweep-Compact）算法。二者本质差异在于标记清除算法是一直非移动式的回收算法，标记压缩是移动式的。是否移动回收后的存货对象是一项优缺点并存的风险决策可以看到，标记的存货被整理后，按照内存地址一次排列，而未被标记的内存会被清理掉。如此一来，我们需要给新对象分配内存是，JVM只需要持有一个内存的起始地址即可，这个比维护一个空闲列表显然少了很多开销 三种算法的性能指标对比 指标 Mark-Sweep Mark-Compact Copying 速度 中等 最慢 最快 空间 少（会堆积碎片） 少（不堆积碎片） 需要两倍大小（不堆积碎片） 移动对象 否 是 是 效率上来说，复制算法最快，但是内存浪费最多而为了尽量兼顾上面三个指标，标记整理算法相对平滑一些，但是效率上不仅如此任意，他比复制算法多了一个标记阶段，比清除多了一个整理内存阶段 分代收集算法 为了满足垃圾回收的效率最优性，所以分代手机算法应运而生。分代手机算法基于一个事实：不同的对象生命周期是不一样的，因此，不同生命周期的对象可以采取不同的手机方式，以便于提高回收效率。一般是把JAVA堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同回收算法，相对提高效率在系统运行过程汇总，会产生大量对象，其中有些对象是业务信息相关，如HTTP请求的Session、线程、Socket连接等对象，这类对象跟业务挂钩，因此生命周期长，还有一部分是运行过程汇总生成的临时变量，这些对象生命周期短，比如：String,这些对象甚至只使用一次即可回收 目前所有GC都采用分代收集算法进行执行对象的状态经过大量的调研研究划分为年青代与老年代两个类别年青代：区域相对小，对象生命周期短、存活率低，且产生应用频繁复制算法回收整理速度是最快的。复制算法效率只与当前存活对象大小有关，因此很实用与年青代的回收，而空间问题，因为存活率问题，所以单独开辟S0,S1两块空间处理清除后结果老年代：区域较大，生命周期长、存活率高，回收不及年青代频繁这种情况存在大量存过对象下，复制不适用，所以一般是用清除与整理算法混合实现Mark阶段的开销与存活对象的数量成正比Sweep阶段的开销与所管理的大小成正比Compact阶段的开销与存活对象的数据成正比 增量收集算法 上述所有算法，在垃圾回收过程中，软件都会处于一种Stop The World的状态。在STW状态下，应用程序所有线程都会挂起，暂停一切正常工作，等待垃圾回收完成，这种情况将严重影响用户体验或系统稳定。为了解决这个问题，催生出了一套增量手机算法。 基本概念：如果一次性将所有垃圾进行处理，需要造成系统长时间停顿，那么久可以让垃圾收集线程和应用程序线程交替执行。每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。一次反复，直到垃圾收集完成。 总结：实际上就是通过对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理、复制等工作。 使用这种方式，由于在垃圾回收过程中，间断性的还执行了应用程序代码，所以能减少停顿时间。但是因为线程切换和上下文转换的消耗，会是的垃圾回收的总体成本上升，系统吞吐量下降。 分区算法 相同条件下，堆空间越大，一次GC时间越长，停顿时间也越长，为了更好地控制GC产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干小区间，而不是整个堆空间，从而减少一次GC所产生的停顿。 总结 :注意，实际上GC过程要复杂的多，需要考虑的不单单是这些，还有并行与并发的兼顾，而且通常都会应用复合算法去使用 垃圾回收器与内存管理常用7种垃圾回收器 垃圾回收的并行与串行 并行&amp;串行：并行（Parallel）：只多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态。ParNew、Parallel Scavenge、Parallel Old串行（Serial）：单线程执行如果内存不够则程序暂停，启动JVM垃圾回收器进行垃圾回收。回收万再启动城西县城 并行&amp;并发：并发：指的是多个事情在同一时间段内同时发生并发的多个任务之间是相互抢占资源并行：指的是多个事情在同一时间点上同时发生了并行的多个线程之间不相互抢占资源 只有在多个CPU或者一个CPU多核的情况中，才会发生并行。否则，看似相同发生的事情，实际上都是并发执行 常用GC垃圾回收器对比 CMS回收器 初始标记：这个阶段会出现STW现象，主要工作内容是标记处GCRoot能关联到的对象。（注意，这里只有GCROOT的对象，不会涉及引用链）并发标记：遍历GCROOT整个引用链，这个工作耗时非常长，采取了与垃圾收集器线程一起运行的方案重新标记：因为在上面步骤有用户线程行为，所以此处再次STW，进行重新标记，但是这部分只管重新运行后的那部分对象数据的变动。并发清理：清理所有标记的死亡对象，释放，这一步与用户线程同步进行并发重置： 评估GC的性能指标 吞吐量：运行用户代码的时间占总运行时间的比例 总运行时间=程序运行时间+内存回收时间垃圾收集开销：吞吐量的补数，垃圾收集所用时间与总运行时间的比例暂停时间：执行垃圾收集时，程序的工作线程被暂停的时间收集频率：应用程序的执行，收集操作发生的次数内存占用：java堆区所占的内存大小 不可达三角： 性能调优的终极概念：空间换时间、时间换空间不存在完美，一般情况下抓住吞吐量与暂停时间来设计","categories":[],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://www.yppcat.top/tags/JVM/"}]},{"title":"Dalvik虚拟机与ART虚拟机","slug":"Dalvik虚拟机与ART虚拟机","date":"2022-11-18T09:14:42.000Z","updated":"2022-11-18T09:52:06.255Z","comments":true,"path":"2022/11/18/Dalvik虚拟机与ART虚拟机/","link":"","permalink":"http://www.yppcat.top/2022/11/18/Dalvik虚拟机与ART虚拟机/","excerpt":"","text":"Dalvik虚拟机&amp;ART虚拟机与Hotspot区别 Dalivk VM: 隶属：Google 发展历史： 应用于Android系统，并且在Android2.2中提供了JIT，发展迅猛 Dalvik是一款不是JVM的JVM虚拟机。本质上他没有遵循与JVM规范 不能直接运行java Class文件 他的结构基于寄存器结构，而不是JVM栈架构 执行的是编译后的Dex文件，执行效率较高 于Android5.0后被ART替换 Android应用程序运行在Dalvik/ART虚拟机，并且每一个应用程序对应有一个单独的Dalvik虚拟机实例。Dalvik虚拟机实则也算是一个Java虚拟机，只不过它执行的不是class文件，而是dex文件。 Dalvik虚拟机与Java虚拟机共享有差不多的特性，差别在于两者执行的指令集是不一样的，前者的指令集是基本寄存的，而后者的指令集是基于堆栈的。 栈区存储结构与运行原理 寄存器存储与运行原理 寄存器是CPU的组成部分。寄存器是有限存贮容量的高速存贮部件，它们可用来暂存指令、数据和位址。 基于寄存器的虚拟机 基于寄存器的虚拟机中没有操作数栈，但是有很多虚拟寄存器。其实和操作数栈相同，这些寄存器也存放在运行时栈中，本质上就是一个数组。与JVM相似，在Dalvik VM中每个线程都有自己的PC和调用栈，方法调用的活动记录以帧为单位保存在调用栈上。 与JVM版相比，可以发现Dalvik版程序的指令数明显减少了，数据移动次数也明显减少了。 性能对比 基于堆栈的Java指令(1个字节)和基于寄存器的Dalvik指令(2、4或者6个字节)各有优劣 一般而言，执行同样的功能，Java虚拟机需要更多的指令（主要是load和store指令），而Dalvik虚拟机需要更多的指令空间 需要更多指令意味着要多占用CPU时间，而需要更多指令空间意味着指令缓冲（i-cache）更易失效 Dalvik虚拟机使用dex（Dalvik Executable）格式的类文件，而Java虚拟机使用class格式的类文件 一个dex文件可以包含若干个类，而一个class文件只包括一个类 由于一个dex文件可以包含若干个类，因此它可以将各个类中重复的字符串只保存一次，从而节省了空间， 适合在内存有限的移动设备使用 一般来说，包含有相同类的未压缩dex文件稍小于一个已经压缩的jar文件 ART与Dalvik Dalvik虚拟机执行的是dex字节码，解释执行。从Android 2.2版本开始，支持JIT即时编译（Just In Time）在程序运行的过程中进行选择热点代码（经常执行的代码）进行编译或者优化。 而ART（Android Runtime） 是在 Android 4.4 中引入的一个开发者选项，也是 Android 5.0 及更高版本的默认 Android 运行时。ART虚拟机执行的是本地机器码。Android的运行时从Dalvik虚拟机替换成ART虚拟机，并不要求开发者将自己的应用直接编译成目标机器码，APK仍然是一个包含dex字节码的文件。 那么，ART虚拟机执行的本地机器码是从哪里来？ dex2aot Dalvik下应用在安装的过程，会执行一次优化，将dex字节码进行优化生成odex文件。而Art下将应用的dex字节码翻译成本地机器码的最恰当AOT时机也就发生在应用安装的时候。ART 引入了预先编译机制（Ahead Of Time），在安装时，ART 使用设备自带的 dex2oat 工具来编译应用，dex中的字节码将被编译成本地机器码。 Android N的运作方式 ART使用预先(AOT)编译，并且从AndroidN混合使用AOT编译，解释和JIT。 1、最初安装应用时不进行任何AOT编译（安装又快了），运行过程中解释执行，对经常执行的方法进行JIT， 经过JIT编译的方法将会记录到Profile配置文件中。 2、当设备闲置和充电时，编译守护进程会运行，根据Profile文件对常用代码进行AOT编译。待下次运行时直 接使用。 Android内存管理模型 用户空间内存管理 用户空间主要分两部分，一个是面向C++的native层，一个是基于虚拟机的java层。 native部分： ​ Data：用于保存全局变量 ​ Bss：用于保存全局未初始化变量 ​ Code：程序代码段 ​ Stack：线程函数执行的内存 ​ Heap：Malloc分配管理的内存 java基于虚拟机的内存划分: ​ ProgramCounterRegisterPC寄存器 ​ VMStack基于方法中的局部变量，包括基本数据类型及对象引用等 ​ NativeMethodStack针对native方法，与方法栈一致 ​ MethodArea虚拟机加载的类信息、常量、静态变量等 ​ Heap对象实体 ART堆的详细划分 ImageSpace：连续地址空间，不进行垃圾回收，存放系统预加载类，而这些对象是存放system@framework@boot.art@classes.oat这个OAT文件中的该文件存于data/dalvikccache目录下，每次开机启动只需把系统类映射到ImageSpace。 ZygoteSpace：连续地址空间，匿名共享内存，进行垃圾回收，管理Zygote进程在启动过程中预加载和创建的各种对象、资源。 注：ImageSpace和ZygoteSpace在Zygote进程和应用程序进程之间进行共享，而AllocationSpace就每个进程都独立地拥有一份。虽然ImageSpace和ZygoteSpace都是在Zygote进程和应用程序进程之间进行共享，但是前者的对象只创建一次，而后者的对象需要在系统每次启动时根据运行情况都重新创建一遍。 AllocationSpace与ZygoteSpace性质一致，在Zygote进程fork第一个子进程之前，就会把ZygoteSpace一分为二，原来的已经被使用的那部分堆还叫ZygoteSpace，而未使用的那部分堆就叫AllocationSpace。以后的对象都在AllocationSpace上分配。 LargeObjectSpace离散地址空间，进行垃圾回收，用来分配一些大于12K的大对象。当满足以下三个条件时，在largeobject heap上分配，否则在zygote或者allocationspace上分配： ​ 1.请求分配的内存大于等于Heap类的成员变量large_object_threshold_指定的值。 ​ 2.这个值等于3*kPageSize，即3个页面的大小 ​ 3.已经从ZygoteSpace划分出AllocationSpace，即Heap类的成员变量have_zygote_space_的值等于true。 ​ 4.被分配的对象是一个原子类型数组，即byte数组、int数组和boolean数组等。 ART的GC策略 Art的三种GC策略： StickyGC:只回收上一次GC到本次GC之间申请的内存。cms浮游垃圾 PartialGC:局部垃圾回收，除了ImageSpace和ZygoteSpace空间以外的其他内存垃圾。 FullGC:全局垃圾回收,除了ImageSpace之外的Space的内存垃圾。 策略的对比：(gcpause时间越长，对应用的影响越大) GC暂停时间：StickyGC&lt;PartialGC&lt;FullGC 回收垃圾的效率：StickyGC&gt;PartialGC&gt;FullGC 分配对象时执行GC的三个阶段 执行GC的三个阶段： 阶段一：首先会进行一次轻量级的GC，GC完成后尝试分配。如果分配失败，则选取下一个GC策略，再进行一次轻量级GC。每次GC完成后都尝试分配，直到三种GC策略都被轮询了一遍还是不能完成分配，则进入下一阶段。 阶段二：允许堆进行增长的情况下进行对象的分配。 阶段三：进行一次允许回收软引用的GC的情况下进行对象的分配。 强、软、弱、虚引用 强软弱虚（强引用、软引用、弱引用、虚引用）对应的是四种JVM回收堆内存的四种策略，不同的引用类型 有不同的回收策略。 1.强引用 普通new对象就是使用强引用，强引用必须是对象不可达情况下才会回收 2.软引用 当内存不足时，软引用会被回收，系统不足时，就算可达也会回收 3.弱引用 只要遇到垃圾回收，就会被回收掉， 4.虚引用 如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。 GC打印log分析 ART不会把所有的GC结果都输出到Logcat中。只有那些被认为执行缓慢的GC才会被输出到Logcat中。确切的说，只有GC停顿时间超过5ms或者整个GC耗时超过100ms才会被输出到Logcat中 I/art:ExplicitconcurrentmarksweepGCfreed104710(7MB)AllocSpaceobjects,21(416KB)LOSobjects,33%free, 25MB/38MB,paused1.230mstotal67.216ms 格式翻译： I/art:&lt;GC_Reason&gt;&lt;GC_Name&gt;&lt;Objects_freed&gt;(&lt;Size_freed&gt;)AllocSpaceObjects, GC_Reason&gt;触发垃圾回收的原因以及触发了何种类型的垃圾回收，它包含以下几类： Concurrent特点是不需要挂起应用线程。它在后台线程中运行，不会影响到内存的分配。(前后台切换) Alloc它在应用申请内存但是堆已满的情况下触发。在这种情况下，垃圾回收在分配内存的线程中进行。（它会导致应用停一段时间） Explicit主动发起的垃圾回收，例如System.gc()。跟dalvik一样，建议不要主动发起垃圾回收。 NativeAlloc它会在native层内存吃紧的时候发起。比如说分配Bitmap或者RenderScript内存空间不够的时候。 CollectorTransition一般由堆转换引起，垃圾回收器会把free-listback空间的所有对象都复制到bumppointer空间中。目前转换过程只在一些低内存的设备上应用所在进程从对暂停敏感切换到对暂停不敏感状态的时候发生。 HomogeneousSpaceCompact它是在free-list空间到free-list空间的复制。当app所在进程对暂停不敏感的时候发生。它可以减少内存的使用，减少内存分配的碎片化。 DisableMovingGc它并不是引起内存回收的真正原因，它是垃圾回收被GetPrimitiveCritical中断时发生的。当concurrent堆压缩正在执行的时候，因为对垃圾回收器的限制，所以非常不建议使用它。 HeapTrim它不是触发垃圾回收的原因，但是在堆压缩的时候垃圾回收会被终止。 GCName垃圾回收的名称，一共有如下几类： Concurrentmarksweep(CMS)对整个堆进行垃圾回收，除了image空间。 Concurrentpartialmarksweep对几乎整个堆进行回收，除了image空间和zynote空间。 Concurrentstickymarksweep一次普通的垃圾回收，它只负责回收上次垃圾回收之后的分配的对象。它要比Concurrentpartial marksweep执行的次数频繁的多，因为它的执行速度快，暂停时间少。 Marksweep+semispace一种非同时进行的，包含复制过程的GC。可以用来移动堆，也可以用来压缩堆（减少堆的碎片化）。 Objectsfreed释放了对象（非大对象）的数量 Sizefreed释放了空间（非大对象）的大小 Largeobjectsfreed释放了大对象的数量 Largeobjectsizefreed释放了大对象的空间的大小 Heapstats堆中空闲空间的百分比和（对象的个数）/（堆的总空间） Pausetimes一般情况下，垃圾回收的暂停时间跟堆中引用的数量成正比。目前，ARTCMSGC只有一次在垃圾回收结束的时候。 分析工具 adb:对应用进程和系统整体内存状态做一个宏观把控 dumpsysmeminfo、MemoryProfiler:操作应用程序过程中，以实时图标反馈当前内存情况，对于明显的内存抖动、内存泄漏能做一个初步分析。 eakCanary:傻瓜式内存泄漏检测工具，对于Activity与Fragment检测非常好用 MAT:内存块分析，比较全面，使用复杂 MemoryProfiler 30分钟下代码整体运行情况 MAT与性能调优（GCROOT溯源与问题分析） Mat工具的使用 转换profile文件格式 -&gt; sdk/platform-tools/hprof-conv.exe -&gt; 转换命令hprof-conv-zsrcdst 下载：https://www.eclipse.org/mat/downloads.php 打开软件File菜单下OpenHeapDump…打开转换好的文件 -&gt; 点击QQL按钮查找activity (select*frominstanceofandroid.app.Activity) 内存抖动与内存泄漏 内存抖动 内存频繁的分配与回收，（分配速度大于回收速度时）最终会产生OOM 内存泄露 一个长生命周期的对象持有一个短生命周期对象的强引用,通俗讲就是该回收的对象因为引用问题没有被回收，最终会产生OOM","categories":[],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://www.yppcat.top/tags/JVM/"}]},{"title":"堆内存解析","slug":"堆内存解析","date":"2022-11-15T13:39:21.000Z","updated":"2022-11-15T14:06:06.260Z","comments":true,"path":"2022/11/15/堆内存解析/","link":"","permalink":"http://www.yppcat.top/2022/11/15/堆内存解析/","excerpt":"","text":"运行时数据区 堆概述 1.一个JVM进程存在一个堆内存，堆是JVM内存管理的核心区域 2.java 堆区在JVM启动是被创建，其空间大小也被确定，是JVM管理的最大一块内存（堆内存大小可以调整） 3.本质上堆是一组在物理上不连续的内存空间，但是逻辑上是连续的空间（参考HSDB分析的内存结构） 4.所有线程共享堆，但是堆内对于线程处理还是做了一个线程私有的部分（TLAB） 堆的对象管理 在《JAVA虚拟机规范》中对Java堆的描述是：所有的对象示例以及数组都应当在运行时分配在堆上 但是从实际使用角度来看，不是绝对，存在某些特殊情况下的对象产生是不在堆上分配 这里请注意，规范上是绝对、实际上是相对 方法结束后,堆中的对象不会马上移除，需要通过GC执行垃圾回收后才会回收 堆的内存细分 Java7之前内存逻辑划分为： 新生区+养老区+永久区 Java8之后内存逻辑划分为： 新生去+养老区+元空间 实际上不管永久代与元空间其实都是只方法区中对于长期存在的常量对象的保存 体会堆空间的分代思想 为什么需要分代？有什么好处？ 经研究表明，不同对象的生命周期不一致，但是在具体使用过程中70%-90的对象是临时对象 分代唯一的理由是优化GC性能。如果没有分代，那么所有对象在一块空间，GC想要回收扫描他就必须扫描所有的对象，分代之后，长期持有的对象可以挑出，短期持有的对象可以固定在一个位置进行回收，省掉很大一部分空间利用 堆的默认大小 默认空间大小： 初始大小：物理电脑内存大小 / 64 最大内存大小：物理电脑内存大小 / 4 对象分配过程图示 对象生产过程自述 1.我是一个普通的java对象，我出生在Eden区，在Eden区我还看到和我长的很像的小兄弟，我们在Eden区中玩了挺长时间。 2.有一天Eden区中的人实在是太多了，我就被迫去了Survivor区的“From”区，自从去了Survivor区，我就开始了我漂泊的人生，有时候在Survivor的“From”区，有时候在Survivor的“To”区，居无定所。 3.直到我 岁的时候，爸爸说我成人了，该去社会上闯闯了。于是我就去了年老代那边，年老代里，人很多，并且年龄都挺大的，我在这里也认识了很多人。在年老代里，我生活了 年(每次GC加一岁)，然后被回收。 MinorGc、MajorGC、FullGC的区别 JVM在进行GC时，并非每次都对上面三个内存区域一起回收，大部分的只会针对于Eden区进行 在JVM标准中，他里面的GC按照回收区域划分为两种： 一种是部分采集（Partial GC ）: 新生代采集（Minor GC / YongGC）： 只采集新生代数据 老年代采集（Major GC / Old GC）： 只采集老年代数据，目前只有CMS会单独采集老年代 混合采集（Mixed GC）： 采集新生代与老年代部分数据，目前只有G1使用 一种是整堆采集（Full GC）: 收集整个堆与方法区的所有垃圾 GC触发策略 年轻代触发机制： 当年青代空间不足时，就会触发MinorGc,这里年轻代满值得是Eden区中满了 因为Java大部分对象都是具备朝生熄灭的特性，所以MinorGC非常频繁，一般回收速度也快 MinorGc会出发STW行为，暂停其他用户的线程 老年代GC触发机制： 出现MajorGC经常会伴随至少一次MinorGC(非绝对，老年代空间不足时会尝试触发 MinorGC如果空间还是不足则会出发MajorGC) MajorGC比MinorGC速度慢10倍，如果MajorGC后内存还是不足则会出现OOM FullGC触发 调用System.gc()时 老年代空间不足时 方法区空间不足时 通过MinorGC进入老年代的平均大小大于老年代的可用内存 在Eden使用Survivor进行复制时，对象大小大于Survivor的可用内存，则该对象转入老年代，且 老年代的可用内存小于该对消 Full GC 是开发或者调优中尽量要避开的 GC日志查看 -Xms9m -Xmx9m -XX:+PrintGCDetails TLAB（Thread Local Allocation Buffer） 什么是TLAB? 堆区是线程共享区，任何线程都可以访问堆中共享数据 由于对象示例的创建很频繁，在并发环境下对重划分内存空间是线程不安全的，如果需要避免多个线程对于同一地址操作，需要加锁，而加锁则会印象分配速度 所以JVM默认在堆区中开辟了一块空间，专门服务于每一个线程。他为每个线程分配了一个私有缓存区域，包含在Eden中，这就是TLAB 多线程同时分配内存是，使用TLAB可以避免一系列的非线程安全问题 TLAB会作为内存分配的首选，TLAB总空间只会占用EDEN空间的1% 一旦对象在TLAB空间分配失败，JVM会尝试使用加锁来保证数据操作的原子性，从而直接在Eden中分配 对象逃逸与代码优化 堆是分配对象存储的唯一选择吗？ 在《深入理解JAVA虚拟机》一书中，有一段这样的描述： 随着JIT编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象分配到堆上也渐渐地变得不那么“绝对”了。 ？？？？什么是栈上分配？？ 什么是标量替换？？ 什么叫逃逸分析技术？？？ 逃逸分析 逃逸： 一个对象的作用域仅限于方法区域内部在使用的情况下，此种状况叫做非逃逸 一个对象如果被外部其他类调用，或者是作用于属性中，则此种现象被称之为对象逃逸 此种行为发生在字节码被编译后JIT对于代码的进一步优化 逃逸分析案例 一个对象的作用域仅限于方法区域内部在使用的情况下，此种状况加做非逃逸 method2因为将当前sb返回出去进行使用，所以发生逃逸， 变更为methd3之后是构建一个新的String 对象，而StringBuffer对象未产生逃逸现象 逃逸分析：代码优化 使用逃逸分析，编译器可以堆代码做如下优化： 1.栈上分配：JIT编译器在编译期间根据逃逸分析计算结果，如果发现当前对象没有发生逃逸现象，那么当前对象就可能被优化成栈上分配，会将对象直接分配在栈中 2.标量替换:有的对象可能不需要作为一个连续的内存结构存在也能被访问到，那么对象部分可以不存储在内存，而是存储在CPU寄存器中 标量替换 标量：指一个无法在分解成更小的数据的数据。Java中的原始数据类型就是标量 聚合量：Java中的聚合量指的就是类，封装的行为就是聚合 标量替换：在未发生逃逸的情况下，函数内部生成的聚合量在经过JIT优化后会将其拆解为标量 逃逸分析弊端 需要进行一些列复杂的分析算法运算，相对耗时 对象的生产与对象内存分布 对象创建的几种实例化方案 1.new 2.Class.newInstance 3.Cpmstructor.newInstance(xxx) 4.obi.clone 5.反序列化 字节码看对象内存创建过程 new=方法调用 dup = 复制 invokespecial = 调用构造器 对象内存布局","categories":[],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://www.yppcat.top/tags/JVM/"}]},{"title":"Activity问题","slug":"Activity问题","date":"2022-11-15T12:50:50.000Z","updated":"2022-11-15T13:07:56.548Z","comments":true,"path":"2022/11/15/Activity问题/","link":"","permalink":"http://www.yppcat.top/2022/11/15/Activity问题/","excerpt":"","text":"Activity的启动流程 Activity跨进程启动 https://juejin.im/post/6844903959581163528#heading-1 http://gityuan.com/2016/03/12/start-activity/ 启动流程： 点击桌面App图标，Launcher进程采用Binder IPC向system_server进程发起startActivity请求； system_server进程接收到请求后，向zygote进程发送创建进程的请求； Zygote进程fork出新的子进程，即App进程； App进程，通过Binder IPC向sytem_server进程发起attachApplication请求； system_server进程在收到请求后，进行一系列准备工作后，再通过binder IPC向App进 程发送 scheduleLaunchActivity请求； App进程的binder线程（ApplicationThread）在收到请求后，通过handler向主线程发送LAUNCH_ACTIVITY消 息； 主线程在收到Message后，通过发射机制创建目标Activity，并回调Activity.onCreate()等方法。 Activity进程内启动 请求进程A：startActivity—(hook插入点1) (AMP，ActivityManager代理对象)——&gt; system_server进程： AMS(ActivityManagerService)解析Activity信息、处理启动参数、scheduleLaunchActivity/mH中EXECUTE_TRANSACTION消息处理(Android P)–&gt; 回到请求进程A：ApplicationThread –&gt; ActivityThread -(hook插入点2)-&gt; Activity生命周期 1.2.onSaveInstanceState(),onRestoreInstanceState的掉用时机 1.2.1onSaveInstanceState(Bundle outState)会在以下情况被调用： 1.2.1.1、从最近应用中选择运行其他的程序时。 1.2.1.2、当用户按下HOME键时。 1.2.1.3、屏幕方向切换时(无论竖屏切横屏还是横屏切竖屏都会调用)。 1.2.1.4、按下电源按键（关闭屏幕显示）时。 1.2.1.5、从当前activity启动一个新的activity时。 onPause -&gt; onSaveInstanceState -&gt; onStop。 1.2.2onRestoreInstanceState(Bundle outState)会在以下情况被调用：onRestoreInstanceState(Bundle savedInstanceState)只有在activity确实是被系统回收，重新创建activity的情 况下才会被调用。 1.2.2.1.屏幕方向切换时，activity生命周期如下 onPause -&gt; onSaveInstanceState -&gt; onStop -&gt; onDestroy -&gt; onCreate -&gt; onStart -&gt; onRestoreInstanceState -&gt; onResume 1.2.2.2.在后台被回收 1.2.2.3.按HOME键返回桌面,又马上点击应用图标回到原来页面时不会被回收 onStart -&gt; onRestoreInstanceState -&gt; onResume 1.2.3源码 系统会调用ActivityThread的performStopActivity方法中掉用onSaveInstanceState， 将状态保存在mActivities 中，mActivities维护了一个Activity的信息表，当Activity重启时候，会从mActivities中查询到对应的 ActivityClientRecord。 如果有信息，则调用Activity的onResoreInstanceState方法， 在ActivityThread的performLaunchActivity方法中，统会判断ActivityClientRecord对象的state是否为空 不为空则通过Activity的onSaveInstanceState获取其UI状态信息，通过这些信息传递给Activity的onCreate方 法， 1.3.activity的启动模式和使用场景 1.3.1 android任务栈 我们每次打开一个新的Activity或者退出当前Activity都会在一个称为任务栈的结构中添加或者减少一个Activity组 件，一个任务栈包含了一个activity的集合。 android通过ActivityRecord、TaskRecord、ActivityStack，ActivityStackSupervisor，ProcessRecord有序地管 理每个activity。 1.3.2 Standard 默认模式，每次启动Activity都会创建一个新的Activity实例。 1.3.3 SingleTop 通知消息打开的页面 如果要启动的Activity已经在栈顶，则不会重新创建Activity，只会调用该该Activity的onNewIntent()方法。 如果要启动的Activity不在栈顶，则会重新创建该Activity的实例。 1.3.4 SingleTask 主界面 如果要启动的Activity已经存在于它想要归属的栈中，那么不会创建该Activity实例，将栈中位于该Activity上的所 有的Activity出栈，同时该Activity的onNewIntent()方法会被调用。 1.3.5SingleInstance 呼叫来电界面要创建在一个新栈，然后创建该Activity实例并压入新栈中，新栈中只会存在这一个Activity实例。 1.4.Activity A跳转Activity B，再按返回键，生命周期执行的顺序 https://www.sohu.com/a/402329833_611601 https://www.jianshu.com/p/6d9d830a758d 在A跳转B会执行：A onPause -&gt; B onCreate -&gt; B onStart -&gt; B onResume-&gt;A onStop 在B按下返回键会执行：B onPause -&gt; A onRestart -&gt; A onStart -&gt; A onResume-&gt; B onStop -&gt; B onDestroy 当A跳转到B的时候，A先执行onPause，然后居然是B再执行onCreate -&gt; onStart -&gt; onResume，最后才执行A 的onStop!!! 当B按下返回键，B先执行onPause，然后居然是A再执行onRestart -&gt; onStart -&gt; onResume，最后才是B执行 onStop -&gt; onDestroy!!! 当 B Activity 的 launchMode 为 singleInstance，singleTask 且对应的 B Activity 有可复用的实例时，生命周期 回调是这样的: A.onPause -&gt; B.onNewIntent -&gt; B.onRestart -&gt; B.onStart -&gt; B.onResume -&gt; A.onStop -&gt; ( 如果 A 被移出栈的 话还有一个 A.onDestory) 当 B Activity 的 launchMode 为 singleTop且 B Activity 已经在栈顶时（一些特殊情况如通知栏点击、连点）， 此时只有 B 页面自己有生命周期变化: B.onPause -&gt; B.onNewIntent -&gt; B.onResume 1.5.横竖屏切换,按home键,按返回键,锁屏与解锁屏幕,跳转透明Activity界面, 启动一个 Theme 为 Dialog 的 Activity，弹出Dialog时Activity的生命周期 横竖屏切换： 从 Android 3.2 (API级别 13)开始 https://www.jianshu.com/p/dbc7e81aead2 1、不设置Activity的androidconfifigChanges，或设置Activity的androidconfifigChanges=”orientation”，或设置 Activity的android:confifigChanges=”orientation|keyboardHidden”，切屏会重新调用各个生命周期，切横屏时会执 行一次，切竖屏时会执行一次。 2、配置 android:confifigChanges=”orientation|keyboardHidden|screenSize”，才不会销毁 activity，且只调 用 onConfifigurationChanged方法。 竖屏： 启动：onCreat-&gt;onStart-&gt;onResume. 切换横屏时： onPause-&gt; onSaveInstanceState -&gt;onStop-&gt;onDestory onCreat-&gt;onStart-&gt;onSaveInstanceState-&gt;onResume. 如果配置这个属性:androidconfifigChanges=”orientation|keyboardHidden|screenSize” 就不会在调用Activity的生命周期，只会调用onConfifigurationChanged方法HOME键的执行顺序：onPause-&gt;onStop-&gt;onRestart-&gt;onStart-&gt;onResume BACK键的顺序： onPause-&gt;onStop-&gt;onDestroy-&gt;onCreate-&gt;onStart-&gt;onResume 锁屏：锁屏时只会调用onPause()，而不会调用onStop方法，开屏后则调用onResume()。 弹出 Dialog： 直接是通过 WindowManager.addView 显示的（没有经过 AMS），所以不会对生命周期有任何 影响。 启动theme为DialogActivity,跳转透明Activity A.onPause -&gt; B.onCrete -&gt; B.onStart -&gt; B.onResume （ Activity 不会回调 onStop，因为只有在 Activity 切到后台不可见才会回调 onStop） https://www.sohu.com/a/402329833_611601 1.6.onStart 和 onResume、onPause 和 onStop 的区别 onStart 和 onResume 从 Activity 可见可交互区分 onStart 用户可以看到部分activity但不能与它交互 onResume()可以获得activity的焦点，能够与用户交互 onStop 和 onPause 从 Activity 是否位于前台，是否有焦点区分 onPause表示当前页面失去焦点。 onStop表示当前页面不可见。 dialog的主题页面，这个时候，打开着一个页面，就只会执行onPause，而不会执行onStop。 1.7.Activity之间传递数据的方式Intent是否有大小限制，如果传递的数据量 偏大，有哪些方案 startActivity-&gt;startActivityForResult-&gt;Instrumentation.execStartActivity -&gt;ActivityManger.getService().startActivity intent中携带的数据要从APP进程传输到AMS进程，再由AMS进程传输到目标Activity所在进程 通过Binder来实现进程间通信 1.Binder 驱动在内核空间创建一个数据接收缓存区。 2.在内核空间开辟一块内核缓存区，建立内核缓存区和内核空间的数据接收缓存区之间的映射关系，以及内核中 数据接收缓存区和接收进程用户空间地址的映射关系。 3.发送方进程通过系统调用 copyfromuser() 将数据 copy 到内核空间的内核缓存区，由于内核缓存区和接收进程 的用户空间存在内存映射，因此也就相当于把数据发送到了接收进程的用户空间，这样便完成了一次进程间的通信。 为当使用Intent来传递数据时，用到了Binder机制，数据就存放在了Binder的事务缓冲区里面，而事务缓冲区是 有大小限制的。普通的由Zygote孵化而来的用户进程，映射的Binder内存大小是不到1M的 Binder 本身就是为了进程间频繁-灵活的通信所设计的, 并不是为了拷贝大量数据 如果非 ipc 单例,eventBus,Application,sqlite、shared preference、fifile 都可以;如果是 ipc 1.共享内存性能还不错， 通过 MemoryFile 开辟内存空间，获得 FileDescriptor； 将 FileDescriptor 传递给其他 进程； 往共享内存写入数据； 从共享内存读取数据。(https://www.jianshu.com/p/4a4bc36000fc) 2.Socket或者管道性能不太好，涉及到至少两次拷贝。 1.8.Activity的onNewIntent()方法什么时候执行 果IntentActivity处于任务栈的顶端，也就是说之前打开过的Activity，现在处于onPause、onStop 状态的话，其 他应用再发送Intent的话，执行顺序为：onNewIntent，onRestart，onStart，onResume。 ActivityA已经启动过,处于当前应用的Activity堆栈中; 当ActivityA的LaunchMode为SingleTop时，如果ActivityA在栈顶,且现在要再启动ActivityA，这时会调用 onNewIntent()方法; 当ActivityA的LaunchMode为SingleInstance,SingleTask时,如果已经ActivityA已经在堆栈中，那么此时再次启动 会调用onNewIntent()方法; 1.9.显示启动和隐式启动 显示启动 1、构造方法传入Component，最常用的方式 2、setComponent(componentName)方法 3、setClass/setClassName方法 隐式启动 https://www.jianshu.com/p/12c6253f1851 隐式Intent是通过在AndroidManifest文件中设置action、data、category，让系统来筛选出合适的Activity action的匹配规则 Intent-fifilter action可以设置多条 intent中的action只要与intent-fifilter其中的一条匹配成功即可，且intent中action最多只有一条 Intent-fifilter内必须至少包含一个action。 category的匹配规则 Intent-fifilter内必须至少包含一个category，android:name为android.intent.category.DEFAULT。 intent-fifilter中，category可以有多条 intent中，category也可以有多条 intent中所有的category都可以在intent-fifilter中找到一样的（包括大小写）才算匹配成功 data的匹配规则 intent-fifilter中可以设置多个data intent中只能设置一个dataintent-fifilter中指定了data，intent中就要指定其中的一个data 1.10.scheme使用场景,协议格式,如何使用 scheme是一种页面内跳转协议，是一种非常好的实现机制，通过定义自己的scheme协议，可以非常方便跳转 app中的各个页面 APP根据URL跳转到另外一个APP指定页面 可以通过h5页面跳转app原生页面 服务器可以定制化跳转app页面 Scheme链接格式样式 样式scheme://host/path?query Uri.parse(“hr://test:8080/goods?goodsId=8897&amp;name=test”) hr代表Scheme协议名称 test代表Scheme作用的地址域 8080代表改路径的端口号 /goods代表的是指定页面(路径) goodsId和name代表传递的两个参数 使用 掉用 1.11.ANR 的四种场景 ANR 的四种场景： Service TimeOut: service 未在规定时间执行完成：前台服务 20s，后台 200s &lt;data android:scheme=”hr” android:host=”test” android:path=”/goods” android:port=”8080”/&gt; Intent intent = new Intent(Intent.ACTION_VIEW,Uri.parse(“hr://test:8080/goods?name=test”)); startActivity(intent);BroadCastQueue TimeOut: 未在规定时间内未处理完广播：前台广播 10s 内, 后台 60s 内 ContentProvider TimeOut: publish 在 10s 内没有完成 Input Dispatching timeout: 5s 内未响应键盘输入、触摸屏幕等事件 我们可以看到， Activity 的生命周期回调的阻塞并不在触发 ANR 的场景里面，所以并不会直接触发 ANR。 只不过死循环阻塞了主线程，如果系统再有上述的四种事件发生，就无法在相应的时间内处理从而触发 ANR。 1.12.onCreate和onRestoreInstance方法中恢复数据时的区别 onSaveInstanceState 不一定会被调用，因为它只有在上次activity被回收了才会调用。 onCreate()里的Bundle参数可能为空，一定要做非空判断。 而onRestoreInstanceState的Bundle参数一定不会 是空值。 1.13.activty间传递数据的方式 通过 Intent 传递（Intent.putExtra 的内部也是维护的一个 Bundle，因此，通过 putExtra 放入的 数据，取出时 也可以通过 Bundle 去取） 通过全局变量传递 通过 SharedPreferences 传递 通过数据库传递 通过文件传递 1.14.跨App启动Activity的方式,注意事项 https://www.jianshu.com/p/ad01ac11b4f1 https://juejin.im/post/6844904056461197326#heading-0 使用intentFilter(隐式跳转) 在Manifest的Activity标签中添加： 启动时：startActivity(new Intent(“com.example.test.action.BActivity”)) 如果有两个action属性值相同的Activity，那么在启动时手机系统会让你选择启动哪一个Activity 要解决这个问题，需要给被启动的Activity再加上一个属性， 然后再启动该Activity的Intent中加上一个URI，其中“app”必须与data属性的scheme的值一样， intent=new Intent(“com.zs.appb.intent.action.BeStartActivity”, Uri.parse(“app://hello”)); 共享uid的App android中uid用于标识一个应用程序，uid在应用安装时被分配，并且在应用存在于手机上期间，都不会改变。 一个应用程序只能有一个uid，多个应用可以使用sharedUserId 方式共享同一个uid，前提是这些应用的签名要相 同。 在AndroidManifest中：manifest标签中添加android:sharedUserId=”xxxx”启动时：startActivity(new Intent().setComponent(new ComponentName(“com.example.test”,”com.example.test.XxxActivity”))); 使用exported 一旦设置了intentFilter之后，exported就默认被设置为true了 在Manifest中添加exported属性 启动时：startActivity(new Intent().setComponent(new ComponentName(“com.example.zhu”,”com.example.zhu.XxxActivity”))); 注意(如何防止自己的Activity被外部非正常启动): 如果AppB设置了android:permission=”xxx.xxx.xx”那么， 就必须在你的AppA的AndroidManifast.xml中uses\u0002 permission xxx.xxx.xx才能访问人家的东西。 给AppA的manifest中添加权限： gei AppB中需要启动的Activity添加permission属性： android:permission=”com.example.test” 1.15.Activity任务栈是什么 1.android任务栈又称为Task，它是一个栈结构，具有后进先出的特性，用于存放我们的Activity组件。 2.我们每次打开一个新的Activity或者退出当前Activity都会在一个称为任务栈的结构中添加或者减少一个Activity 组件， 一个任务栈包含了一个activity的集合, 只有在任务栈栈顶的activity才可以跟用户进行交互。 3.在我们退出应用程序时，必须把所有的任务栈中所有的activity清除出栈时,任务栈才会被销毁。当然任务栈也 可以移动到后台, 并且保留了每一个activity的状态. 可以有序的给用户列出它们的任务, 同时也不会丢失Activity的状态 信息。 4.对应AMS中的ActivityRecord、TaskRecord、ActivityStack(AMS中的总结) 1.16.有哪些Activity常用的标记位Flags FLAG_ACTIVITY_NEW_TASK 此标记位作用是为Activity指定“singleTask”启动模式，其效果和在XML中指定相同 android:launchMode=”singleTask” FLAG_ACTIVITY_SINGLE_TOP 此标记位作用是为Activity指定“singleTop”启动模式，其效果和在XML中指定相同 android:launchMode=”singleTop” FLAG_ACTIVITY_CLEAR_TOP 具有此标记位的Activity，当它启动时，在同一个任务栈中位于它上面的Activity都要出栈。此标记位一般会和 singleTask启动模式一起出现，此情况下，若被启动的Activity实例存在，则系统会调用它的onNewIntent。 1.17.Activity的数据是怎么保存的,进程被Kill后,保存的数据怎么恢复的 https://www.wanandroid.com/wenda/show/12574在Activity的onSaveInstanceState方法回调时，put到参数outState（Bundle）里面。outState就是 ActivityClientRecord的state。 ActivityClientRecord实例，都存放在ActivityThread的mActivities里面。 Activity变得不可见时（onSaveInstanceState和onStop回调之后），在应用进程这边会通过 ActivityTaskManagerService的activityStopped方法，把刚刚在onSaveInstanceState中满载了数据的Bundle对象， 传到系统服务进程那边！ 然后（在系统服务进程这边），会进一步将这个Bundle对象，赋值到对应ActivityRecord的 icicle上 ActivityRecord是用来记录对应Activity的各种信息的，如theme，启动模式、当前是否可见等等（为了排版更简 洁，上图只列出来一个icicle），它里面还有很多管理Activity状态的相关方法； TaskRecord就是大家耳熟能详的任务栈（从上图可以看出并不真的是栈）了，它的主要职责就是管理 ActivityRecord。每当Activity启动时，会先找到合适的TaskRecord（或创建新实例），然后将该Activity所对应的 ActivityRecord添加到TaskRecord的mActivities中； ActivityStack管理着TaskRecord，当新TaskRecord被创建后，会被添加到它mTaskHistory里面。","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"http://www.yppcat.top/tags/面试/"}]},{"title":"JVM底层核心技术解析","slug":"JVM底层核心技术解析","date":"2022-11-09T00:24:50.000Z","updated":"2022-11-09T12:28:19.068Z","comments":true,"path":"2022/11/09/JVM底层核心技术解析/","link":"","permalink":"http://www.yppcat.top/2022/11/09/JVM底层核心技术解析/","excerpt":"","text":"JVM是一种规范JVM从编译到执行Java程序的执行过程一个 Java 程序，首先经过 javac 编译成 .class 文件，然后 JVM 将其加载到方法区，执行引擎将会执行这些字节码。执行时，会翻译成操作系统相关的函数。JVM 作为 .class 文件的翻译存在，输入字节码，调用操作系统函数。 过程如下：Java 文件-&gt;编译器&gt;字节码-&gt;JVM-&gt;机器码。 JVM 全称 Java Virtual Machine，也就是我们耳熟能详的 Java 虚拟机。它能识别 .class后缀的文件，并且能够解析它的指令，最终调用操作系统上的函数，完成我们想要的操作。 JVM、JRE、JDK的关系JVM只是一个翻译，把Class翻译成机器识别的代码，但是需要注意，JVM 不会自己生成代码，需要大家编写代码，同时需要很多依赖类库，这个时候就需要用到JRE。 JRE是什么，它除了包含JVM之外，提供了很多的类库（就是我们说的jar包，它可以提供一些即插即用的功能，比如读取或者操作文件，连接网络，使用I/O等等之类的）这些东西就是JRE提供的基础类库。JVM 标准加上实现的一大堆基础类库，就组成了 Java 的运行时环境JRE 但对于程序员来说，JRE还不够。我写完要编译代码，还需要调试代码，还需要打包代码、有时候还需要反编译代码。所以我们会使用JDK，因为JDK还提供了一些非常好用的小工具，比如 javac（编译代码）、java、jar （打包代码）、javap（反编译&lt;反汇编&gt;）等。这个就是JDK。 具体文档可以通过官网去下载：https://www.oracle.com/java/technologies/javase-jdk8-doc-downloads.html JVM的作用是：从软件层面屏蔽不同操作系统在底层硬件和指令的不同. 同时JVM是一个虚拟化的操作系统，类似于Linux或者Windows的操作系统，只是它架在操作class 从跨平台到跨语言跨平台：我们写的一个类，在不同的操作系统上（Linux、Windows、MacOS 等平台）执行，效果是一样，这个就是JVM的跨平台性。 为了实现跨平台型，不同操作系统有对应的JDK的版本。 https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html 跨语言（语言无关性）：JVM只识别字节码，所以JVM其实跟语言是解耦的，也就是没有直接关联，JVM运行不是翻译Java文件，而是识别class文件，这个一般称之为字节码。还有像Groovy 、Kotlin、Scala等等语言，它们其实也是编译成字节码，所以它们也可以在JVM上面跑，这个就是JVM的跨语J**ava的跨语言性一定程度上奠定了非常强大的java语言生态圈**。 JVM的发展（非重点）常见的JVM实现对于Java开发来说，《Java虚拟机规范》才是最为官方、准确的一个文档，了解这个规范可以让我们更深入地理解JVM。我们平常说的JVM其实更多说的是HotSpot 规范文档如下，7版本做了中文翻译，8版本没有。 Hotspot：目前使用的最多的Java虚拟机。在命令行 java –version。它会输出你现在使用的虚拟机的名字、版本等信息、执行模式。 Jrockit：原来属于 BEA公司，曾号称世界上最快的JVM，后被Oracle公司收购，合并于Hotspot J9: IBM有自己的java虚拟机实现，它的名字叫做J9. 主要是用在IBM产品（IBM WebSphere和IBM的AIX平台上） TaobaoVM: 只有一定体量、一定规模的厂商才会开发自己的虚拟机，比如淘宝有自己的VM,它实际上是Hotspot的定制版，专门为淘宝准备的，阿里、天猫都是用的这款虚拟机。 LiquidVM: 它是一个针对硬件的虚拟机，它下面是没有操作系统的（不是Linux也不是windows）,下面直接就是硬件，运行效率比较高。 zing: 它属于zual这家公司，非常牛，是一个商业产品，很贵！它的垃圾回收速度非常快（1毫秒) 毕昇：毕昇JDK是华为内部OpenJDK定制版Huawei JDK的开源版本，是一个高性能、可用于生产环境的OpenJDK发行版。Huawei JDK运行在华为内部500多个产品上，积累了大量使用场景和java开发者反馈的问题和诉求，解决了业务实际运行中遇到的多个问题，并在ARM架构上进行了性能优化，毕昇JDK运行在大数据等场景下可以获得更好的性能。毕昇JDK 8与Java SE标准兼容，目前仅支持Linux/AArch64平台。 具体https://gitee.com/openeuler/bishengjdk-8 JVM的内存区域运行时数据区域运行时数据区的定义：Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域 Java 引以为豪的就是它的自动内存管理机制。相比于 C++的手动内存管理、复杂难以理解java的内存管理方便实用 所以要深入理解JVM必须理解内存虚拟化的概念。 在JVM中，JVM 内存主要分为堆、程序计数器、方法区、虚拟机栈和本地方法栈等。 同时按照与线程的关系也可以这么划分区域： 线程私有区域：一个线程拥有单独的一份内存区域。 线程共享区域：被所有线程共享，且只有一份。 这里还有一个直接内存，这个虽然不是运行时数据区的一部分，但是会被频繁使用。你可以理解成没有被虚拟机化的操作系统上的其他内存（比如操作系统上有8G内存，被JVM虚拟化了3G，那么还剩余5G， JVM是借助一些工具使用这5G内存的，这个内存部分称之为直接内存 JAVA方法的运行与虚拟机栈虚拟机栈是用来存放线程运行java方法所需的数据，指令、返回地址。 其实在我们实际的代码中，一个线程是可以运行多个方法的。 比如： 这段代码很简单，就是起一个main方法，在main方法运行中调用A方法，A方法中调用B方法B方法调用了C方法 我们把代码跑起来，线程1来运行这段代码， 线程1跑起来，就会有一个对应 的虚拟机栈，同时在执行每个方法的时候都会打包成一个栈帧。 比如main开始运行，打包一个栈帧送入到虚拟机栈。 C方法运行完了，C方法出栈，接着B方法运行完了，B方法出栈、接着A方法运行完了，A方法出栈，最后main方法运行完了，main方法这个栈帧就出栈了。 这个就是Java方法运行对虚拟机栈的一个影响。虚拟机栈就是用来存储线程运行方法中的数据的。而每一个方法对应一个栈帧。 虚拟机栈栈的数据结构：先进后出(FILO)的数据结构， 虚拟机栈的作用：在JVM运行过程中存储当前线程运行方法所需的数据，指令、返回地址。 虚拟机栈是基于线程的：哪怕你只有一个 main() 方法，也是以线程的方式运行的。在线程的生命周期中，参与计算的数据会频繁地入栈和出栈，栈的生命周期是和线程一样的。 虚拟机栈的大小缺省为1M，可用参数 –Xss调整大小，例如-Xss256k。 参数官方文档（JDK1.8）：https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html 栈帧：在每个 Java 方法被调用的时候，都会创建一个栈帧，并入栈。一旦方法完成相应的调用，则出栈。 栈帧大体都包含四个区域：(局部变量表、操作数栈、动态连接、返回地址) 局部变量表: 顾名思义就是局部变量的表，用于存放我们的局部变量的（方法中的变量）。首先它是一个32位的长度，主要存放我们的Java的八大基础数据类型，一般32位就可以存放下，如果是64位的就使用高低位占用两个也可以存放下，如果是局部的一些对象，比如我们的Object对象，我们只需要存放它的一个引用地址即可。 操作数据栈： 存放java方法执行的操作数的，它就是一个栈，先进后出的栈结构，操作数栈，就是用来操作的，操作的的元素可以是任意的java数据类型，所以我们知道一个方法刚刚开始的时候，这个方法的操作数栈就是空的。 操作数栈本质上是JVM执行引擎的一个工作区，也就是方法在执行，才会对操作数栈进行操作，如果代码不不执行，操作数栈其实就是空的。 动态连接: Java语言特性多态（后续章节细讲，需要结合class与执行引擎一起来讲）。 返回地址: 正常返回（调用程序计数器中的地址作为返回）、异常的话（通过异常处理器表&lt;非栈帧中&gt; 同时，虚拟机栈这个内存也不是无限大，它有大小限制，默认情况下是1M。 如果我们不断的往虚拟机栈中入栈帧，但是就是不出栈的话，那么这个虚拟机栈就会爆掉。 程序计数器较小的内存空间，当前线程执行的字节码的行号指示器；各线程之间独立存储，互不影响。 程序计数器是一块很小的内存空间，主要用来记录各个线程执行的字节码的地址，例如，分支、循环、跳转、异常、线程恢复等都依赖于计数器。 由于 Java 是多线程语言，当执行的线程数量超过 CPU 核数时，线程之间会根据时间片轮询争夺 CPU 资源。如果一个线程的时间片用完了，或者是其它原因导致这个线程的 CPU 资源被提前抢夺，那么这个退出的线程就需要单独的一个程序计数器，来记录下一条运行的指令 因为JVM是虚拟机，内部有完整的指令与执行的一套流程，所以在运行Java方法的时候需要使用程序计数器（记录字节码执行的地址或行号），如果是遇到本地方法（native方法），这个方法不是JVM来具体执行，所以程序计数器不需要记录了，这个是因为在操作系统层面也有一个程序计数器，这个会记录本地代码的执行的地址， 另外程序计数器也是JVM中唯一不会OOM(OutOfMemory)的内存区域。 栈帧执行对内存区域的影响对class进行反汇编 javap –c XXXX.class 字节码助记码解释地址：https://cloud.tencent.com/developer/article/1333540 在JVM中，基于解释执行的这种方式是基于栈的引擎，这个说的栈，就是操作数栈。 虚拟机栈： 每个线程私有的，线程在运行时，在执行每个方法的时候都会打包成一个栈帧，存储了局部变量表，操作数栈，动态链接，方法出口等信息，然后放入栈。每个时刻正在执行的当前方法就是虚拟机栈顶的栈桢。方法的执行就对应着栈帧在虚拟机栈中入栈和出栈的过程。 栈的大小缺省为1M，可用参数 –Xss调整大小，例如-Xss256k 在编译程序代码的时候，栈帧中需要多大的局部变量表，多深的操作数栈都已经完全确定了，并且写入到方法表的Code属性之中，因此一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现。 局部变量表:顾名思义就是局部变量的表，用于存放我们的局部变量的。首先它是一个32位的长度，主要存放我们的Java的八大基础数据类型，一般32位就可以存放下，如果是64位的就使用高低位占用两个也可以存放下，如果是局部的一些对象，比如我们的Object对象，我们只需要存放它的一个引用地址即可。（基本数据类型、对象引用、returnAddress类型） 操作数据栈：存放我们方法执行的操作数的，它就是一个栈，先进后出的栈结构，操作数栈，就是用来操作的，操作的的元素可以是任意的java数据类型，所以我们知道一个方法刚刚开始的时候，这个方法的操作数栈就是空的，操作数栈运行方法是会一直运行入栈/出栈的操作 动态连接**:**Java语言特性多态（需要类加载、运行时才能确定具体的方法，后续有详细的讲解）动态分派 完成出口(返回地址)**:** 正常返回：（调用程序计数器中的地址作为返回） 三步曲： 恢复上层方法的局部变量表和操作数栈、 把返回值（如果有的话）压入调用者栈帧的操作数栈中、 调整程序计数器的值以指向方法调用指令后面的一条指令、 异常的话：（通过异常处理表&lt;非栈帧中的&gt;来确定） 运行时数据区及JVM的整体内存结构本地方法栈本地方法栈跟 Java 虚拟机栈的功能类似，Java 虚拟机栈用于管理 Java 函数的调用，而本地方法栈则用于管理本地方法的调用。但本地方法并不是用 Java 实现的，而是由 C 语言实现的(比如Object.hashcode方法)。 本地方法栈是和虚拟机栈非常相似的一个区域，它服务的对象是 native 方法。你甚至可以认为虚拟机栈和本地方法栈是同一个区域。 虚拟机规范无强制规定，各版本虚拟机自由实现 ，HotSpot直接把本地方法栈和虚拟机栈合二为一 。 方法区方法区（Method Area）是可供各条线程共享的运行时内存区域。它存储了每一个类的结构信息，例如运行时常量池（Runtime Constant Pool）字段和方法数据、构造函数和普通方法的字节码内容、还包括一些在类、实例、接口初始化时用到的特殊方法 方法区是JVM对内存的“逻辑划分”，在JDK1.7及之前很多开发者都习惯将方法区称为“永久代”，是因为在HotSpot 虚拟机中，设计人员使用了永久代来实现了 JVM 规范的方法区。在JDK1.8及以后使用了元空间来实现方法区。 JVM整体知识模块 JVM能涉及非常庞大的一块知识体系，比如内存结构、垃圾回收、类加载、性能调优、JVM自身优化技术、执行引擎、类文件结构、监控工具等。 但是在所有的知识体系中，都或多或少跟内存结构有一定的关系： 比如垃圾回收回收的就是内存、类加载加载到的地方也是内存、性能优化也涉及到内存优化、执行引擎与内存密不可分、类文件结构与内存的设计有关系，监控工具也会监控内存。所以内存结构处于JVM中核心位置。也是属于我们入门JVM学习的最好的选择。 元空间方法区与堆空间类似，也是一个共享内存区，所以方法区是线程共享的。假如两个线程都试图访问方法区中的同一个类信息，而这个类还没有装入 JVM，那么此时就只允许一个线程去加载它，另一个线程必须等待。 在 HotSpot 虚拟机、Java7 版本中已经将永久代的静态变量和运行时常量池转移到了堆中，其余部分则存储在 JVM 的非堆内存中，而 Java8 版本已经将方法区中实现的永久代去掉了，并用元空间（class metadata）代替了之前的永久代，并且元空间的存储位置是本地内存。 元空间大小参数： jdk1.7及以前（初始和最大值）：-XX:PermSize；-XX:MaxPermSize； jdk1.8以后（初始和最大值）：-XX:MetaspaceSize； -XX:MaxMetaspaceSize jdk1.8以后大小就只受本机总内存的限制（如果不设置参数的话） JVM参数参考：https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html Java8 为什么使用元空间替代永久代，这样做有什么好处呢？ 官方给出的解释是： 移除永久代是为了融合 HotSpot JVM 与 JRockit VM 而做出的努力，因为 JRockit 没有永久代，所以不需要配置永久代。 永久代内存经常不够用或发生内存溢出，抛出异常 java.lang.OutOfMemoryError: PermGen。这是因为在 JDK1.7 版本中，指定的 PermGen 区大小为 8M，由于 PermGen 中类的元数据信息在每次 FullGC 的时候都可能被收集，回收率都偏低，成绩很难令人满意；还有为 PermGen 分配多大的空间很难确定，PermSize 的大小依赖于很多因素，比如，JVM 加载的 class 总数、常量池的大小和方法的大小等。 运行时常量池运行时常量池（Runtime Constant Pool）是每一个类或接口的常量池（Constant_Pool）的运行时表示形式，它包括了若干种不同的常量：从编译期可知的数值字面量到必须运行期解析后才能获得的方法或字段引用。 运行时常量池是方法区的一部分。 堆堆是 JVM 上最大的内存区域，我们申请的几乎所有的对象，都是在这里存储的。 堆空间一般是程序启动时，就申请了，但是并不一定会全部使用。堆一般设置成可伸缩的。 随着对象的频繁创建，堆空间占用的越来越多，就需要不定期的对不再使用的对象进行回收。这个在 Java 中，就叫作 GC（Garbage Collection）。 那一个对象创建的时候，到底是在堆上分配，还是在栈上分配呢？这和两个方面有关：对象的类型和在 Java 类中存在的位置。 Java 的对象可以分为基本数据类型和普通对象。 对于普通对象来说，JVM 会首先在堆上创建对象，然后在其他地方使用的其实是它的引用。比如，把这个引用保存在虚拟机栈的局部变量表中。 对于基本数据类型来说（byte、short、int、long、float、double、char)，有两种情况。 当你在方法体内声明了基本数据类型的对象，它就会在栈上直接分配。其他情况，都是在堆上分配。 堆大小参数： -Xms：堆的最小值； -Xmx：堆的最大值； -Xmn：新生代的大小； -XX:NewSize；新生代最小值； -XX:MaxNewSize：新生代最大值； 例如- Xmx256m 直接内存（堆外内存）直接内存有一种更加科学的叫法，堆外内存。 JVM 在运行时，会从操作系统申请大块的堆内存，进行数据的存储；同时还有虚拟机栈、本地方法栈和程序计数器，这块称之为栈区。操作系统剩余的内存也就是堆外内存。 它不是虚拟机运行时数据区的一部分，也不是java虚拟机规范中定义的内存区域；如果使用了NIO,这块区域会被频繁使用，在java堆内可以用directByteBuffer对象直接引用并操作； 这块内存不受java堆大小限制，但受本机总内存的限制，可以通过-XX:MaxDirectMemorySize来设置（默认与堆内存最大值一样），所以也会出现OOM异常。 小结： 1、直接内存主要是通过 DirectByteBuffer 申请的内存，可以使用参数“MaxDirectMemorySize”来限制它的大小。 2、其他堆外内存，主要是指使用了Unsafe 或者其他 JNI 手段直接直接申请的内存。 堆外内存的泄漏是非常严重的，它的排查难度高、影响大，甚至会造成主机的死亡。后续章节会详细讲。 同时，要注意**Oracle 之前计划在Java 9中去掉 sun.misc.Unsafe API**。这里删除sun.misc.Unsafe的原因之一是使Java更加安全，并且有替代方案。 目前我们主要针对的JDK1.8，JDK1.9暂时不放入讨论范围中，我们大致知道java的发展即可。 深入理解JVM的内存区域深入理解运行时数据区代码示例： JVM 向操作系统申请内存： JVM 第一步就是通过配置参数或者默认配置参数向操作系统申请内存空间，根据内存大小找到具体的内存分配表，然后把内存段的起始地址和终止地址分配给 JVM， JVM 获得内存空间后，会根据配置参数分配堆、栈以及方法区的内存大小 -Xms30m -Xmx30m -Xss1m -XX:MaxMetaspaceSize=30m 类加载（类加载的细节后续章节会讲）： 这里主要是把class放入方法区、还有class中的静态变量和常量也要放入方法区 执行方法及创建对象： 启动 main 线程，执行 main 方法，开始执行第一行代码。此时堆内存中会创建一个 student 对象，对象引用 student 就存放在栈中。 后续代码中遇到new关键字，会再创建一个 student 对象，对象引用 student 就存放在栈中。 总结一下JVM运行内存的整体流程 JVM在操作系统上启动，申请内存，先进行运行时数据区的初始化，然后把类加载到方法区中 方法的执行和退出过程在内存上的体现上就是虚拟机栈中栈帧的入栈和出栈。 同时在方法的执行过程中创建的对象一般情况下都是放在堆中，最后堆中的对象也是需要进行垃圾回收清理的。 从底层深入理解运行时数据区堆空间分代划分堆被划分为新生代和老年代（Tenured），新生代又被进一步划分为 Eden 和 Survivor 区，最后 Survivor 由 From Survivor 和 To Survivor 组成。 （先需要有概念，后续对象分配和垃圾回收会细讲这块） GC概念GC- Garbage Collection 垃圾回收，在JVM中是自动化的垃圾回收机制，我们一般不用去关注，在JVM中GC的重要区域是堆空间。 我们也可以通过一些额外方式主动发起它，比如System.gc(),主动发起。（项目中切记不要使用） JHSDB工具JHSDB是一款基于服务性代理实现的进程外调试工具。 JDK1.8的开启方式开启HSDB工具 Jdk1.8启动JHSDB的时候必须将sawindbg.dll（一般会在JDK的目录下）复制到对应目录的jre下(注意在win上安装了JDK1.8后往往同级目录下有一个jre的目录) 然后到目录：C:\\Program Files\\Java\\jdk1.8.0_101\\lib 进入命令行，执行 java -cp .\\sa-jdi.jar sun.jvm.hotspot.HSDB JDK1.9及以后的开启方式进入JDK的bin目录下，我们可以在命令行中使用 jhsdb hsdb 来启动它 代码改造VM参数加入： -XX:+UseConcMarkSweepGC -XX:-UseCompressedOops JHSDB中查看对象实例代码启动 因为JVM启动有一个进程，需要借助一个命令 jps查找到对应程序的进程 在JHSDB工具中attach上去 JHSDB中查看对象查看堆参数： 上图中可以看到实际JVM启动过程中堆中参数的对照，可以看到，在不启动内存压缩的情况这是一篇连续的内存地址 再来查看对象： 这里可以看到JVM中所有的对象，都是基于class的对象 全路径名搜索 双击出现这个Teacher类的对象，两个，就是T1和T2对象。 最后再对比一下堆中分代划分可以得出为什么T1在Eden,T2在老年代 JHSDB中查看栈 从上图中可以验证栈内存，同时也可以验证到虚拟机栈和本地方法栈在Hotspot中是合二为一 当我们通过 Java 运行以上代码时，JVM 的整个处理过程如下： JVM 向操作系统申请内存，JVM 第一步就是通过配置参数或者默认配置参数向操作系统申请内存空间。 JVM 获得内存空间后，会根据配置参数分配堆、栈以及方法区的内存大小。 完成上一个步骤后， JVM 首先会执行构造器，编译器会在.java 文件被编译成.class 文件时，收集所有类的初始化代码，包括静态变量赋值语句、静态代码块、静态方法，静态变量和常量放入方法区 执行方法。启动 main 线程，执行 main 方法，开始执行第一行代码。此时堆内存中会创建一个 Teacher 对象，对象引用 student 就存放在栈中。 执行其他方法时，具体的操作：栈帧执行对内存区域的影响。栈帧执行对内存区域的影响 内存溢出（重点）栈溢出参数：-Xss1m， 具体默认值需要查看官网：[https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html#BABHDABI HotSpot版本中栈的大小是固定的，是不支持拓展的。 java.lang.StackOverflowError一般的方法调用是很难出现的，如果出现了可能会是无限递归。 虚拟机栈带给我们的启示：方法的执行因为要打包成栈桢，所以天生要比实现同样功能的循环慢，所以树的遍历算法中：递归和非递归(循环来实现)都有存在的意义。递归代码简洁，非递归代码复杂但是速度较快。 OutOfMemoryError：不断建立线程，JVM申请栈内存，机器没有足够的内存。 同时要注意，栈区的空间JVM没有办法去限制的，因为JVM在运行过程中会有线程不断的运行，没办法限制，所以只限制单个虚拟机栈的大小。 堆溢出内存溢出：申请内存空间,超出最大堆内存空间。 如果是内存溢出，则通过 调大 -Xms，-Xmx参数。 如果不是内存泄漏，就是说内存中的对象却是都是必须存活的，那么久应该检查JVM的堆参数设置，与机器的内存对比，看是否还有可以调整的空间，再从代码上检查是否存在某些对象生命周期过长、持有状态时间过长、存储结构设计不合理等情况。 方法区溢出（1） 运行时常量池溢出 （2）方法区中保存的Class对象没有被及时回收掉或者Class信息占用的内存超过了我们配置。 注意Class要被回收，条件比较苛刻（仅仅是可以，不代表必然，因为还有一些参数可以进行设置 该类所有的实例都已经被回收，也就是堆中不存在该类的任何实例。 加载该类的ClassLoader已经被回收。 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该 代码示例： cglib是一个强大的，高性能，高质量的Code生成类库，它可以在运行期扩展Java类与实现Java接口。 CGLIB包的底层是通过使用一个小而快的字节码处理框架ASM，来转换字节码并生成新的类。除了CGLIB包，脚本语言例如Groovy和BeanShell，也是使用ASM来生成java的字节码。当然不鼓励直接使用ASM。 本机直接内存溢出直接内存的容量可以通过MaxDirectMemorySize来设置（默认与堆内存最大值一样），所以也会出现OOM异常； 由直接内存导致的内存溢出，一个比较明显的特征是在HeapDump文件中不会看见有什么明显的异常情况，如果发生了OOM，同时Dump文件很小，可以考虑重点排查下直接内存方面的原因","categories":[],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://www.yppcat.top/tags/JVM/"}]},{"title":"kotlin笔记-标准函数","slug":"kotlin笔记-标准函数","date":"2021-12-08T14:59:06.000Z","updated":"2021-12-08T15:14:46.728Z","comments":true,"path":"2021/12/08/kotlin笔记-标准函数/","link":"","permalink":"http://www.yppcat.top/2021/12/08/kotlin笔记-标准函数/","excerpt":"","text":"let函数会将参数传入到lambda作用域中，返回作用域的最后一行1234val res = listOf(1,2,3).first().let &#123; it * it&#125;println(res) also函数会返回接收者对象，作用域和功能类似，传入参数12345678val s = \"hello\"var m = \"\"s.also &#123; println(it)&#125;.also &#123; m = it.uppercase()&#125;println(m) apply函数会返回接受者对象并执行lambda中的内容，作用域中不需要再写当前参数1234val s = \"hello\".apply &#123; capitalize()&#125;println(s) run函数和apply作用域一样，但是返回lambda的结果，此外run还可以用来执行函数(链式调用也可以)123456789101112131415161718192021222324fun main()&#123; val res = \"hello\".run &#123; length &#125; println(res) \"The people of china\" .run(::isTooLong) .run(::showMessage)&#125;fun isTooLong(name : String) = name.length &gt;= 10fun showMessage(isLong: Boolean) :String&#123; return if (isLong)&#123; println(\"name is too long\") \"name is too long\" &#125;else&#123; println(\"Please rename\") \"Please rename\" &#125;&#125; with函数功能和run一样，但是需要将值参作为第一个参数传入1234567fun main()&#123; val isTooLong = with(\"The people of China\")&#123; length &gt; 10 &#125; println(isTooLong)&#125; takeIf函数的lambda作用域和let相似，此函数需要在lambda作用域中给出true或者false ，true返回当前的对象，false返回NulltakeUnless对于lambda的结果处理与之相反123456789101112131415161718192021fun main() &#123; var isLong = \"The people of China\" .takeIf &#123; it.length &gt;= 10 &#125; ?.length println(isLong) //等价于上面 val str = \"The people of China\" isLong = if (str.length &gt;= 10) &#123; str.length &#125; else &#123; null &#125; println(isLong) isLong = str .takeUnless &#123; it.length &lt;= 10 &#125; ?.length println(isLong)&#125;","categories":[],"tags":[{"name":"kotlin","slug":"kotlin","permalink":"http://www.yppcat.top/tags/kotlin/"}]},{"title":"kotlin笔记-列表","slug":"kotlin笔记","date":"2021-12-08T14:18:06.000Z","updated":"2021-12-08T14:59:33.174Z","comments":true,"path":"2021/12/08/kotlin笔记/","link":"","permalink":"http://www.yppcat.top/2021/12/08/kotlin笔记/","excerpt":"","text":"kotlin普通列表1234val list = listOf(\"jack\", \"lucy\", \"black\")println(list.getOrElse(4) &#123; \"UnKnown\" &#125;)println(list.getOrNull(4) ?: \"UnKnown\")println(list[2]) list的for each循环1234567891011121314151617val list = listOf(\"jack\", \"jimmy\", \"jason\")for (s in list) &#123; println(s)&#125;list.forEach &#123; println(it)&#125;list.forEachIndexed &#123; index, s -&gt; println(\"$index $s\")&#125;//此处的_参数被过滤掉，name proxy依次赋值0 1个元素val (name,_,proxy) = listOf(\"jack\",\"jimmy\",\"jason\",\"jacky\")println(\"name = $name proxy = $proxy\") map列表12345678910111213141516171819202122//此处用了infix函数val map = mapOf(\"jack\" to 20, \"jimmy\" to 18, \"jason\" to 24)println(map)//pair是map的子元素val sMap = mapOf(Pair(\"jack\", 20), Pair(\"jimmy\", 18), Pair(\"json\", 24))println(map[\"jack\"])println(sMap[\"jimmy\"])//println(map.getOrElse(\"jimmy\") &#123; \"UnKnown\" &#125;)println(map.getOrDefault(\"jason\") &#123; \"UnKnown\" &#125;)//map的遍历map.forEach &#123; println(\"$&#123;it.key&#125; $&#123;it.value&#125;\")&#125;//map的遍历map.forEach &#123; (key, value) -&gt; println(\"key = $key value = $value\")&#125; kotlin可变列表MutableList1234567val mutableList = mutableListOf(\"jack\", \"jimmy\", \"jacky\")mutableList.add(\"jason\")mutableList.remove(\"jack\")println(mutableList)listOf(\"a\", \"b\", \"c\").toMutableList()mutableListOf(\"m\", \"n\", \"o\").toList() kotlin可变列表MutableMap1234567891011val mutableMap = mutableMapOf(\"Jack\" to 20, \"Jason\" to 18, \"Jacky\" to 30)//此处用到了操作符重载mutableMap += \"jimmy\" to 1000mutableMap.put(\"lucas\", 31)mutableMap[\"lucy\"] = 30mutableMap.getOrPut(\"lily\")&#123; 100 &#125;val i = mutableMap.getOrPut(\"jimmy\")&#123; 100 &#125;println(mutableMap)println(i) set列表 1234567val mutableSet = mutableSetOf(\"Kotlin\", \"Java\", \"Scala\")mutableSet += \"Groovy\"println(listOf(\"Jack\", \"Jason\", \"Jacky\",\"Jacky\").toSet().toList())//去重的快捷函数println(listOf(\"Jack\", \"Jason\", \"Jacky\",\"Jacky\").distinct())","categories":[],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://www.yppcat.top/tags/Kotlin/"}]},{"title":"Activity启动流程","slug":"Activity启动流程","date":"2020-07-29T03:40:07.000Z","updated":"2020-07-29T11:26:34.776Z","comments":true,"path":"2020/07/29/Activity启动流程/","link":"","permalink":"http://www.yppcat.top/2020/07/29/Activity启动流程/","excerpt":"","text":"我们看一下startActivity方法中到底发生了什么： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 @Override public void startActivity(Intent intent) &#123; this.startActivity(intent, null); &#125;@Override public void startActivity(Intent intent, @Nullable Bundle options) &#123; if (options != null) &#123; startActivityForResult(intent, -1, options); &#125; else &#123; // Note we want to go through this call for compatibility with // applications that may have overridden the method. startActivityForResult(intent, -1); &#125; &#125;public void startActivityForResult(@RequiresPermission Intent intent, int requestCode, @Nullable Bundle options) &#123; if (mParent == null) &#123; options = transferSpringboardActivityOptions(options); Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity( this, mMainThread.getApplicationThread(), mToken, this, intent, requestCode, options); if (ar != null) &#123; mMainThread.sendActivityResult( mToken, mEmbeddedID, requestCode, ar.getResultCode(), ar.getResultData()); &#125; if (requestCode &gt;= 0) &#123; // If this start is requesting a result, we can avoid making // the activity visible until the result is received. Setting // this code during onCreate(Bundle savedInstanceState) or onResume() will keep the // activity hidden during this time, to avoid flickering. // This can only be done when a result is requested because // that guarantees we will get information back when the // activity is finished, no matter what happens to it. mStartedActivity = true; &#125; cancelInputsAndStartExitTransition(options); // TODO Consider clearing/flushing other event sources and events for child windows. &#125; else &#123; if (options != null) &#123; mParent.startActivityFromChild(this, intent, requestCode, options); &#125; else &#123; // Note we want to go through this method for compatibility with // existing applications that may have overridden it. mParent.startActivityFromChild(this, intent, requestCode); &#125; &#125; &#125; 可以看到最终都会走到上述的方法中，我们关注一下mParent==null这种情况，上面的ApplicationThread其实是ActivityThread的一个内部类，我们看下execStartActivity方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344public ActivityResult execStartActivity( Context who, IBinder contextThread, IBinder token, Activity target, Intent intent, int requestCode, Bundle options) &#123; IApplicationThread whoThread = (IApplicationThread) contextThread; Uri referrer = target != null ? target.onProvideReferrer() : null; if (referrer != null) &#123; intent.putExtra(Intent.EXTRA_REFERRER, referrer); &#125; if (mActivityMonitors != null) &#123; synchronized (mSync) &#123; final int N = mActivityMonitors.size(); for (int i=0; i&lt;N; i++) &#123; final ActivityMonitor am = mActivityMonitors.get(i); ActivityResult result = null; if (am.ignoreMatchingSpecificIntents()) &#123; result = am.onStartActivity(intent); &#125; if (result != null) &#123; am.mHits++; return result; &#125; else if (am.match(who, null, intent)) &#123; am.mHits++; if (am.isBlocking()) &#123; return requestCode &gt;= 0 ? am.getResult() : null; &#125; break; &#125; &#125; &#125; &#125; try &#123; intent.migrateExtraStreamToClipData(); intent.prepareToLeaveProcess(who); int result = ActivityManager.getService() .startActivity(whoThread, who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, target != null ? target.mEmbeddedID : null, requestCode, 0, null, options); checkStartActivityResult(result, intent); &#125; catch (RemoteException e) &#123; throw new RuntimeException(\"Failure from system\", e); &#125; return null; &#125; 可以看到最终都是由ActivityManager.getService()的startActivity方法来完成的","categories":[],"tags":[{"name":"android","slug":"android","permalink":"http://www.yppcat.top/tags/android/"}]},{"title":"Okhttp源码分析","slug":"Okhttp源码分析","date":"2020-07-27T09:10:53.000Z","updated":"2020-07-28T10:11:11.552Z","comments":true,"path":"2020/07/27/Okhttp源码分析/","link":"","permalink":"http://www.yppcat.top/2020/07/27/Okhttp源码分析/","excerpt":"","text":"首先看Okhttp发起一个异步的请求： 123456789101112131415161718192021222324private void testOkHttp() &#123; OkHttpClient okHttpClient = new OkHttpClient.Builder().build(); //构造 OkHttpClient Request request = new Request.Builder() .get() //Method GET .url(\"www.baidu.com\") .build(); //构造请求信息 okHttpClient.newCall(request) .enqueue(new Callback() &#123; //发起异步请求 @Override public void onResponse(final Call call, final Response response) throws IOException &#123; //成功拿到响应 int code = response.code(); ResponseBody body = response.body(); String string = body.string(); &#125; @Override public void onFailure(final Call call, final IOException e) &#123; e.printStackTrace(); &#125; &#125;); &#125; 我们看下newCall方法， 123@Override public Call newCall(Request request) &#123; return new RealCall(this, request); &#125; newCall(Request) 方法调用了 RealCall.newRealCall() 方法，这个 RealCall.newRealCall() 方法创建了一个新的RealCall对象，这个RealCall是okhttp3.Call` 接口的一个实现。 1234567891011121314151617181920212223public interface Call extends Cloneable &#123; //返回这个请求关联的 Request 对象 Request request(); //立即执行请求，阻塞等待拿到响应 Response execute() throws IOException; //请求入队，异步执行 void enqueue(Callback responseCallback); //取消一个请求 void cancel(); boolean isExecuted(); boolean isCanceled(); Call clone(); interface Factory &#123; Call newCall(Request request); &#125;&#125; 可以看到，我们前面发起异步请求的 enqueue() 方法是定义在 Call 中的。 12okHttpClient.newCall(request) .enqueue(new Callback() &#123; ...&#125;); //原来就是 Call 的方法 在 OkHttp 中，Call 的唯一实现就是 RealCall，它表示一个准备好被执行的请求。和 Request 不同在于，它还提供了发起请求、取消等方法。 拿到 OkHttp.Call 的实例、RealCall 对象后，我们调用了它的 enqueue() 方法： 12345678910//RealCall.enqueue()@Override public void enqueue(Callback responseCallback) &#123; synchronized (this) &#123; if (executed) throw new IllegalStateException(\"Already Executed\"); executed = true; &#125; captureCallStackTrace(); eventListener.callStart(this); client.dispatcher().enqueue(new AsyncCall(responseCallback));&#125; 核心就在最后这句 client.dispatcher().enqueue(new AsyncCall(responseCallback));，它做了两件事： 创建一个 AsyncCall 对象 调用 Dispatcher.enqueue() 方法将请求入队 先看下 AsyncCall 是何方神圣： 123456789101112131415161718192021222324final class AsyncCall extends NamedRunnable &#123; private final Callback responseCallback; AsyncCall(Callback responseCallback) &#123; super(\"OkHttp %s\", redactedUrl()); this.responseCallback = responseCallback; &#125; String host() &#123; //用于标识这个请求 return originalRequest.url().host(); &#125; Request request() &#123; return originalRequest; &#125; RealCall get() &#123; return RealCall.this; &#125; @Override protected void execute() &#123; //... &#125;&#125; 可以看到， AsyncCall 就是一个 Runnable，用于异步执行任务。 接着看 client.dispatcher() 方法，它返回一个调度器 Dispatcher，这是 OkHttp 中比较核心的一个类： 1234567891011121314151617181920212223242526272829303132public final class Dispatcher &#123; private int maxRequests = 64; //同时最多发起 64 个请求 private int maxRequestsPerHost = 5; //同一 host 最多发起 5 个请求 private @Nullable Runnable idleCallback; private @Nullable ExecutorService executorService; //将会异步创建的线程池 //等待被执行的异步请求队列 private final Deque&lt;AsyncCall&gt; readyAsyncCalls = new ArrayDeque&lt;&gt;(); //正在运行的异步请求队列（其中也包括取消后没有完成的请求） private final Deque&lt;AsyncCall&gt; runningAsyncCalls = new ArrayDeque&lt;&gt;(); //正在运行的同步请求队列 private final Deque&lt;RealCall&gt; runningSyncCalls = new ArrayDeque&lt;&gt;(); public Dispatcher(ExecutorService executorService) &#123; this.executorService = executorService; &#125; public Dispatcher() &#123; &#125; public synchronized ExecutorService executorService() &#123; if (executorService == null) &#123; executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(\"OkHttp Dispatcher\", false)); &#125; return executorService; &#125; //...&#125; 在一个 OkHttpClient 中一般只有一个 Dispatcher，因此一个 OkHttpClient 能发起的最多请求就是 Dispatcher 中定义的 64 个 同样，同一 host 能发起的最多请求是 5 个 Dispatcher 中用三个队列保存同步、异步请求 默认线程池核心线程数量为 0，最多数量不限制，消息队列为 SynchronousQueue，因此有请求时会不断创建新线程 接着我们看一下NamedRunnable 的execute在AsyncCall的实现 12345678910111213141516171819202122@Override protected void execute() &#123; boolean signalledCallback = false; try &#123; Response response = getResponseWithInterceptorChain(forWebSocket); if (canceled) &#123; signalledCallback = true; responseCallback.onFailure(RealCall.this, new IOException(\"Canceled\")); &#125; else &#123; signalledCallback = true; responseCallback.onResponse(RealCall.this, response); &#125; &#125; catch (IOException e) &#123; if (signalledCallback) &#123; // Do not signal the callback twice! logger.log(Level.INFO, \"Callback failure for \" + toLoggableString(), e); &#125; else &#123; responseCallback.onFailure(RealCall.this, e); &#125; &#125; finally &#123; client.dispatcher().finished(this); &#125; &#125; 可以看到，这个方法中先通过 getResponseWithInterceptorChain() 方法拿到了响应 Response，然后进行了回调，最后在 finally 代码块中调用了 client.dispatcher().finished(this) 方法，这个方法的作用是从调度器 Dispatcher 里移除当前这个请求，执行下一个。 我们重点看 getResponseWithInterceptorChain() 方法， 12345678910111213141516171819Response getResponseWithInterceptorChain() throws IOException &#123; // Build a full stack of interceptors. List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;(); interceptors.addAll(client.interceptors()); interceptors.add(retryAndFollowUpInterceptor); interceptors.add(new BridgeInterceptor(client.cookieJar())); interceptors.add(new CacheInterceptor(client.internalCache())); interceptors.add(new ConnectInterceptor(client)); if (!forWebSocket) &#123; interceptors.addAll(client.networkInterceptors()); &#125; interceptors.add(new CallServerInterceptor(forWebSocket)); Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0, originalRequest, this, eventListener, client.connectTimeoutMillis(), client.readTimeoutMillis(), client.writeTimeoutMillis()); return chain.proceed(originalRequest); &#125; 小结至此我们对 OkHttp 如何发起请求、逐层处理、拿到响应有了一个基本的认识，三句话概括一下： 发起异步请求后会构造异步任务 AsyncCall 入队，等被执行时会调用它的 execute() 方法 这个执行方法会通过拦截器链，挨个调用我们自定义的和系统内置的 5 个拦截器，对请求信息和响应做处理，最后返回结果，回调我们传入的参数 然后从队列中移除当前任务，执行下一个，以此循环","categories":[],"tags":[{"name":"android","slug":"android","permalink":"http://www.yppcat.top/tags/android/"}]},{"title":"Java线程状态","slug":"Java线程状态","date":"2020-07-17T05:32:23.000Z","updated":"2020-07-17T06:06:05.484Z","comments":true,"path":"2020/07/17/Java线程状态/","link":"","permalink":"http://www.yppcat.top/2020/07/17/Java线程状态/","excerpt":"","text":"线程的 6 种状态就像生物从出生到长大、最终死亡的过程一样，线程也有自己的生命周期，在 Java 中线程的生命周期中一共有 6 种状态。 New（新创建） Runnable（可运行） Blocked（被阻塞） Waiting（等待） Timed Waiting（计时等待） Terminated（被终止） 如果想要确定线程当前的状态，可以通过 getState() 方法，并且线程在任何时刻只可能处于 1 种状态。 New 新创建New 表示线程被创建但尚未启动的状态：当我们用 new Thread() 新建一个线程时，如果线程没有开始运行 start() 方法，所以也没有开始执行 run() 方法里面的代码，那么此时它的状态就是 New。而一旦线程调用了 start()，它的状态就会从 New 变成 Runnable。 Runnable 可运行Java 中的 Runable 状态对应操作系统线程状态中的两种状态，分别是 Running 和 Ready，也就是说，Java 中处于 Runnable 状态的线程有可能正在执行，也有可能没有正在执行，正在等待被分配 CPU 资源。 所以，如果一个正在运行的线程是 Runnable 状态，当它运行到任务的一半时，执行该线程的 CPU 被调度去做其他事情，导致该线程暂时不运行，它的状态依然不变，还是 Runnable，因为它有可能随时被调度回来继续执行任务。 Blocked 被阻塞从 Runnable 状态进入 Blocked 状态只有一种可能，就是进入 synchronized 保护的代码时没有抢到 monitor 锁，无论是进入 synchronized 代码块，还是 synchronized 方法，都是一样。 Waiting 等待我们再看看 Waiting 状态，线程进入 Waiting 状态有三种可能性。 没有设置 Timeout 参数的 Object.wait() 方法。 没有设置 Timeout 参数的 Thread.join() 方法。 LockSupport.park() 方法。 刚才强调过，Blocked 仅仅针对 synchronized monitor 锁，可是在 Java 中还有很多其他的锁，比如 ReentrantLock，如果线程在获取这种锁时没有抢到该锁就会进入 Waiting 状态，因为本质上它执行了 LockSupport.park() 方法，所以会进入 Waiting 状态。同样，Object.wait() 和 Thread.join() 也会让线程进入 Waiting 状态。 Blocked 与 Waiting 的区别是 Blocked 在等待其他线程释放 monitor 锁，而 Waiting 则是在等待某个条件，比如 join 的线程执行完毕，或者是 notify()/notifyAll() 。 Timed Waiting 限期等待在 Waiting 上面是 Timed Waiting 状态，这两个状态是非常相似的，区别仅在于有没有时间限制，Timed Waiting 会等待超时，由系统自动唤醒，或者在超时前被唤醒信号唤醒。 以下情况会让线程进入 Timed Waiting 状态。 设置了时间参数的 Thread.sleep(long millis) 方法； 设置了时间参数的 Object.wait(long timeout) 方法； 设置了时间参数的 Thread.join(long millis) 方法； 设置了时间参数的 LockSupport.parkNanos(long nanos) 方法和 LockSupport.parkUntil(long deadline) 方法。 Terminated 终止再来看看最后一种状态，Terminated 终止状态，要想进入这个状态有两种可能。 run() 方法执行完毕，线程正常退出。 出现一个没有捕获的异常，终止了 run() 方法，最终导致意外终止。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.yppcat.top/tags/Java/"}]},{"title":"JNIEnv实现原理","slug":"JNIEnv实现原理","date":"2020-03-18T12:55:54.000Z","updated":"2020-03-18T12:57:35.774Z","comments":true,"path":"2020/03/18/JNIEnv实现原理/","link":"","permalink":"http://www.yppcat.top/2020/03/18/JNIEnv实现原理/","excerpt":"","text":"` #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt;typedef const struct JNINativeInterface *JNIEnv; struct JNINativeInterface{ //方法指针 const char(NewStringUTF)(JNIEnv,const char);}; //方法实现const char NewStringUTF(JNIEnv env, const char* c_str) { return c_str; } const char Java_com_yppcat_ndk_NdkSimple_getStr(JNIEnv env) { return (*env)-&gt;NewStringUTF(env, &quot;940223&quot;); } void main() { 1234567struct JNINativeInterface nativeInterface;nativeInterface.NewStringUTF = NewStringUTF;//给方法指针赋值JNIEnv env = &amp;nativeInterface; //JniEnv本身就是一级指针JNIEnv* jniEnv = &amp;env;const char* jString = Java_com_yppcat_ndk_NdkSimple_getStr(jniEnv);printf(\"jString = %s \", jString);getchar(); }`","categories":[],"tags":[{"name":"Ndk","slug":"Ndk","permalink":"http://www.yppcat.top/tags/Ndk/"}]},{"title":"Ndk开发步骤","slug":"Ndk开发步骤","date":"2020-03-17T13:41:13.000Z","updated":"2020-03-17T14:04:29.000Z","comments":true,"path":"2020/03/17/Ndk开发步骤/","link":"","permalink":"http://www.yppcat.top/2020/03/17/Ndk开发步骤/","excerpt":"","text":"step1: step2 : javah -c ../jni com\\yppcat\\ndk\\NdkSimple.java 生成需要的头文件 step3: 拷贝jni.h和jni_md.h到vs中 step4: 生成需要的方法 step5:加载本地路径运行","categories":[],"tags":[{"name":"NDK","slug":"NDK","permalink":"http://www.yppcat.top/tags/NDK/"}]},{"title":"视频基础概念","slug":"视频基础概念","date":"2019-11-02T12:57:16.000Z","updated":"2019-11-03T02:53:37.048Z","comments":true,"path":"2019/11/02/视频基础概念/","link":"","permalink":"http://www.yppcat.top/2019/11/02/视频基础概念/","excerpt":"","text":"1.H264 : IBP帧概念 2.GOF : 两个I帧的间隔（一组帧） 3.SPS ： 序列参数集，一组帧的存放帧数、参考帧数目。。。 4.PPS ： 图像参数集，存放编码模式选择标识、片组数目。。。 编码器 ：x264、x265(cpu占用过高)、openH264(svc分层传输，硬编不兼容)、vp8、vp9 H264压缩：帧内压缩、帧间压缩、整数离散余弦变换（傅里叶变换）、CABAC压缩 H264编码分层 码流：SODB、RBSP、EBSP、NALU YUV图像存储格式","categories":[],"tags":[{"name":"音视频","slug":"音视频","permalink":"http://www.yppcat.top/tags/音视频/"}]},{"title":"内存泄漏的原因和解决方式","slug":"内存泄漏的原因和解决方式","date":"2019-08-26T13:39:00.000Z","updated":"2019-08-27T14:44:59.039Z","comments":true,"path":"2019/08/26/内存泄漏的原因和解决方式/","link":"","permalink":"http://www.yppcat.top/2019/08/26/内存泄漏的原因和解决方式/","excerpt":"","text":"1.Handler引起的内存泄漏（生命周期长的持有了生命周期短的引用） 2.Bitmap对象使用结束没有使用recycle释放内存 12val bitmap = BitmapFactory.decodeResource(resources,R.drawable.ic_launcher)bitmap.recycle() 3.cursor的释放 12val cursor = contentResolver.query(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,null,null,null,null)cursor?.close() 4.BroadcastReceiver、EventBus、RxBus等注册未取消监听 5.单例模式构造引用的context对象：public class Utils { private static Utils instance; private Context context; public static Utils getInstance(Context context) { if (instance == null) { synchronized (Utils.class) { instance = new Utils(context.getApplicationContext()); } } return instance; } private Utils(Context context) { this.context = context; } }","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"http://www.yppcat.top/tags/面试/"}]},{"title":"Activity和Fragment通信","slug":"Activity和Fragment通信","date":"2019-08-23T14:19:48.000Z","updated":"2019-08-23T14:36:57.087Z","comments":true,"path":"2019/08/23/Activity和Fragment通信/","link":"","permalink":"http://www.yppcat.top/2019/08/23/Activity和Fragment通信/","excerpt":"","text":"Activity和Fragment通信的几种方式： 1.接口的方式： 1234567891011121314151617class MainFragment : Fragment() &#123; private lateinit var name : String fun setName(name : String)&#123; this.name = name &#125; override fun onCreateView( inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle? ): View? &#123; return inflater.inflate(R.layout.fragment_main, container, false) &#125;&#125; 123456789101112class MainActivity : AppCompatActivity() &#123; private lateinit var mainFragment: MainFragment override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) mainFragment = MainFragment() mainFragment.setName(&quot;Hello&quot;) &#125;&#125; 2.Bundle的方式： 123456789101112131415class MainFragment private constructor() : Fragment() &#123; private lateinit var name: String private lateinit var mainFragment: MainFragment companion object &#123; private lateinit var mainFragment: MainFragment fun newInstance(bundle: Bundle): MainFragment &#123; mainFragment = MainFragment() mainFragment.arguments = bundle return mainFragment &#125; &#125; &#125; 3.广播方式 4.eventBus、RxBus等事件 5.文件（File、SharedPreference方式等）","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"http://www.yppcat.top/tags/面试/"}]},{"title":"自定义 Handler 时如何有效地避免内存泄漏问题","slug":"自定义-Handler-时如何有效地避免内存泄漏问题","date":"2019-08-22T14:17:26.000Z","updated":"2019-08-22T14:50:31.995Z","comments":true,"path":"2019/08/22/自定义-Handler-时如何有效地避免内存泄漏问题/","link":"","permalink":"http://www.yppcat.top/2019/08/22/自定义-Handler-时如何有效地避免内存泄漏问题/","excerpt":"","text":"我们在使用Handler时通常都会按照如下方式创建Handler： 123456val handler : Handler = object : Handler() &#123; override fun handleMessage(msg: Message) &#123; super.handleMessage(msg) &#125;&#125; 因为在java中非静态内部类会持有外部类的引用，所以内部类可以使用外部类的属性。但是Handler通常会被用来做延迟操作，这就可能导致Handler的生命周期比它外部组件的生命周期还要长，导致它引用的组件无法及时的被销毁，从而造成内存的泄露。 解决的方法： 1.保证Activity被finish()时该线程的消息队列没有这个Activity的handler内部类的引用。这个场景是及其常见的，因为handler经常被用来发延时消息。一个补救的办法就是在该类需要回收的时候，手动地把消息队列中的消息清空：handler.removeCallbacksAndMessages(null);让handler销毁， 以Activity为例如下： 1234567891011val handler : Handler = object : Handler() &#123; override fun handleMessage(msg: Message) &#123; super.handleMessage(msg) &#125;&#125;override fun onDestroy() &#123; super.onDestroy() handler.removeCallbacksAndMessages(null)&#125; 2.用static修饰handler，同时传入一个外部类的弱引用（为了能够调用外部类的资源）如下： 12345678910111213141516171819companion object &#123; const val CODE_LOAD_DATA: Int = 101 private class WithoutLeakHandler( activity: MainActivity) : Handler()&#123; private var mActivity: WeakReference&lt;MainActivity&gt; = WeakReference(activity) override fun handleMessage(msg: Message) &#123; super.handleMessage(msg) val activity = mActivity.get() when(msg.what)&#123; CODE_LOAD_DATA -&gt; &#123; //data load started &#125; &#125; &#125; &#125;&#125; 3.自定义WeakHandler持有Hadnler引用来处理消息： 123456789101112131415161718class WeakRefHandler : Handler &#123; private var mWeakReference: WeakReference&lt;Callback&gt;? = null constructor(callback: Callback) &#123; mWeakReference = WeakReference(callback) &#125; constructor(callback: Callback, looper: Looper) : super(looper) &#123; mWeakReference = WeakReference(callback) &#125; override fun handleMessage(msg: Message) &#123; if (mWeakReference != null &amp;&amp; mWeakReference!!.get() != null) &#123; val callback = mWeakReference!!.get() callback?.handleMessage(msg) &#125; &#125;&#125; 使用如下： 12345678val callback : Handler.Callback = object : Handler.Callback&#123; override fun handleMessage(p0: Message): Boolean &#123; TODO(&quot;not implemented&quot;) //To change body of created functions use File | Settings | File Templates. &#125;&#125;val handler : WeakRefHandler = WeakRefHandler(callback)","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"http://www.yppcat.top/tags/面试/"}]},{"title":"C++学习笔记－复合类型","slug":"C-学习笔记－复合类型","date":"2019-06-16T10:42:46.000Z","updated":"2019-06-25T12:57:27.000Z","comments":true,"path":"2019/06/16/C-学习笔记－复合类型/","link":"","permalink":"http://www.yppcat.top/2019/06/16/C-学习笔记－复合类型/","excerpt":"","text":"1.数组 类似Java中的数组 1234unsigned int name[10] = &#123;&#125;;name[1] = 9;name[3] = 1;cout &lt;&lt; sizeof name / sizeof (int);//获取数组长度 ２.字符串 (1)char数组形式： 12345char name;char fish[] = &quot;Bubbles&quot;;size_t len = strlen(fish);cin &gt;&gt; name;cout &lt;&lt; &quot;name is&quot; &lt;&lt; name &lt;&lt; endl &lt;&lt; &quot;length is&quot; &lt;&lt; len; (2)string形式： 123456789101112131415161718string str1 = &quot;father&quot;;char first_data[] = &#123;&quot;Le Chapon Dodu&quot;&#125;;string second_data = &#123;&quot;The Bread Bowl&quot;&#125;;char charr[20] = &quot;jaguar&quot;;string str = charr;string str3 = str1 + str;char ca1[20];char ca2[20] = &quot;jagur&quot;;strcpy(ca1, ca2); //copy ca2 to ca1;strcat(ca1, &quot;juice&quot;); // add juice to end of ca1unsigned long len1 = str.size(); // return sizesize_t len2 = strlen(ca1); // return sizewchar_t title[] = L&quot;chief&quot;;char16_t names[] = u&quot;felonia&quot;;char32_t car[] = U&quot;Humer&quot;; ３．结构属性： 1234567891011121314151617181920212223void test() &#123; user person1 = &#123; &quot;haha&quot;, 3.2f, 2.5 &#125;; cout &lt;&lt; person1.name &lt;&lt; endl; user persons[] = &#123;&#125;; user people[2] = &#123; &#123;&quot;bami&quot;, 1.1f, 1.99&#125;, &#123;&quot;God&quot;, 2.3f, 3.5&#125; &#125;; if (person1.name == &quot;haha&quot;)&#123; //... &#125;&#125;struct user &#123; char name[20]; float volume; double price;&#125;; ４．共用体用法和结构属性相同，但是只能同时存储其中一种类型(int、long、double) 123456789101112 cout &lt;&lt; person1.id_val.id_char; struct user &#123; char name[20]; float volume; double price; union id&#123; long id_num; char id_char[20]; &#125; id_val;&#125;; ５.enum类型 12345678910111213141516void test_color() &#123; color band; band = yellow; int col = black; col += 1; bits mybit = bits(2);&#125;enum color &#123; red, orange, yellow, green, blue, black, purple&#125;;enum bits &#123; one = 1, two = 2, three = 3, four = 4&#125;; ６.指针 123456789101112131415161718void point() &#123; int updates = 6; // 声明变量 int *p_update; // 声明int类型指针 p_update = &amp;updates;//声明指针指向的地址 cout &lt;&lt; &quot;updates = &quot; &lt;&lt; updates; //6 cout &lt;&lt; &quot;*p_update = &quot; &lt;&lt; *p_update &lt;&lt; endl; //6 cout &lt;&lt; &quot;Address = &quot; &lt;&lt; &amp;updates &lt;&lt; endl; //0x7ffd813aebe4 cout &lt;&lt; &quot;Address = &quot; &lt;&lt; p_update; //0x7ffd813aebe4 int *pt; pt = (int *) 0xB8000000; int *pn = new int; //只能通过指针访问值 int higgens; int *ps = &amp;higgens; //可通过变量和指针访问&#125; ７．delete和new delete只能用来释放new 分配的内存,delete后加上指向内存块的指针。 123456int *ps = new int;delete ps;int *psom = new int [10];psom[5] = 10;delete [] psom; ８．指针算数 C++允许将指针和整数相加，加１的结果等于原来的地址值加上指向的对象占用的字节数。 123456int as[3] = &#123;1,2,3&#125;;int *aw = as;cout &lt;&lt; *aw; //默认取第一个aw = aw +1; //1cout &lt;&lt; *aw; //2 因为int类型指针加１相当于把地址值增加了8,这使得aw的值为第二个元素的值。 9.存储类型 （１）自动存储：函数内部定义的常规变量使用自动存储空间，称为自动变量。自动变量存储在栈中（后进先出） （２）静态存储：整个程序执行期间都存在的存储方式。可使用在函数外部定义或者static。 （３）动态存储：new和delete运算符提供了一种比自动变量和静态变量更灵活的方法。管理了一个内存池，称为堆。内存管理更加复杂和灵活。 10.使用vector和array代替数组 12345678vector&lt;double&gt; ve(8);vector&lt;int&gt;vi;ve[2] = 2.4;array&lt;double ,4&gt; ad = &#123;1.1,2.3,1.4,3.2&#125;;array&lt;int,5&gt;ai&#123;&#125;;ai[2] = 2;","categories":[],"tags":[{"name":"C++学习笔记","slug":"C-学习笔记","permalink":"http://www.yppcat.top/tags/C-学习笔记/"}]},{"title":"C++学习笔记-数据处理","slug":"C-学习笔记-数据处理","date":"2019-06-16T00:52:08.000Z","updated":"2019-06-16T04:50:35.000Z","comments":true,"path":"2019/06/16/C-学习笔记-数据处理/","link":"","permalink":"http://www.yppcat.top/2019/06/16/C-学习笔记-数据处理/","excerpt":"","text":"1.整型： short至少表示1６位 int至少与short一样长（可能16位，可能32位） long至少32位，且至少与int一样长 long long至少64位，且至少与long一样长 可通过sizeof()方法查看具体类型的最大值: 1cout &lt;&lt; &quot;int is&quot; &lt;&lt; sizeof(int) &lt;&lt; &quot;bytes&quot; &lt;&lt; INT_MAX &lt;&lt; endl; 2.无符号类型： eg：unsigned short change; short表示的范围是-32767到+32767，上述所表示的范围是0-65535，优点是可以增大变量能够存储的最大值。此外 unsigned int 可以简写为unsigned。 ３.char类型 char类型专门存储字符（数字和字母），是一种整型。eg : char s = ‘s’; signed char 和 unsigned char的区别： 将char作为数值类型时，同上面的整型（表示的范围0-255），在表示字符时可以直接使用char。 4.bool类型 1bool is_ready = true; 其中true被转换成１，false被转换成０ 5.const限定符 类似Java中的static final的用法，定义常量且在程序的多处用到。 1const int msg = 0; ６.浮点数 浮点数可以表示带小数的数字，计算机存储时将这样的值分为两个部分存储，一部分表示值，另一部分用于对值进行放大和缩小。 浮点类型有float(至少32位),double(至少48位且不少于float),long double(至少和double一样多) 两种写法： 12float f = 12.34;float ss = 3.65E6; 后者表示的是3.65与1000000相乘的结果，前者表示具体的值。表示小数还可以写：3.65E-4表示3.65/10000 优点：可以表示的范围大得多。 缺点：运算速度较慢，精度降低。 ７.运算符： +,-,*,/,%等不具体说 类型转换：转换float会导致精度丢失的问题，将long转换成short这种类型时原来的值可能超出目标范围，只复制右边的值。 强制转换： 12cout &lt;&lt; int(&apos;Q&apos;);cout &lt;&lt; (int) &apos;Q&apos;; 强制转换会有危险，用以下方式较好： 1cout &lt;&lt; static_cast&lt;int &gt;(&apos;Q&apos;); static_cast用于将一种数值转换为另一种数值。 8.auto关键字 auto关键字用于声明变量时不指定变量和的类型，编译器将把变量的类型设置成与初始值相同。 12auto x = 0.99;auto y = &quot;hello&quot;;","categories":[],"tags":[{"name":"C++学习笔记","slug":"C-学习笔记","permalink":"http://www.yppcat.top/tags/C-学习笔记/"}]},{"title":"iconify使用","slug":"iconify使用","date":"2019-05-14T08:06:31.000Z","updated":"2019-05-14T10:20:32.000Z","comments":true,"path":"2019/05/14/iconify使用/","link":"","permalink":"http://www.yppcat.top/2019/05/14/iconify使用/","excerpt":"","text":"先引入： 12compile &apos;com.joanzapata.iconify:android-iconify-ionicons:2.2.2&apos; // (v2.0.1)compile &apos;com.joanzapata.iconify:android-iconify-fontawesome:2.2.2&apos; // (v4.5) 在Applciation初始化： Iconify.with(FontAwesomeModule()) .with(FontEcModule()) 自定义module使用：先创建继承自IconFontDescriptor的类 12345678910class FontEcModule : IconFontDescriptor&#123; override fun ttfFileName(): String &#123; return &quot;iconfont.ttf&quot; &#125; override fun characters(): Array&lt;EcIcons&gt; &#123; return EcIcons.values() &#125;&#125; 上面的ttf文件是放在assets目录下的，之后定义枚举的Icon 12345678910111213141516171819202122public enum EcIcons implements Icon &#123; icon_shuidi(&apos;\\ue600&apos;) ; private char character; EcIcons(char character) &#123; this.character = character; &#125; @Override public String key() &#123; return name().replace(&apos;_&apos;, &apos;-&apos;); &#125; @Override public char character() &#123; return character; &#125;&#125; 这里有个细节，枚举中的名字是用下划线_定义的，但是在使用时要用- 1android:text=&quot;&#123;icon-shuidi&#125;&quot; 这里的unicode编码 &#xe600; 需要将&amp;#xe删除 改为\\u","categories":[],"tags":[{"name":"android","slug":"android","permalink":"http://www.yppcat.top/tags/android/"}]},{"title":"Linux命令","slug":"Linux命令","date":"2019-04-26T14:16:17.000Z","updated":"2019-04-26T14:32:39.000Z","comments":true,"path":"2019/04/26/Linux命令/","link":"","permalink":"http://www.yppcat.top/2019/04/26/Linux命令/","excerpt":"","text":"用户相关命令： 创建用户： useradd ypp : 新建一个ypp用户 passwd ypp : 设置ypp密码 切换用户: su – ypp : 切换到ypp用户 修改密码: passwd : 修改当前用户密码 passwd ypp : 修改ypp用户密码 查看创建的用户信息： cat /etc/passwd 查看组信息: cat /etc/group","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.yppcat.top/tags/Linux/"}]},{"title":"NDK入门-NDK简介","slug":"NDK入门-NDK简介","date":"2019-04-17T12:21:45.000Z","updated":"2019-04-17T12:21:45.000Z","comments":true,"path":"2019/04/17/NDK入门-NDK简介/","link":"","permalink":"http://www.yppcat.top/2019/04/17/NDK入门-NDK简介/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"HashMap实现原理","slug":"HashMap实现原理","date":"2019-04-14T14:15:21.000Z","updated":"2019-04-14T14:21:51.000Z","comments":true,"path":"2019/04/14/HashMap实现原理/","link":"","permalink":"http://www.yppcat.top/2019/04/14/HashMap实现原理/","excerpt":"","text":"HashMap原理 几个注意点： 哈希冲突：当插入的Entry越来越多时，不同的Key值通过哈希函数算出来的index值肯定会有冲突，此时就可以利用链表来解决。 其实HaspMap数组的每一个元素不止是一个Entry对象，也是一个链表的头节点，每一个Entry对象通过Next指针指向下一个Entry对象，这样，当新的Entry的hash值与之前的存在冲突时，只需要插入到对应点链表即可。要注意的是，新来的Entry节点采用的是“头插法”，而不是直接插入在链表的尾部，这是因为HashMap的发明者认为，新插入的节点被查找的可能性更大。 get的几个步骤： 第一步，算出Key值“apple”的hash值，假设为2。 第二步，在数组中查找索引为2的位置，此时找到头节点为Entry6，Entry6的Key值是banana，不是我们要找的值。 第三步，查找Entry6的Next节点，这里为Entry1，它的Key值为apple，是我们要查找的值，这样就找到了对应的键值对，结束。 HashMap死锁： HashMap设计了一个阈值，其值为容量的0.75，当HashMap所用容量超过了阈值后，就会自动扩充其容量。 在多线程的情况下，当重新调整HashMap大小的时候，就会存在条件竞争，因为如果两个线程都发现HashMap需要重新调整大小了，它们会同时试着调整大小。在调整大小的过程中，存储在链表中的元素的次序会反过来，因为移动到新的bucket位置的时候，HashMap并不会将元素放在链表的尾部，而是放在头部，这是为了避免尾部遍历。如果条件竞争发生了，那么就会产生死循环了。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.yppcat.top/tags/Java/"}]},{"title":"Android文件路径详解","slug":"Android文件路径详解","date":"2019-04-13T05:11:50.000Z","updated":"2019-04-13T13:57:45.000Z","comments":true,"path":"2019/04/13/Android文件路径详解/","link":"","permalink":"http://www.yppcat.top/2019/04/13/Android文件路径详解/","excerpt":"","text":"Android磁盘存储可以分为两类，内部存储和外部存储。 内部存储：内部存储不是内存，是位于系统磁盘中一个独特的位置。/data/文件夹就是内部存储，内部存储中一般存储一些应用数据，如apk,sharedpreference,database数据，webView缓存和图片缓存等。内部存储中还有一个文件夹，每个应用都有一个，里面中的数据在应用卸载之后就会删除。结构如：/data/data/你的应用报名/。其次还有一个/data/app/的文件夹，这里面存储着我们手机上安装的ａｐｋ文件。 特点： 内部存储的文件和目录只能被我们的app自己访问，别的app不能访问。 内部存储中的私有目录，当用户卸载app之后，该文件目录中关于该应用的信息就会被删除。 内部存储是可用的。 内部存储大小有限，不适合存储大量数据。 只有root的手机，才能从手机文件管理器看见，否则都是隐藏的。 1getCacheDir().getAbsolutePath();///data/data/包名/cache 常见的内部存储中有这些目录: /data/app/ /data/data/包名/shared_prefs /data/data/包名/cache /data/data/包名/databases /data/data/包名/files 外部存储：外部存储并不是指拓展的ＳＤ卡，不管有无外接设备，每个Android手机都有外部存储。 一般的mnt或者storage目录。外部存储中分两类目录，私有目录和公有目录，私有目录的数据会随着应用的卸载而删除，公有目录不会。 特点： 公有目录任何程序都可以访问，私有目录自身可以访问。 并不一定是可用的，因为SD卡会被挂载。 外部存储中的私有目录中的数据会随着应用的卸载而删除，而公有目录不会。 公有目录： 公有目录是任何程序都可以 DIRECTORY_MUSIC 音乐/storage/emulated/0/Music DIRECTORY_PODCASTS 播客/storage/emulated/0/Podcasts DIRECTORY_RINGTONES 来点铃声 DIRECTORY_ALARMS 闹钟/storage/emulated/0/Alarms DIRECTORY_NOTIFICATIONS 通知/storage/emulated/0/Notifications DIRECTORY_PICTURES 图片/storage/emulated/0/Pictures DIRECTORY_MOVIES 电影/storage/emulated/0/Movies DIRECTORY_DOWNLOADS 下载文件存储路径/storage/emulated/0/Download DIRECTORY_DCIM 媒体文件/storage/emulated/0/DCIM DIRECTORY_DOCUMENTS 文档/storage/emulated/0/Documents 我们通过Environment.getExternalStoragePublicDirectory()来获取这些目录 私有目录： 外部存储中的私有目录是不会主动创建的，需要我们自己创建，私有目录应用本身无需申请动态权限，就能直接访问。我们可以在私有目录下创建我们自己的文件夹： getExternalFilesDir(“files目录的子目录名称”) 获取应用私有目录files目录中的文件目录(storage/emulated/0/Android/data/包名/files/子目录) getExternalCacheDir() 获取应用cache目录（/storage/emulated/0/Android/data/包名/cache）","categories":[],"tags":[{"name":"android","slug":"android","permalink":"http://www.yppcat.top/tags/android/"}]},{"title":"单例模式","slug":"单例模式","date":"2019-04-12T14:47:57.000Z","updated":"2019-04-12T15:06:47.000Z","comments":true,"path":"2019/04/12/单例模式/","link":"","permalink":"http://www.yppcat.top/2019/04/12/单例模式/","excerpt":"","text":"单例模式：保证一个类仅有一个实例，并提供一个访问它的全局访问点。 单例模式的６中写法： 饿汉模式：在类加载时就完成了初始化，所以加载较慢，但是对象的获取速度快，避免了多线程同步问题。 123456789101112public class SingleTon &#123; private static SingleTon instance = new SingleTon(); private SingleTon() &#123; &#125; public static SingleTon getInstance() &#123; return instance; &#125;&#125; 懒汉模式：线程不安全，节约了资源，在多线程时不能正常工作。 123456789101112131415public class SingleTon &#123; private static SingleTon instance; private SingleTon() &#123; &#125; public static SingleTon getInstance() &#123; if (instance == null) &#123; return new SingleTon(); &#125; return instance; &#125;&#125; 线程安全的懒汉模式：能够在多线程下工作，但是每次调用getInstance都需要进行同步，造成的同步开销较大。 123456789101112131415public class SingleTon &#123; private static SingleTon instance; private SingleTon() &#123; &#125; public static synchronized SingleTon getInstance() &#123; if (instance == null) &#123; return new SingleTon(); &#125; return instance; &#125;&#125; 双重检查模式: 避免了不必要的同步，同时避免创建多余的实例，volatile稍微影响了性能。 第一次加载稍慢，有可能出现失效的问题。 12345678910111213141516171819public class SingleTon &#123; private volatile static SingleTon instance; private SingleTon() &#123; &#125; public static synchronized SingleTon getInstance() &#123; if (instance == null) &#123; synchronized (SingleTon.class) &#123; if (instance == null) &#123; instance = new SingleTon(); &#125; &#125; &#125; return instance; &#125;&#125; 静态内部类单例模式：第一次加载时不会初始化sInstance,只有第一次调用getInstance方法时才会加载SingleTonHolder并初始化sInstance。不仅能保证线程安全，也能保证SingleTon类的唯一性。（推荐使用） 123456789101112131415public class SingleTon &#123; private SingleTon() &#123; &#125; public static SingleTon getInstance() &#123; return SingleTonHolder.sInstance; &#125; private static class SingleTonHolder &#123; private static final SingleTon sInstance = new SingleTon(); &#125;&#125; 枚举单例： 线程安全，且在任何情况下都是单例，但是可读性不高。 12345678public enum SingleTon &#123; INSTANCE; public void doSomeThing()&#123; &#125;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.yppcat.top/tags/Java/"}]},{"title":"AsyncTask原理分析","slug":"AsyncTask原理分析","date":"2019-04-12T01:21:57.000Z","updated":"2019-04-12T05:22:15.000Z","comments":true,"path":"2019/04/12/AsyncTask原理分析/","link":"","permalink":"http://www.yppcat.top/2019/04/12/AsyncTask原理分析/","excerpt":"","text":"AsyncTask是一个抽象泛型类，它有三个参数，分别是Params,Progress和Result，其中Params为参数类型,Progress为后台执行任务的进度，Result为返回的结果的类型。如果不需要某个参数，可以将其设置为Void类型。 AsyncTask中有四个核心的方法: onPreExecute：在主线程中执行，一般在任务执行前做准备工作，比如对UI做一些标记。doInBackground(Params…params)：在线程池中执行。在onPreExecute方法执行后运行，用来执行较为耗时的操作。在执行过程中可以调用publishProgress(Progress…values)来更新进度信息。 onProgressUpdate(Progress…values)：在主线程中执行。当调用publishProgress(Progress…values)时，此方法会将进度更新到ＵＩ组件上。 onPostExecute(Result result)：在主线程中执行。当后台任务执行完成后，它会被执行。doInBackground方法得到的结果就是返回的result的值。此方法一般做任务执行后的收尾工作，比如更新ＵＩ和数据。 AsyncTask源码解析： 先看一下它的初始化的一些数据和方法： 12345678910111213141516171819202122232425262728293031private static final int CPU_COUNT = Runtime.getRuntime().availableProcessors();// We want at least 2 threads and at most 4 threads in the core pool,// preferring to have 1 less than the CPU count to avoid saturating// the CPU with background workprivate static final int CORE_POOL_SIZE = Math.max(2, Math.min(CPU_COUNT - 1, 4));private static final int MAXIMUM_POOL_SIZE = CPU_COUNT * 2 + 1;private static final int KEEP_ALIVE_SECONDS = 30;private static final ThreadFactory sThreadFactory = new ThreadFactory() &#123; private final AtomicInteger mCount = new AtomicInteger(1); public Thread newThread(Runnable r) &#123; return new Thread(r, &quot;AsyncTask #&quot; + mCount.getAndIncrement()); &#125;&#125;;private static final BlockingQueue&lt;Runnable&gt; sPoolWorkQueue = new LinkedBlockingQueue&lt;Runnable&gt;(128);/** * An &#123;@link Executor&#125; that can be used to execute tasks in parallel. */public static final Executor THREAD_POOL_EXECUTOR;static &#123; ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor( CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_SECONDS, TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory); threadPoolExecutor.allowCoreThreadTimeOut(true); THREAD_POOL_EXECUTOR = threadPoolExecutor;&#125; 这里的corePoolSize获取的是Java虚拟机的可用的处理器数量来计算的 maximumPoolSize也是根据这个来计算的 keepAliveTime的时间是３０ｓ 阻塞队列采用的是LinkedBlockingQueue，容量为１２８ ThreadFactory给线程起了”AsyncTask#”这样格式的名字 这样就完成了线程池的构造。 接着看一下AsyncTask的构造： 12345678910111213141516171819202122232425262728293031323334353637383940public AsyncTask(@Nullable Looper callbackLooper) &#123; mHandler = callbackLooper == null || callbackLooper == Looper.getMainLooper() ? getMainHandler() : new Handler(callbackLooper); mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123; public Result call() throws Exception &#123; mTaskInvoked.set(true); Result result = null; try &#123; Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); //noinspection unchecked result = doInBackground(mParams); Binder.flushPendingCommands(); &#125; catch (Throwable tr) &#123; mCancelled.set(true); throw tr; &#125; finally &#123; postResult(result); &#125; return result; &#125; &#125;; mFuture = new FutureTask&lt;Result&gt;(mWorker) &#123; @Override protected void done() &#123; try &#123; postResultIfNotInvoked(get()); &#125; catch (InterruptedException e) &#123; android.util.Log.w(LOG_TAG, e); &#125; catch (ExecutionException e) &#123; throw new RuntimeException(&quot;An error occurred while executing doInBackground()&quot;, e.getCause()); &#125; catch (CancellationException e) &#123; postResultIfNotInvoked(null); &#125; &#125; &#125;;&#125; 这里强调一下，AsyncTask的execute方法一定要在主线程中调用，因为这里的handler一定要是getMainHandler,具体的原因下面会讲。此外创建了一个WorkRunnable对象mWorker,这个WorkRunnable实现了Calable接口，并实现了call方法，并且在该方法中调用了doInBackground方法类处理任务并得到结果，最终还通过postResult将结果传递了出去。这里的FutureTask是一个可管理的异步任务，它实现了Runnable和Future这两个接口。所以，它可以包装Runnable和Callable，并且提供给Executor执行，在这里我们将WorkerRunnable作为参数传递给了FutureTask。接下来我们看一下execute方法： 123456789101112131415161718192021222324252627public final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) &#123; return executeOnExecutor(sDefaultExecutor, params);&#125;public final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec, Params... params) &#123; if (mStatus != Status.PENDING) &#123; switch (mStatus) &#123; case RUNNING: throw new IllegalStateException(&quot;Cannot execute task:&quot; + &quot; the task is already running.&quot;); case FINISHED: throw new IllegalStateException(&quot;Cannot execute task:&quot; + &quot; the task has already been executed &quot; + &quot;(a task can be executed only once)&quot;); &#125; &#125; mStatus = Status.RUNNING; onPreExecute(); mWorker.mParams = params; exec.execute(mFuture); return this; &#125; 我们看到这里首先执行了onPreExecute方法，然后将参数传给mWorker。前面我们已经说过WokrerRunnable作为参数传递给了FutureTask,因此，参数被封装到了FutureTask中。接下来我们看一下exec这个对象： 12345678910111213141516171819202122232425private static class SerialExecutor implements Executor &#123; final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;(); Runnable mActive; public synchronized void execute(final Runnable r) &#123; mTasks.offer(new Runnable() &#123; public void run() &#123; try &#123; r.run(); &#125; finally &#123; scheduleNext(); &#125; &#125; &#125;); if (mActive == null) &#123; scheduleNext(); &#125; &#125; protected synchronized void scheduleNext() &#123; if ((mActive = mTasks.poll()) != null) &#123; THREAD_POOL_EXECUTOR.execute(mActive); &#125; &#125;&#125; 从上面的代码可以看出该对象表示的是一个串行的线程池，当调用execute方法时，会将futureTask加入到mTask中。且当任务执行完或者当前没有活动是都会执行scheduleNext方法，会从mTaskｓ中取出FutureTask任务并交由THREAD_POOL_EXECUTOR处理。执行的时候因为传进来的是由WorkerRunnable作为参数的FutureTask，所以会执行WorkerRunnable的call方法，在call方法中会将结果通过postResult方法传递出去： 1234567private Result postResult(Result result) &#123; @SuppressWarnings(&quot;unchecked&quot;) Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT, new AsyncTaskResult&lt;Result&gt;(this, result)); message.sendToTarget(); return result;&#125; 可以看到，上面说的使用getMainHandler和这里的getHandler是一样的，在这里创建了Message,并通过Handler发送了该消息： 1234567891011121314151617181920212223242526272829private static Handler getMainHandler() &#123; synchronized (AsyncTask.class) &#123; if (sHandler == null) &#123; sHandler = new InternalHandler(Looper.getMainLooper()); &#125; return sHandler; &#125;&#125;private static class InternalHandler extends Handler &#123; public InternalHandler(Looper looper) &#123; super(looper); &#125; @SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;RawUseOfParameterizedType&quot;&#125;) @Override public void handleMessage(Message msg) &#123; AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj; switch (msg.what) &#123; case MESSAGE_POST_RESULT: // There is only one result result.mTask.finish(result.mData[0]); break; case MESSAGE_POST_PROGRESS: result.mTask.onProgressUpdate(result.mData); break; &#125; &#125; &#125; 这里自定义了一个Handler并处理了它的处理方式，可以看到上面发送的消息会调用finish方法： 12345678private void finish(Result result) &#123; if (isCancelled()) &#123; onCancelled(result); &#125; else &#123; onPostExecute(result); &#125; mStatus = Status.FINISHED;&#125; 这里判断了是否被取消，如果被取消了，则调用onCancelled方法，否则调用onPostExecute方法。","categories":[],"tags":[{"name":"android","slug":"android","permalink":"http://www.yppcat.top/tags/android/"}]},{"title":"多线程","slug":"多线程","date":"2019-04-10T01:35:12.000Z","updated":"2019-04-11T14:46:37.000Z","comments":true,"path":"2019/04/10/多线程/","link":"","permalink":"http://www.yppcat.top/2019/04/10/多线程/","excerpt":"","text":"进程：可以被看做是程序的实体，同样，它也是线程的容器。是受操作系统管理的最小单元。 线程：操作系统调度的最小单元。 多线程的优点： ​ 使用多线程可以减少程序的相应时间 ​ 与进程比，线程创建和切换开销很小，同时多线程在数据共享方面效率非常高 ​ 多CPU或者多核计算机本身就具备执行多线程的能力 ​ 使用多线程能简化成 程序的结构，使程序便于维护和理解 线程的几种状态： New：新创建状态。 Runnable：可运行状态。一旦调用start，线程就处于Runnable状态。 Blocked：阻塞状态。表示线程被锁阻塞，暂时不活动。（请求锁） Waiting：等待状态。线程暂时不活动，并且不运行任何代码，这消耗最少的资源，直到线程调度器重新激活它。 Time Waiting：超时等待状态。和等待状态不同的是，它是可以在指定的时间自由返回的。 Terminated：终止状态。表示当前线程已经执行完毕，可能是ｒｕｎ方法执行完毕正常退出，也可能是因为未捕获的异常导致了ｒｕｎ方法的终止。 线程的创建： １．继承Ｔｈｒｅａｄ类，重写ｒｕｎ方法: 12345678910111213public class TestThread extends Thread &#123; @Override public void run() &#123; Log.e(&quot;thread&quot;, &quot;create&quot;); &#125;&#125;public void run() &#123; Thread thread = new TestThread(); thread.run();&#125; 2.实现Ｒｕｎｎａｂｌｅ接口，并实现ｒｕｎ方法： 1234567891011121314public class TestRunnable implements Runnable &#123; @Override public void run() &#123; Log.e(&quot;thread&quot;, &quot;create&quot;); &#125;&#125;public void run() &#123; TestRunnable runnable = new TestRunnable(); Thread mThread = new Thread(runnable); mThread.start();&#125; ３.实现Callable接口，重写call方法： Callable接口实际是属于Ｅｘｅｃｕｔｏｒ框架中的功能类，Callable和Runnable接口的功能类似，但提供了比Runable更强大的功能： Callable可以在任务接受后提供一个返回值，而Runnable不可以。 Callable接口中的ｃａｌｌ方法可以抛出异常，但是Runnable 中的run方法不可以。 运行Callable可以拿到一个Ｆｕｔｕｒｅ对象，Future对象表示异步计算的结果，它提供了检查计算是否完成的办法。但是当调用Ｆｕｔｕｒｅ的get 方法获取结时，当前线程会阻塞，直到call方法返回结果。 12345678910111213141516171819public class TestCallable implements Callable &#123; @Override public Object call() throws Exception &#123; return &quot;hello&quot;; &#125;&#125;public void run() &#123; TestCallable callable = new TestCallable(); ExecutorService executorService = Executors.newSingleThreadExecutor(); Future future = executorService.submit(callable); try &#123; Log.e(&quot;thread&quot;, &quot;create&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 安全地终止线程： 1.用中断来终止线程： 1234567public void stopThread() throws InterruptedException &#123; TestRunnable runnable = new TestRunnable(); Thread thread = new Thread(runnable); thread.start(); TimeUnit.MILLISECONDS.sleep(10); thread.interrupt();&#125; ２．通过boolean来控制是否需要停止线程： 123456789101112131415161718192021222324public class MoonRunner implements Runnable &#123; private long i; private volatile boolean on = true; @Override public void run() &#123; while (on) &#123; i++; Log.e(&quot;test&quot;, &quot;i=&quot; + i); &#125; &#125; public void cancel()&#123; on = false; &#125;&#125;public void stop() throws InterruptedException &#123; MoonRunner runner = new MoonRunner(); Thread mThread = new Thread(runner,&quot;moonThread&quot;); mThread.start(); TimeUnit.MILLISECONDS.sleep(10); runner.cancel();&#125; 同步： Lock Condition Volatile 阻塞队列：就是生产者存放元素的容器，而消费者也只从容器里拿元素。使用阻塞队列无须单独考虑同步和线程间通信的问题。 常见的两种阻塞场景： （１）当队列中没有数据的情况下，消费者端的所有线程会被自动阻塞，直到有数据放进队列 （２）当队列中填满数据的情况下，生产者端的所有线程会被自动阻塞，直到队列中有空的位置，线程被自动唤醒 核心的几个方法： 放入数据： offer(anObject)：表示如果可能的话，将anObject放到BlockingQueue里。可以容纳返回true，否则返回false,且这个方法不阻塞当前执行方法的线程。 offer(E o,long timeout,TimeUnit unit)：可以设定等待的时间。如果在指定的时间内还不能往队列中加入BlockingQueue，则返回false. put(anObjec t)：将anObject加到BlockingQueue里。如果BlockingQueue没有空间，则调用此方法的线程被阻断，直到BlockingQueue里面有了空间再继续。 获取数据： poll(time)：取走BlockingQueue里排在首位的对象，若不能立即取出，则可以等time的参数规定的时间。取不到时返回null poll(long time,TimeUnit unit)：从BlockingQueue中取出一个队首的对象。如果在指定的时间内，队列一旦有数据可取，则立即返回队列中的数据；否则知道时间超时还没有数据可取，返回失败。 take()：取走BlockingQueue里排在首位的对象。若BlockingQueue为空，则阻断进入等待状态，直到BlockingQueue有新的数据被加入。 drainTo()：一次从BlockingQueue获取所有的可用的数据对象（还可以指定获取的个数）。通过该方法,可以提升获取数据的效率；无须多次分批加锁和释放锁。 线程池： 构造方法如下所示： 12345678public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) &#123; this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), defaultHandler);&#125; corePoolSize：核心线程数。默认情况下线程池是空的，只有任务提交时才会创建线程。如果当前运行的线程数小于corePoolSize，则创建新线程来处理任务；如果等于或者多余corePoolSize，则不再创建。如果调用线程池的prestartAllcoreThread方法，线程池也会 提前创建并启动所有核心线程来等待任务。 maximumPoolSize：线程池允许创建的最大线程数。如果任务队列满了并且线程数小于maximunPoolSize时，则线程池仍旧会创建新的线程来处理任务。 keepAliveTime：非核心线程闲置的超时时间。超过这个时间则回收。如果任务很多，并且每个任务的执行时间很短，则可以调大keepAliveTime来提高线程的利用率。另外，如果设置allowCoreThreadTimeOut属性为true时，keepAliveTime也会应用到核心线程上。 TimeUnit：keepAliveTime参数的时间单位。 workQueue：任务队列。如果当前线程数大于corePoolSize，则将任务添加到次任务队列中。该任务队列是BlockingQueue类型的，也就是阻塞队列。 ThreadFactory：线程工厂。可以用线程工厂给每个创建出来的线程设置名字。 RejectedExecutionHandler：饱和策略。这是当任务队列和线程池都满了时所采取的应对策略，默认是AbordPolicy，表示无法处理新任务，并抛出RejectedExecutionException异常。此外还有三种： （１）CallerRunsPolicy：用调用者所在的线程来处理任务。此策略提供简单的反馈控制机制，能够减缓新任务提交的速度 （２）DiscardPolicy：不能执行任务，并将该任务删除 （３）DiscardOldestPolicy：丢弃队列最近的任务，并执行当前任务 以下是线程池的处理流程 线程池的种类： （１）FixedThreadPool：只有核心线程，并且数量固定，没有非核心线程。keepAliveTime为0L表示多余的线程会被立即终止。因为不会产生多余的线程，所以keepAliveTime是无效参数。此外，任务队列采用的无界的阻塞队列LinkedBlockingQueue。 （２）CachedThreadPool：根据需要创建线程的线程池，corePoolSize为０，maximumPoolSize设置为Integer.MAX_VALUE ，这意味着CachedThreadPool没有０核心线程，非核心线程是无界的。keepAliveTime设置为60L，则空闲线程等待新任务的最长时间为60s。用了阻塞队列SynchronousQueue，它是一个不存储元素的阻塞队列，每个插入操作必须等待另一个线程的移除操作，同样任何一个移除操作都等待另一个线程的插入操作。 （３）SingleThreadExecutor：使用单个工作线程的线程池。corePoolSize和maximumPoolSize都为１，这意味着只有一个核心线程，其他的参数都和FixedThreadPool一样。 （４）ScheduledThreadPool：是一个能实现定时和周期性任务的线程池。构造时传入corePoolSize，maximumPoolSize的值是Integer.MAX_VALUE。采用了DelayedWorkQueue，是无界的，所以maximumPoolSize这个参数是无效的。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.yppcat.top/tags/Java/"}]},{"title":"kotlin特殊的函数和调用","slug":"kotlin特殊的函数和调用","date":"2019-04-04T15:23:38.000Z","updated":"2019-04-04T15:58:17.000Z","comments":true,"path":"2019/04/04/kotlin特殊的函数和调用/","link":"","permalink":"http://www.yppcat.top/2019/04/04/kotlin特殊的函数和调用/","excerpt":"","text":"1.扩展函数的使用： 新建.kt文件，并编写如下 12345fun Fragment.showToast(content: String): Toast &#123; val toast = Toast.makeText(this.activity?.applicationContext, content, Toast.LENGTH_SHORT) toast.show() return toast&#125; 图上的showToast就是一个扩展函数，可以直接访问被扩展的其他方法和属性，相当于在Fragment类中添加了这样的方法再去访问一样，此外，扩展函数不能访问私有的和受保护的成员。扩展函数不存在重写，在Kotlin中会被当做静态的函数对待。通过以下方导入： 1import ktmvp.yppcat.ktmvp.utils.showToast 之后在Fragment可以这样使用： 1showToast(errorMessage) 2.可变参数：让函数支持任意数量的参数 在Java中： 1234 private void getName(String... params) &#123; Log.e(&quot;test&quot;, Arrays.toString(params)); &#125;&#125; Kotlin中： 1234private fun getName(vararg params: String) &#123; val list = listOf(&quot;aa&quot;, *params) print(list)&#125; java中的…被vararg修饰符替代，此外*表示的是展开运算符","categories":[],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://www.yppcat.top/tags/Kotlin/"}]},{"title":"apk优化方式","slug":"apk优化方式","date":"2019-04-02T13:49:34.000Z","updated":"2019-04-02T14:59:11.000Z","comments":true,"path":"2019/04/02/apk优化方式/","link":"","permalink":"http://www.yppcat.top/2019/04/02/apk优化方式/","excerpt":"","text":"apk优化的几种方式： 1.svg图片的使用 强调点：在安卓5.0 以下是不支持这种方式的，需要做以下兼容： 在app的build.gradle目录下的defaultConfig中添加 12//将svg图片生成指定的png图片vectorDrawables.generatedDensities(&apos;xhdpi&apos;,&apos;xxhdpi&apos;,&apos;xxxhdpi&apos;) 或者添加 12//使用support-v7兼容vectorDrawables.useSupportLibrary = true 2.使用tint着色器来给png图片增加颜色 12345678910&lt;ImageView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:src=&quot;@drawable/test&quot;/&gt;&lt;ImageView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:src=&quot;@drawable/test&quot; android:tint=&quot;@android:color/holo_green_dark&quot; /&gt; 也可以增加类似的点击效果： 12345&lt;ImageView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:src=&quot;@drawable/test&quot; android:tint=&quot;@color/color&quot; /&gt; color的selector： 12345&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;item android:state_pressed=&quot;true&quot; android:color=&quot;@android:color/holo_green_dark&quot;/&gt; &lt;item android:color=&quot;@android:color/transparent&quot; /&gt;&lt;/selector&gt; 3.打包时只保留中文语言： 在app的build.gradle目录下的defaultConfig中添加 1resConfigs(&apos;zh-rCN&apos;,&apos;ko&apos;)//中文和韩语 4.打包时将只打包需要的so库： 在app的build.gradle目录下的defaultConfig中添加 123ndk&#123; abiFilters(&apos;armeabi&apos;,&apos;armeabi-v7a&apos;)//这两种是常见的手机架构&#125; 5.删除无用的资源（Lint工具检查） Analyze-&gt;Run Inspection by name-&gt;搜索unused resource 删除 6.混淆的使用： 12345release &#123; //开启代码混淆 minifyEnabled true proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;&#125; 7.资源压缩： 1234567release &#123; //开启代码混淆 minifyEnabled true //资源压缩 shrinkResources true proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;&#125; 此外还可以通过指定的方式不压缩某些资源，在res目录下新建raw文件夹，新建keep.xml文件： 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources xmlns:tools=&quot;http://schemas.android.com/tools&quot; tools:discard=&quot;@color/color&quot; tools:keep=&quot;@layout/activity_main&quot; //指定不压缩的资源 tools:shrinkMode=&quot;strict&quot;&gt;&lt;/resources&gt; 8.androidStudio中webp插件的使用： 右键png或jepg图片convert to webp可以压缩需要的图片 9.资源混淆、压缩对齐（待详解～～～）","categories":[],"tags":[{"name":"android","slug":"android","permalink":"http://www.yppcat.top/tags/android/"}]},{"title":"java反射","slug":"java反射","date":"2019-03-28T13:56:23.000Z","updated":"2019-03-28T14:42:33.000Z","comments":true,"path":"2019/03/28/java反射/","link":"","permalink":"http://www.yppcat.top/2019/03/28/java反射/","excerpt":"","text":"简单来说，反射就是在运行时可以获取任意 Class 或 Object 内部所有成员属性，如成员变量、成员方法、构造函数和 Annotation。 首先，我们定义一个注解： 1234@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface Invoke &#123;&#125; 对于注解中的参数，有以下解释： @Target : 注解所修饰的对象范围 @Inherited ：表示注解可以被继承 @Documented ：表示这个注解应该被JavaDoc工具记录 @Retention ：用来声明注解的保留策略 其中@Target和@Retention有以下的一些参数： 12345678910111213141516171819202122public enum ElementType &#123; TYPE, 能修饰类，接口和枚举类型 FIELD, 能修饰成员变量 METHOD, 能修饰方法 PARAMETER, 能修饰参数 CONSTRUCTOR, 能修饰构造方法 LOCAL_VARIABLE, 能修饰局部变量 ANNOTATION_TYPE, 能修饰注解 PACKAGE, 能修饰包 TYPE_PARAMETER, 类型参数声明 TYPE_USE 使用类型&#125; 12345678public enum RetentionPolicy &#123; SOURCE, 源码级注解，只会保留在.java源码中，编译后被丢弃，不会保留在.class中 CLASS, 编译时注解。注解信息会保留在.java源码以及.class中。当程序运行时，JVM会丢弃该注解信息 RUNTIME 运行时注解。当运行Java程序时，JVM也会保留该注解信息，可以通过反射获取该注解信息&#125; 下面，我们来定义一个该注解使用的类： 12345678910111213141516171819202122232425public class UserBean &#123; private String name; public int age; public UserBean(String name, int age) &#123; this.name = name; this.age = age; &#125; @Invoke public static void logd() &#123; Log.e(&quot;test&quot;, &quot;this is static class&quot;); &#125; @Invoke public void publicMethod(String user) &#123; Log.e(&quot;test&quot;, &quot;this is public&quot; + user); &#125; @Invoke private void privateMethod() &#123; Log.e(&quot;test&quot;, &quot;this is private method&quot;); &#125;&#125; 上面说过，运行时注解可以通过反射的方式处理：","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.yppcat.top/tags/Java/"}]},{"title":"表","slug":"表","date":"2019-03-25T14:22:11.000Z","updated":"2020-05-22T12:50:34.170Z","comments":true,"path":"2019/03/25/表/","link":"","permalink":"http://www.yppcat.top/2019/03/25/表/","excerpt":"","text":"1.数组 特点： 在内存中，数组是一块连续的区域。 数组需要预留空间，在使用前要先申请占内存的大小，可能会浪费内存空间。 插入数据和删除数据效率低，插入数据时，这个位置后面的数据在内存中都要向后移。删除数据时，这个数据后面的数据都要往前移动。 随机读取效率很高。因为数组是连续的，知道每一个数据的内存地址，可以直接找到给地址的数据。 并且不利于扩展，数组定义的空间不够时要重新定义数组。 优点： 随机访问性强 查找速度快 缺点： 插入和删除效率低 可能浪费内存 内存空间要求高，必须有足够的连续内存空间。 数组大小固定，不能动态拓展 2.链表 特点： 在内存中可以存在任何地方，不要求连续。 每一个数据都保存了下一个数据的内存地址，通过这个地址找到下一个数据。 增加数据和删除数据很容易。 再来个人可以随便坐，比如来了个人要做到第三个位置，那他只需要把自己的位置告诉第二个人，然后问第二个人拿到原来第三个人的位置就行了。其他人都不用动。 查找数据时效率低，因为不具有随机访问性，所以访问某个位置的数据都要从第一个数据开始访问，然后根据第一个数据保存的下一个数据的地址找到第二个数据，以此类推。 要找到第三个人，必须从第一个人开始问起。 不指定大小，扩展方便。链表大小不用定义，数据随意增删。 优点： 插入删除速度快 内存利用率高，不会浪费内存 大小没有固定，拓展很灵活。 缺点： 不能随机查找，必须从第一个开始遍历，查找效率低 Java Collections 表 Collections实现了Iterator（迭代器）接口，并且提供了remove、next、hasNext方法。 Interator的remove方法可以删除由next最新返回的项，相比较Collections中的remove方法，Iterator中的remove有很多的优点。但是有一点，当我们对正在被迭代的集合进行结构上的改变时(add、remove、clear)等操作，那么迭代器就不再合法（此后我们再使用该迭代器将会有ConcurrentModificationException异常）。 List接口继承了Collection接口，并且有两种实现方式 ArrayList：提供了List ADT 的一种可增长数组的实现。它的优缺点同上面的数组。 LinkedList：提供了List ADT双链表的实现（每一个节点除了持有指向后继节点的链，还有一个指向前驱节点的链），它的优缺点同以上的了链表。 以下是自定义类似ArrayList的实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112public class MyArrayList&lt;AnyType&gt; implements Iterable&lt;AnyType&gt; &#123; public static final int default_size = 10; private int theSize; private AnyType[] theItems; public MyArrayList() &#123; doClear(); &#125; public void clear() &#123; doClear(); &#125; public int size() &#123; return theSize; &#125; public boolean isEmpty() &#123; return size() == 0; &#125; public void trimToSize() &#123; ensureCapacity(size()); &#125; public AnyType get(int idx) &#123; if (idx &lt; 0 || idx &gt;= size()) &#123; throw new ArrayIndexOutOfBoundsException(); &#125; return theItems[idx]; &#125; public AnyType set(int idx, AnyType newVal) &#123; if (idx &lt; 0 || idx &gt;= size()) &#123; throw new ArrayIndexOutOfBoundsException(); &#125; AnyType old = theItems[idx]; theItems[idx] = newVal; return old; &#125; public boolean add(AnyType x) &#123; add(size(), x); return true; &#125; public void add(int idx, AnyType x) &#123; //扩展数组 if (theItems.length == size()) &#123; ensureCapacity(size() * 2 + 1); &#125; //插入时整体移动 for (int i = theSize; i &gt; idx; i--) &#123; theItems[i] = theItems[i - 1]; &#125; theItems[idx] = x; &#125; public AnyType remove(int idx) &#123; AnyType removedItem = theItems[idx]; for (int i = idx; i &lt; size() - 1; i++) &#123; theItems[i] = theItems[i + 1]; &#125; theSize--; return removedItem; &#125; private void doClear() &#123; theSize = 0; ensureCapacity(default_size); &#125; public void ensureCapacity(int newCapacity) &#123; if (newCapacity &lt; theSize) &#123; return; &#125; AnyType[] old = theItems; theItems = (AnyType[]) new Object[newCapacity]; for (int i = 0; i &lt; size(); i++) &#123; theItems[i] = old[i]; &#125; &#125; public Iterator&lt;AnyType&gt; iterator() &#123; return new ArrayListIterator&lt;AnyType&gt;(this); &#125; private static class ArrayListIterator&lt;AnyType&gt; implements Iterator&lt;AnyType&gt; &#123; private int current = 0; private MyArrayList&lt;AnyType&gt; theList; public ArrayListIterator(MyArrayList&lt;AnyType&gt; list) &#123; theList = list; &#125; @Override public boolean hasNext() &#123; return current &lt; theList.size(); &#125; @Override public AnyType next() &#123; return theList.theItems[current++]; &#125; &#125;&#125;","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.yppcat.top/tags/数据结构/"}]},{"title":"安卓内存泄漏","slug":"安卓内存泄漏","date":"2019-03-20T12:44:05.000Z","updated":"2019-03-20T13:09:28.000Z","comments":true,"path":"2019/03/20/安卓内存泄漏/","link":"","permalink":"http://www.yppcat.top/2019/03/20/安卓内存泄漏/","excerpt":"","text":"内存泄漏（Memory Leak）是指程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。 安卓中常见的容易导致内存泄露的原因有以下几种： 1.非静态内部类的使用； eg: 12345678910111213141516class MyAdapter extends FragmentPagerAdapter&#123; public MyAdapter(FragmentManager fm) &#123; super(fm); &#125; @Override public Fragment getItem(int position) &#123; return null; &#125; @Override public int getCount() &#123; return 0; &#125;&#125; 以上的例子使我们在开发中常用的使用内部类，但是这样写会导致内部类一直持有外部类（Activity等）的引用，所以如果当activity退出时， 此内部类依然持有按错activity 的引用，导致activity无法回收，则会导致activity的内存泄漏。 2.非静态handler的使用： eg: 123456Handler handler = new Handler()&#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); &#125;&#125;; 以上是我们常见的handler 的构造，as也会提示我们会有内存泄露的问题。原因呢？建议去过一遍Handler的源码，回调的handlerMessage方法中的message对象有个target属性指向的就是当前的Handler，所以如果存在message，那么因为它持有了Handler对象，而Handler对象又是当前类的匿名内部类，持有当前类的引用，导致当前类无法释放，从而造成了内存泄漏。 3.eventBus未取消注册 4.Rxbus未取消注册 5.广播为取消注册 以上三种情况类似，这里就不过多介绍。 6.不规范的单例导致的内存泄漏： eg： 1234567891011121314151617181920public class Utils &#123; private Context context; private static Utils utils; private Utils(Context context) &#123; this.context = context; &#125; public static Utils getInstance(Context context) &#123; if (utils == null) &#123; synchronized (Utils.class) &#123; if (utils == null) &#123; utils = new Utils(context); &#125; &#125; &#125; return utils; &#125;&#125; 以上的单例模式每次在使用的时候会传入一个Context对象，因为单利对象是一直存在的，使用完并不会被释放，所有导致持有的context不会被释放，context一般是Activity，所以就导致了Activity的内存泄漏。正确的写法如下： 123456789101112131415161718public class Utils &#123; private Context context; private static Utils utils; private Utils(Context context) &#123; this.context = context; &#125; public static Utils getInstance(Context context) &#123; if (utils == null) &#123; synchronized (Utils.class) &#123; if (utils == null) &#123; utils = new Utils(context.getApplicationContext()); &#125; &#125; &#125; return utils; &#125;","categories":[],"tags":[{"name":"android","slug":"android","permalink":"http://www.yppcat.top/tags/android/"}]},{"title":"安卓序列化","slug":"安卓序列化","date":"2019-03-12T14:06:12.000Z","updated":"2019-03-13T15:42:44.000Z","comments":true,"path":"2019/03/12/安卓序列化/","link":"","permalink":"http://www.yppcat.top/2019/03/12/安卓序列化/","excerpt":"","text":"Serializable是 序列化的意思，表示将一个对象转换成可存储或可传输的状态。序列化后的对象可以在网络上进行传输，也可以存储到本地。至于序列化的方式，只需要让一个类实现该接口即可。 eg: 123456789101112131415161718192021public class Student implements Serializable &#123; public static final long serialVersionUID = 1L; private String name; private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 上面的serialVersionUID不写同样可以实现序列化，serialVersionUID实现序列化时，会把当前类的serialVersionUID写入序列化的文件中，当反序列化时系统会去检测文件中的serialVersionUID，看它是否和当前类的serialVersionUID是否一致，如果一致则可以成功反序列化，否则则说明当前类和序列化的类相比发生了某些变化，这时候反序列化失败。一般来说，我们都是要手动指定serialVersionUID的值。此外静态从成员变量属于类不属于对象，所以不会参与序列化的过程，其次用transient关键字标记的成员不参与序列化过程。 此外我们还可以使用Parcelable接口来实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class Person implements Parcelable&#123; private String name; private int age; public Person(String name,int age)&#123; this.name = name; this.age = age; &#125; protected Person(Parcel in) &#123; //读取name 和 age name = in.readString(); age = in.readInt(); &#125; public static final Creator&lt;Person&gt; CREATOR = new Creator&lt;Person&gt;() &#123; @Override public Person createFromParcel(Parcel in) &#123; //实现反序列化 return new Person(in); &#125; @Override public Person[] newArray(int size) &#123; return new Person[size]; &#125; &#125;; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public int describeContents() &#123; return 0; &#125; @Override public void writeToParcel(Parcel dest, int flags) &#123; //序列化 写出name 和 age dest.writeString(name); dest.writeInt(age); &#125;&#125; 以上具体的几个方法说明如下： createFromParcel(Parcel in)：从序列化的对象中创建原始对象 newArray(int size)：创建指定长度的原始数组 Person(Parc el in)：从序列化的对象中创建原始对象 writeToParcel(Parcel out,int flags)：将当前对象写入序列化结构中，其中flags标识由两种值：0和1。为1标识当前对象需要作为返回值返回，不能立即释放资源，几乎所有情况为0; describeContents：返回当前对象内容描述。如果含有文件描述符，返回1，否则返回0，几乎所有的情况都返回0 w相比较而言，Serializable是java中的序列化接口，虽然使用简单，但是开销很大，序列化和反序列化要实现大量的II/O操作。而Parcelable是Android中的序列化方式，因此更适合用在Android平台上，虽然使用麻烦，但是效率很高。","categories":[],"tags":[{"name":"android","slug":"android","permalink":"http://www.yppcat.top/tags/android/"}]},{"title":"ContentProvider用法详解","slug":"ContentProvider用法详解","date":"2019-03-09T10:22:28.000Z","updated":"2019-03-11T14:24:10.000Z","comments":true,"path":"2019/03/09/ContentProvider用法详解/","link":"","permalink":"http://www.yppcat.top/2019/03/09/ContentProvider用法详解/","excerpt":"","text":"在安卓中，我们可以使用内容提供器ContentResolver来获取其他应用程序的数据： Cursor cursor = getContentResolver().query(ContactsContract.CommonDataKinds.Phone.CONTENT_URI,null,null,null,null); public final @Nullable Cursor query(@RequiresPermission.Read @NonNull Uri uri, @Nullable String[] projection, @Nullable String selection, @Nullable String[] selectionArgs, @Nullable String sortOrder) { return query(uri, projection, selection, selectionArgs, sortOrder, null);} 类似上面的获取Cursor，其中的参数分别有以下含义： uri：指定某一应用程序下的某一张表(l类似SQL中 from table_name),注意一点，使用时要提前申请访问数据权限 ​ eg content://com.example.app.provider/table1 ​ Uri uri = Uri.parse(&quot;content://com.example.app.provider/table1&quot;); projection:指定查询的列名（类似SQL中 select column1,column2） selection:指定where的约束条件（类似SQL中 where column = value） selectionArgs:为以上条件指定具体的指（相当于SQL中where占位符提供的具体的值） orderBy：指定查询结果的排序方式（类似SQL中 order by column1,column2） 用以上方法获取到指定的cursor后，可用以下方式获取： if (cursor!=null){ while (cursor.moveToNext()){ //通过指定的列名获取相应的数据 String displayName = cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.DISPLAY_NAME)); }} 类似SQLite数据插入的方式，我们可以用以下的方式向指定表中添加数据： ContentValues values = new ContentValues();values.put(&quot;column1&quot;,&quot;text&quot;);values.put(&quot;column2&quot;,1);getContentResolver().insert(uri,values); 更新数据： ContentValues values1 = new ContentValues();values.put(&quot;column1&quot;,&quot;&quot;);//利用selection 和 selectionArgs参数来约束需要更新的条件getContentResolver().update(uri,values,&quot;column1 = ? and column2 = ?&quot;,new String[]{&quot;text&quot;,1}); 删除数据： //删除指定列column2中值为1的数据getContentResolver().delete(uri,&quot;column2 = ?&quot;,new String[]{&quot;1&quot;}); 实现自定义ContentProvider 先看一下ContentProvider中主要的几个方法： onCreate（）：初始化内容提供器的时候调用。通常会在这里完成对数据库的创建和升级等操作，返回true表示内容提供器初始化成功，返回false则表示失败。注意，只有当存在ContentResolver尝试访问我们程序中的数据时，内容提供器才会被初始化。 query（）：从内容提供器中查询数据。使用uri参数来确定查询哪张表，projection参数用于确定查询哪些列，selection和selectionArgs参数用于约束查询哪些行，sortOrder参数用于对结果进行排序，查询的结果存放在Cursor对象中返回。 insert（）：向内容提供器中添加一条数据。使用uri参数来确定要添加到的表，待添加的数据保存在values参数中。添加完成后，返回一个用于表示这条记录的URI。 update（）：更新内容提供器已有的数据。使用uri参数来确定更新哪一张表中的数据，新数据保存在values参数中，selection和selectionArgs参数用于约束更新哪些行，受影响的行数将作为返回值返回。 delete（）：从内容提供器中删除数据。使用uri参数来确定删除哪一张表中的数据，selection和selectionArgs参数用于约束删除哪些行，被删除的行数将作为返回值返回。 getType（）：根据传入的内容URI来返回相应的MIME类型。 URI写法： content://com.example.app.provider/table1 表示访问com.example.app这个应用table1表中的数据。此外，我们可以在这个URI的后面加上一个id： content://com.example.app.provider/table1/1 这就表示查询table1表中id为1的数据 此外我们可以使用通配符的方式来分别匹配这两种格式内容的URI： * ：表示匹配任意长度的任意字符 # ：表示匹配任意长度的数字 所以，一个能够匹配任意表的内容URI格式就可以写成： content://com.example.app.provider/* 而一个能够匹配任意一行数据的内容URI格式就可以写成： content://com.example.app.provider/table1/# 接着，借助UriMatcher这个类可以实现匹配内容URI的功能。UriMatcher中提供了一个addURI()方法，这个方法接收三个参数，可以分别把authority、path和一个自定义代码传进去。这样，当调用UriMatcher的match()方法时，就可以将一个Uri对象传入，返回值是某个能够匹配这个Uri对象所对应的自定义代码，利用这个代码，我们就可以判断出调用方期望的是那张表中的数据了。 eg: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137public class MyContentProvider extends ContentProvider &#123; public static final int BOOK_DIR = 0; //表中所有数据 public static final int BOOK_ITEM = 1; //表中单条数据 public static final int CATEGORY_DIR = 2; public static final int CATEGORY_ITEM = 3; public static final String AUTHORITY = &quot;com.example.ypp0623.decorator.provider&quot;; public static UriMatcher uriMatcher; private MyDataBaseHelper dbHelper; static &#123; uriMatcher = new UriMatcher(UriMatcher.NO_MATCH); uriMatcher.addURI(AUTHORITY, &quot;book&quot;, BOOK_DIR); uriMatcher.addURI(AUTHORITY, &quot;book/#&quot;, BOOK_ITEM); uriMatcher.addURI(AUTHORITY, &quot;category&quot;, CATEGORY_DIR); uriMatcher.addURI(AUTHORITY, &quot;catagory/#&quot;, CATEGORY_ITEM); &#125; @Override public int delete(@NonNull Uri uri, String selection, String[] selectionArgs) &#123; SQLiteDatabase db = dbHelper.getWritableDatabase(); int deletedRows = 0; switch (uriMatcher.match(uri)) &#123; case BOOK_DIR: deletedRows = db.delete(&quot;Book&quot;, selection, selectionArgs); break; case BOOK_ITEM: String bookId = uri.getPathSegments().get(1); deletedRows = db.delete(&quot;Book&quot;, &quot;id = ?&quot;, new String[]&#123;bookId&#125;); break; case CATEGORY_DIR: deletedRows = db.delete(&quot;Category&quot;, selection, selectionArgs); break; case CATEGORY_ITEM: String categoryId = uri.getPathSegments().get(1); deletedRows = db.delete(&quot;Category&quot;, &quot;id = ?&quot;, new String[]&#123;categoryId&#125;); break; default: break; &#125; return deletedRows; &#125; @Override public String getType(@NonNull Uri uri) &#123; switch (uriMatcher.match(uri)) &#123; case BOOK_DIR: return &quot;vnd.android.cursor.dir/vnd.com.example.ypp0623.decorator.provider.book&quot;; case BOOK_ITEM: return &quot;vnd.android.cursor.item/vnd.com.example.ypp0623.decorator.provider.book&quot;; case CATEGORY_DIR: return &quot;vnd.android.cursor.dir/vnd.com.example.ypp0623.decorator.provider.category&quot;; case CATEGORY_ITEM: return &quot;vnd.android.cursor.item/vnd.com.example.ypp0623.decorator.provider.category&quot;; &#125; return null; &#125; @Override public Uri insert(@NonNull Uri uri, ContentValues values) &#123; SQLiteDatabase db = dbHelper.getWritableDatabase(); Uri uriReturn = null; switch (uriMatcher.match(uri)) &#123; case BOOK_DIR: case BOOK_ITEM: long newBookId = db.insert(&quot;Book&quot;, null, values); uriReturn = Uri.parse(&quot;content://&quot; + AUTHORITY + &quot;/book/&quot; + newBookId); break; case CATEGORY_DIR: case CATEGORY_ITEM: long newCategoryId = db.insert(&quot;Category&quot;, null, values); uriReturn = Uri.parse(&quot;content://&quot; + AUTHORITY + &quot;/catrgory/&quot; + newCategoryId); break; default: break; &#125; return uriReturn; &#125; @Override public boolean onCreate() &#123; dbHelper = new MyDataBaseHelper(getContext(), &quot;BookStore.db&quot;, null, 1); return true; &#125; @Override public Cursor query(@NonNull Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) &#123; SQLiteDatabase db = dbHelper.getReadableDatabase(); Cursor cursor = null; switch (uriMatcher.match(uri)) &#123; case BOOK_DIR: cursor = db.query(&quot;Book&quot;, projection, selection, selectionArgs, null, null, sortOrder); break; case BOOK_ITEM: String bookId = uri.getPathSegments().get(1); cursor = db.query(&quot;Book&quot;, projection, &quot;id = ?&quot;, new String[]&#123;bookId&#125;, null, null, sortOrder); break; case CATEGORY_DIR: cursor = db.query(&quot;Category&quot;, projection, selection, selectionArgs, null, null, sortOrder); break; case CATEGORY_ITEM: String categoryId = uri.getPathSegments().get(1); cursor = db.query(&quot;Category&quot;, projection, &quot;id = ?&quot;, new String[]&#123;categoryId&#125;, null, null, sortOrder); break; default: break; &#125; return cursor; &#125; @Override public int update(@NonNull Uri uri, ContentValues values, String selection, String[] selectionArgs) &#123; SQLiteDatabase db = dbHelper.getWritableDatabase(); int updateRows = 0; switch (uriMatcher.match(uri)) &#123; case BOOK_DIR: updateRows = db.update(&quot;Book&quot;, values, selection, selectionArgs); break; case BOOK_ITEM: String bookId = uri.getPathSegments().get(1); updateRows = db.update(&quot;Book&quot;, values, &quot;id = ？&quot;, new String[]&#123;bookId&#125;); break; case CATEGORY_DIR: updateRows = db.update(&quot;Category&quot;, values, selection, selectionArgs); break; case CATEGORY_ITEM: String categoryId = uri.getPathSegments().get(1); updateRows = db.update(&quot;Category&quot;, values, &quot;id = ?&quot;, new String[]&#123;categoryId&#125;); break; default: break; &#125; return updateRows; &#125;&#125; MyDataBaseHelper如下所示： 1234567891011121314151617181920212223242526272829public class MyDataBaseHelper extends SQLiteOpenHelper &#123; private Context mContext; public static final String CREATE_BOOK = &quot;create table Book(&quot; +&quot;id integer primary key autoinCrement,&quot; +&quot;author text,&quot; +&quot;price real,&quot; +&quot;pages integer,&quot; +&quot;name text)&quot;; public static final String CREATE_CATEGORY = &quot;create table Category(&quot; +&quot;id integer primary key autoincrement,&quot; +&quot;catrgory_name text,&quot; +&quot;category_code integer)&quot;; public MyDataBaseHelper(Context context, String name, SQLiteDatabase.CursorFactory factory, int version) &#123; super(context, name, factory, version); mContext = context; &#125; @Override public void onCreate(SQLiteDatabase db) &#123; db.execSQL(CREATE_BOOK); db.execSQL(CREATE_CATEGORY); &#125; @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) &#123; &#125;&#125; 在Manifest中注册： 123456&lt;provider android:authorities=&quot;com.example.ypp0623.decorator&quot; android:name=&quot;.MyContentProvider&quot; android:enabled=&quot;true&quot; android:exported=&quot;true&quot;&gt;&lt;/provider&gt; 具体使用如下： 12345678Uri uri1 = Uri.parse(&quot;content://com.example.ypp0623.decorator.MyContentProvider/book&quot;);Cursor cursor1 = getContentResolver().query(uri1,null,null,null,null);if (cursor1!=null)&#123; while (cursor1.moveToNext())&#123; String name = cursor1.getString(cursor1.getColumnIndex(&quot;name&quot;)); String author = cursor1.getString(cursor1.getColumnIndex(&quot;author&quot;)); &#125;&#125;","categories":[],"tags":[{"name":"android","slug":"android","permalink":"http://www.yppcat.top/tags/android/"}]},{"title":"app冷热启动及优化","slug":"app冷热启动及优化","date":"2019-03-08T14:35:49.000Z","updated":"2019-03-08T15:08:14.000Z","comments":true,"path":"2019/03/08/app冷热启动及优化/","link":"","permalink":"http://www.yppcat.top/2019/03/08/app冷热启动及优化/","excerpt":"","text":"冷启动：当启动应用时，后台没有该应用的进程，这时系统会重新创建一个新的进程分配给该应用，这个启动方式就是冷启动。 特点：冷启动因为系统会重新创建一个新的进程分配给它，所以会先创建和初始化Application类，再创建和初始化MainActivity类（包括一系列的测量、布局、绘制），最后显示在界面上。 热启动：当启动应用时，后台已有该应用的进程（例：按back键、home键，应用虽然会退出，但是该应用的进程是依然会保留在后台，可进入任务列表查看），所以在已有进程的情况下，这种启动会从已有的进程中来启动应用，这个方式叫热启动。 特点：热启动因为会从已有的进程中来启动，所以热启动就不会走Application这步了，而是直接走MainActivity（包括一系列的测量、布局、绘制），所以热启动的过程只需要创建和初始化一个MainActivity就行了，而不必创建和初始化Application，因为一个应用从新进程的创建到进程的销毁，Application只会初始化一次。 冷启动优化方案： 1.使用背景图： 在style文件下定义如下主题： &lt;style name=&quot;AppWelcome&quot; parent=&quot;AppTheme&quot;&gt; &lt;item name=&quot;android:windowBackground&quot;&gt;@mipmap/bg_welcome_start&lt;/item&gt; &lt;/style&gt; 然后在Manifest中将启动页的主题设置为当前主题： android:theme=&quot;@style/AppWelcome&quot; 2.使用透明背景和全屏： &lt;style name=&quot;AppTransparent&quot; parent=&quot;AppTheme&quot;&gt; &lt;item name=&quot;android:windowFullscreen&quot;&gt;true&lt;/item&gt; &lt;item name=&quot;android:windowIsTranslucent&quot;&gt;true&lt;/item&gt;&lt;/style&gt; 或者： &lt;style name=&quot;APPWel&quot; parent=&quot;android:Theme.Translucent.NoTitleBar.Fullscreen&quot; /&gt; 这种就和微信的处理方式是一样的，APP启动时会有一种因为系统卡顿造成启动较慢的假象。 3.如下几点建议： 尽量不要让Application参与业务的操作 尽量不要在APPlication进行耗时操作，比如有些开发者会在自己的APP里一系列文件夹或文件（比如我自己），这些I/O操作应该放到”确实该使用的时候再去创建”亦或者是数据库的一些操作 尽量不要以静态变量的方式在Application中保存数据等。 4、减少LaunchActivity的View层级，减少View测量绘制时间 此外，可以通过如下方式测量APP冷启动和热启动的时间： adb shell am start -W [packageName]/[packageName.launchActivity]","categories":[],"tags":[{"name":"android","slug":"android","permalink":"http://www.yppcat.top/tags/android/"}]},{"title":"IntentFilter的匹配规则","slug":"IntentFilter的匹配规则","date":"2019-02-26T14:56:34.000Z","updated":"2019-02-27T15:48:14.000Z","comments":true,"path":"2019/02/26/IntentFilter的匹配规则/","link":"","permalink":"http://www.yppcat.top/2019/02/26/IntentFilter的匹配规则/","excerpt":"","text":"IntentFilter中的过滤信息有action、category、data，一个过滤列表中的action、category、data可以有多个，只有一个Intent同时匹配action类别、category类别、data类别才算完全匹配，只有完全匹配才能成功启动目标Activity。此外，一个Activity可以有多个intent-filter，一个Intent只要能匹配任何一组intent-filter即可成功启动对应的Activity。 1.action匹配规则：action匹配规则是Intent中action必须能够和过滤规则中的action匹配，这里的匹配是指action的字符串值完全一样。一个过滤规则中可以有多个action，只要Intent中的action能够和过滤规则中的任何一个action相同即可匹配成功，此外，action区分大小写。 2.catrgory匹配规则：和action有区别的是Intent没有category也能匹配成功，系统在startActivity和startActivityForResult是否会默认加上“android.intent.category.DEFAULT”这个category。但是一旦Intent中有category，不管有几个，一定要和过滤规则中的任何一个category相同。此外，为了activity能够接受隐式调用，就必须在intent-filter中指定”android.intent.category.DEFAULT”这个catogory。 3.data匹配规则：和action类似，如果过滤规则中定义了data，那么Intent中必须也要定义可匹配的data。 data的结构：data由两部分构成，mimeType和URI。mimeType指媒体类型，比如image/jpeg、audio/mpeg4-generic和video/*等，可以表示图片、文本、视频等不同的媒体格式。 URI的结构： &lt;scheme&gt;://&lt;host&gt;:&lt;port&gt;/[&lt;path&gt;|&lt;pathPrefix&gt;|&lt;pathPattern&gt;] eg: content://com.example.project:200/folder/subfolder/etc ​ http://www.baidu.com:80/search/info Scheme:URI的模式，比如http、file、content等，如果URI中没有指定scheme,那么整个URI的其他参数无效，这也意味着URI是无效的。 Host：URI的主机名，比如www.baidu.com，如果host未指定，那么整个URI中的其他参数无效，这也意味着URI是无效的。 Port：URI中的端口号，比如80，仅当URI中指定了scheme和host参数的时候port参数才是有意义的。 Path、pathPattern和pathPrefix：这三个参数表述路径信息，其中path表示完整的路径信息，但是它里面可以包含通配符“”，“”表示0个或多个任意字符，需要注意的是，由于正则表达式的规范，如果想表示真实的字符串，那么“”要写成“\\”,”\\”要写成“\\\\\\”;pathPrefix表示路径的前缀信息。 data的匹配规则和action类似， 它也要求Intent必须含有data数据，并且data数据能够完全匹配过滤规则中的某一个data。","categories":[],"tags":[{"name":"android","slug":"android","permalink":"http://www.yppcat.top/tags/android/"}]},{"title":"activity启动模式和intent filter","slug":"activity启动模式","date":"2019-02-20T14:50:26.000Z","updated":"2019-02-26T14:55:10.000Z","comments":true,"path":"2019/02/20/activity启动模式/","link":"","permalink":"http://www.yppcat.top/2019/02/20/activity启动模式/","excerpt":"","text":"Activity的启动模式： 1.standard : 标准模式，每次打开都会新建一个实例，而且会处于启动当前activity的activity的任务栈中 2.singleTop : 栈顶复用模式，在这种模式下，如果新的activity已经位于任务栈的栈顶，那么此activity不会被创建，同时它的onNewIntent会被调用，此时它的生命周期不会被调用。 3.singleTask ：栈内复用模式，这是一种单实例模式，只要activity在一个栈中存在，那么多次启动此activity都不会被重新创建，并且调用其onNewIntent。当一个activity具有这种模式，系统会首先寻找当前activity是否在当前任务栈中是否存在当前activity 的实例，如果没有则重新创建 4.singleInstance : 单实例模式。这是一种加强的singleTask模式，它除了具有singleTask模式的所有特性之外，还加强了一点，那就是具有此种模式的activity只能单独的位于一个任务栈中，换句话说，比如Activity A 是singleInstance模式，当A启动后，系统会为它创建一个新的任务栈，然后A独自在这个新的任务栈中，由于栈内的复用性，后续的请求均不会创建新的Activity，除非这个独特的任务栈被系统销毁了。 此外，对于singleTask模式的Activity，还可以通过TaskAffinity来指定Activity启动所在的任务栈的名字，未指定情况下会出现在和包名相同的任务栈中。 可通过一下两种方式来指定activity 的启动模式： 1.&lt;activity android:name=&quot;.Main2Activity&quot; android:launchMode=&quot;singleTop&quot;&gt; 2.Intent intent = new Intent(this,Main2Activity.class);intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);startActivity(intent); 此外增加FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS这个标记的Activity不会出现在历史的Activity的列表中，等同于在XML中指定Activity的属性android:excludeFromRecents=”true”。","categories":[],"tags":[{"name":"android","slug":"android","permalink":"http://www.yppcat.top/tags/android/"}]},{"title":"activity生命周期相关","slug":"activity生命周期相关","date":"2019-02-17T12:05:04.000Z","updated":"2019-02-17T13:49:08.000Z","comments":true,"path":"2019/02/17/activity生命周期相关/","link":"","permalink":"http://www.yppcat.top/2019/02/17/activity生命周期相关/","excerpt":"","text":"(1) onCreate : 表示activity 正在被创建，这是生命周期的第一个方法。在这个方法中，我们可以做一些初始化工作，比如setContentView去加载界面布局资源、初始化activity所需数据等，还可以在异常状态重建是利用savedInstanceState 获取需要的值。 (2) onRestart : 表示acticity正在重新启动。一般情况下，当当前activity从不可见重新变为可见状态时，onRestart就会被调用。这种情形一般是用户行为导致的，比如用户按Home切换到桌面或者用户打开了一个新的activity，这是当前的activity就会暂停，也就是onPause和onStop被执行了，接着用户又回到了这个activity，就会出现这种情况。 (3) onStart : 表示activity正在被启动，即将开始，这是activity已经可见了，但是还没有出现在前台，还无法和用户交互。这个时候其实可以理解为activity已经显示出来了，但是我们还看不到。 (4) onResume : 表示activity已经可见了，并且出现在前台病开始活动。要注意这个和onStart的对比，onStart和onResume都表示activity已经可见，但是onStart的时候activity还在后台，onResume的时候activity才显示到前台。 (5) onPause : 表示activity正在停止，正常情况下，紧接着onStop就会被调用。在特殊情况下，如果这个时候快速再回到当前的activity，那么onResume就会被调用。在此时用户可以一些数据存储、停止动画的操作，但是注意不能太耗时，因为这会影响到新activity的显示，onPause必须先执行完，新activity的onResume才会执行。 (6) onStop : 表示activity即将停止，可以做一些稍微重量级的回收工作，同样不能太耗时。 (7) onDestroy : 表示activity即将被销毁，这是activity生命周期中的最后一个回调，在这里，我们可以做一些回收工作和最终的资源释放。 常见activity生命周期的几种情况： (1) activity正常启动时，onCreate -&gt; onStart -&gt; onResume (2) 打开新的activity或者切换到桌面时：onPause -&gt; onStop，在这里当activity采用透明主题时比较特殊，不会回调onStop (3) 当在上面情况再返回当前activity时，onRestart -&gt; onStart -&gt; onResume (4) back键返回时 onPasue -&gt; onStop -&gt; onDestroy","categories":[],"tags":[{"name":"android","slug":"android","permalink":"http://www.yppcat.top/tags/android/"}]},{"title":"观察者模式","slug":"观察者模式","date":"2019-02-07T11:35:29.000Z","updated":"2019-02-07T11:46:08.000Z","comments":true,"path":"2019/02/07/观察者模式/","link":"","permalink":"http://www.yppcat.top/2019/02/07/观察者模式/","excerpt":"","text":"首先，实现观察者、被观察者接口 123456789101112public interface Subject &#123; void registerObserver(Observer o); //注册观察者 void removeObserver(Observer o); //删除观察者 void notifyObservers(); //当被观察者状态改变时，通知所有观察者信息&#125;public interface Observer &#123; //当被观察者的数据更新时，将更新的信息当做参数传递给观察者 void update(float temperature, float humidity, float pressure);&#125;public interface DisplayElement &#123; void display(); //用于显示更新的数据&#125; 被观察者对象的实现 123456789101112131415161718192021222324252627282930313233343536373839404142//被观察对象实现被观察接口public class WeatherData implements Subject &#123; private ArrayList&lt;Observer&gt; observers; private float temperature; private float humidity; private float pressure; public WeatherData() &#123; observers = new ArrayList&lt;Observer&gt;(); &#125; @Override public void registerObserver(Observer o) &#123; observers.add(o); &#125; @Override public void removeObserver(Observer o) &#123; int i = observers.indexOf(o); if (i &gt;= 0) &#123; observers.remove(i); &#125; &#125; public void notifyObservers() &#123; for (int i = 0; i &lt; observers.size(); i++) &#123; Observer observer = observers.get(i); observer.update(temperature, humidity, pressure); &#125; &#125; public void measurementsChanged()&#123; notifyObservers(); &#125; public void setMeasurements(float temperature,float humidity,float pressure)&#123; this.temperature = temperature; this.humidity = humidity; this.pressure = pressure; measurementsChanged(); &#125;&#125; 观察者被观察者逻辑的具体实现 123456789101112131415161718192021222324//观察者实现观察者接口和具体的数据展示public class CurrentContionsDisplay implements Observer, DisplayElement &#123; private static final String TAG = &quot;CurrentContionsDisplay&quot;; private float temperature; private float humidity; private Subject weatherData; public CurrentContionsDisplay(Subject weatherData) &#123; this.weatherData = weatherData; weatherData.registerObserver(this); &#125; @Override public void update(float temperature, float humidity, float pressure) &#123; this.temperature = temperature; this.humidity = humidity; display(); &#125; @Override public void display() &#123; Log.d(TAG, &quot;display: &quot; + temperature + &quot;::&quot; + humidity); &#125;&#125; 使用实例： 123WeatherData data = new WeatherData();CurrentContionsDisplay display = new CurrentContionsDisplay(data);data.setMeasurements(100,100,100); 代码地址","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.yppcat.top/tags/设计模式/"}]},{"title":"RxJava操作符","slug":"RxJava操作符","date":"2019-01-30T12:12:08.000Z","updated":"2019-01-30T12:18:56.000Z","comments":true,"path":"2019/01/30/RxJava操作符/","link":"","permalink":"http://www.yppcat.top/2019/01/30/RxJava操作符/","excerpt":"","text":"RxJava操作符详解","categories":[],"tags":[{"name":"安卓资源","slug":"安卓资源","permalink":"http://www.yppcat.top/tags/安卓资源/"}]},{"title":"android性能优化","slug":"android性能优化","date":"2019-01-29T13:36:14.000Z","updated":"2019-01-29T14:38:14.000Z","comments":true,"path":"2019/01/29/android性能优化/","link":"","permalink":"http://www.yppcat.top/2019/01/29/android性能优化/","excerpt":"","text":"1.优化布局 （1）减少布局嵌套，VIew树的高度不超过10层，使用RelativeLayout可以提高渲染的效率 （2）使用标签重用布局 （3）使用ViewStub延迟加载 （4）github开源工具检测布局 2.内存优化 获取应用程序最大内存//128MB int maxMemory=(int)(Runtime.getRuntime().maxMemory()/1024); 获取手机堆内存大小 MB int memClass=((ActivityManager)getSystemService(Context.ACTIVITY_SERVICE)).getMemoryClass(); int maxMemory=(int)(Runtime.getRuntime().maxMemory()/1024);//得到应用程序最大内存的kb大小 Log.d(TAG, maxMemory+””); int memClass=((ActivityManager)getSystemService(Context.ACTIVITY_SERVICE)).getMemoryClass();//得到手机最大堆内存的大小，java heap最大值 Log.d(TAG, memClass+””); Runtime runtime=Runtime.getRuntime(); //字节大小 long maxHeap=runtime.maxMemory();//最大java heap最大值 Log.d(TAG, “maxMemory”+maxHeap+””); long freeMemory=runtime.freeMemory();//获取申请但未使用java heap,单位byte Log.d(TAG, “freeMemory”+freeMemory); long usedMemory=runtime.totalMemory();//获取已经申请的全部内存 Log.d(TAG, “totalMemory”+usedMemory); long haveusedMemory=runtime.totalMemory()-runtime.freeMemory();//已经使用的heap内存 Log.d(TAG, “haveusedMemory”+haveusedMemory); long availableMemory=runtime.maxMemory()-runtime.totalMemory()+runtime.freeMemory();//当前可new出来的最大内存 Log.d(TAG, “availableMemory”+availableMemory); （1）堆内存：堆内存用来存放new创建的对象和数组，由虚拟机的垃圾回收器GC管理。调用System.gc()方法可以建议系统回收，但是开发者无法控制。 （2）Bitmap优化 在Bitmap对象使用结束时及时调用bitmap.recycle()方法释放资源；通过内存缓存（LruCache）和磁盘缓存（DiskLruCache）更好的使用（推荐使用Glide框架） （3）代码优化 常量使用static修饰符 static方法可以提高访问速度 尽量使用局部变量代替成员变量（as自带提醒） 减少对象的使用，尽量使用基础类型 eg: Sting s; better than String s = new String();(装拆箱) 不使用枚举！！（很消耗内存） 减少使用Iterator Cursor、Receiver、Sensor、File等内存大户的创建、回收、注册和解注册 避免使用IOC注解？？？（待理解） 利用SurfaceView代替View来进行绘图操作 View inflate后及时缓存 不用每次都去解析视图 3.Lint工具 4.Android Studio自带的Mrmory Monitor工具 5.使用TraceView工具优化 6.使用MAT工具分析应用内存 7.使用Dumpsys分析系统状态","categories":[],"tags":[{"name":"android","slug":"android","permalink":"http://www.yppcat.top/tags/android/"}]},{"title":"图片加水印","slug":"图片加水印","date":"2019-01-28T16:05:20.000Z","updated":"2019-01-28T16:26:34.000Z","comments":true,"path":"2019/01/29/图片加水印/","link":"","permalink":"http://www.yppcat.top/2019/01/29/图片加水印/","excerpt":"","text":"关于一些对于图片添加水印的处理，具体方法如下： `package yppcat.morethread;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import android.graphics.Canvas;import android.graphics.Matrix;import android.util.Log;import android.view.View; import java.io.File;import java.io.FileOutputStream; /** Created by 殷朋朋 on 19-1-28. */ public class BitmapUtils { private static final String TAG = “BitmapUtils”; /** * view转成bitmap (此方法在低分辨率手机上有可能出现返回null,可选用下面的重载方法) * * @param view 指定的view * @return 图片大小和view大小相同 */ public static Bitmap convertViewToBitmap(View view) { view.measure(View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED), View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED)); view.layout(0, 0, view.getMeasuredWidth(), view.getMeasuredHeight()); view.buildDrawingCache(); Bitmap bitmap = view.getDrawingCache(); if (bitmap == null) { Log.d(TAG, &quot;bitmap is null&quot;); return null; } return bitmap; } /** * view 转换bitmap * @param view 指定的view * @param width 图片的宽 * @param height 图片的高 * @return 图片 */ public static Bitmap convertViewToBitmap(View view, int width, int height) { Bitmap bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888); view.draw(new Canvas(bitmap)); if (bitmap == null) { Log.d(TAG, &quot;bitmap is null&quot;); return null; } return bitmap; } /** * 创建水印bitmap * * @param src 原图 * @param watermark 水印图 * @return 加完水印的图片 */ public static Bitmap createWatermarkBitmap(Bitmap src, Bitmap watermark) { if (src == null || watermark == null) { return null; } int w = src.getWidth(); //获取图片的宽高 int h = src.getHeight(); int ww = watermark.getWidth(); //获取水印宽高 int wh = watermark.getHeight(); Bitmap newb = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888);//创建一个新的和SRC长度宽度一样的位图 Canvas cv = new Canvas(newb); cv.drawBitmap(src, 0, 0, null);//在 0，0坐标开始画入src cv.drawBitmap(watermark, w - ww - 5, h - wh - 5, null);//在src的右下角画入水印 位置可自定义 cv.save(Canvas.ALL_SAVE_FLAG);//保存 cv.restore();//存储 return newb; } /** * 创建水印bitmap * @param src 原图 */ public static Bitmap createWatermarkBitmap(Bitmap src) { Bitmap watermark = BitmapFactory.decodeResource(App.getContext().getResources(), R.mipmap.water_mark); return createWatermarkBitmap(src, watermark); } /** * 将bitmap保存到本地 * @param path 文件目录 * @param mBitmap 图片 * @param quality 图片质量 0-100 * @return 是否保存成功 */ public static boolean saveBitmap(String path, Bitmap mBitmap, int quality) { File f = new File(path); if (f.exists()) f.delete(); try { FileOutputStream out = new FileOutputStream(f); mBitmap.compress(Bitmap.CompressFormat.PNG, quality, out); out.flush(); out.close(); return true; } catch (Exception e) { e.printStackTrace(); } return false; } /** * * @param src 原图 * @param watermark 水印图片 * @param paddingLeft 水平方向偏移量 * @param paddingTop 竖直方向偏移量 * @return 加完水印的图片 */ public static Bitmap createWaterMaskBitmap(Bitmap src, Bitmap watermark, int paddingLeft, int paddingTop) { if (src == null) { return null; } int width = src.getWidth(); int height = src.getHeight(); //创建一个bitmap Bitmap newBitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);// 创建一个新的和SRC长度宽度一样的位图 //将该图片作为画布 Canvas canvas = new Canvas(newBitmap); //在画布 0，0坐标上开始绘制原始图片 canvas.drawBitmap(src, 0, 0, null); //在画布上绘制水印图片 canvas.drawBitmap(watermark, paddingLeft, paddingTop, null); // 保存 canvas.save(Canvas.ALL_SAVE_FLAG); // 存储 canvas.restore(); return newBitmap; } /** * 根据给定的宽和高进行拉伸 * * @param origin 原图 * @param newWidth 新图的宽 * @param newHeight 新图的高 * @return new Bitmap */ public static Bitmap scaleBitmap(Bitmap origin, int newWidth, int newHeight) { if (origin == null) { return null; } int height = origin.getHeight(); int width = origin.getWidth(); float scaleWidth = ((float) newWidth) / width; float scaleHeight = ((float) newHeight) / height; Matrix matrix = new Matrix(); matrix.postScale(scaleWidth, scaleHeight);// 使用后乘 Bitmap newBM = Bitmap.createBitmap(origin, 0, 0, width, height, matrix, false); if (!origin.isRecycled()) { origin.recycle(); } return newBM; } /** * 回收bitmap * * @param bitmaps 数组 */ public static void recycleBitmaps(Bitmap... bitmaps) { if (bitmaps != null &amp;&amp; bitmaps.length &gt; 0) { for (Bitmap bitmap : bitmaps) { if (bitmap != null) { if (!bitmap.isRecycled()) { bitmap.recycle(); } bitmap = null; } } } } }`","categories":[],"tags":[{"name":"android","slug":"android","permalink":"http://www.yppcat.top/tags/android/"}]}]}